# 6: Migration

1. Migration - 29m
2. Practice 6-1: Examining the League Application - 21m
3. Practice 6-2: Using jdeps to Determine Dependencies - 5m
4. Practice 6-3: Migrating the Application - 8m
5. Practice 6-4: Adding a main Module - 6m
6. Practice 6-5: Migrating a Library - 4m
7. Practice 6-6: Bottom-Up Migration - 10m
8. Practice 6-7: Adding the Jackson Library - 8m
9. Skill Check: Migration - Score 80% or higher to pass

## 1. Migration - 29m

Let's go ahead now and take a look at the migration. This would be in lesson 6. Here we're going to use of a very nice tool called jdeps.

You remember we've seen this earlier. This name, we've seen it earlier. Now, of course, I said at some point in time we're going to use it. And now we're going to use it in this class.

So we're going to use jdeps to check the dependencies of individual JAR files in the SE 8 application, describe the difference between top-down and bottom-up migration, use the class path and the module path to run the Java SE 9 and 10 application, describes split packages and how that can happen, and, of course, describe cyclic dependencies in a way to address them.

So let's start by looking at application migration overview. Here, we do have an application. Typically, it's made of a bunch of JAR files in the application and a bunch of libraries that maybe your application needs. And then, of course, they all run on a JDK.

So let's take a look now at the League application. Here, we do have a JDM that makes use of a bunch of modules. And then we do have, of course, the JDKs are modularized. But here, we have a bunch of JAR files that represent libraries and JAR files that represent my application. And of course, the idea here is to be able to modularize these.

So of course, it's important that why the JDK is modularized, the other layers, as you see here, they basically are not modularized. And they're all based on JAR files. So this basically, the fact that we're using the JDK modularized, this would give us flexibility that allows us to start by migrating either the lowest layer, which is, again, in this case, the library, and then the upper level, or the vice versa.

And of course, if now run it, here's how pretty quickly you would run it if you want to run it, for example, on the Java SE 8, in this case, on a JDK 8. But assuming that this is running on a modular JDK, something slightly different is going to, in this case, on in this particular moderate JDK that works only with modules. But here we have only JAR files.

So what happens if, for example, you have all these JAR files that you put down here and on this command that you see on the slide? And then, of course, as you see, the module system will typically treat all these packages as if they are in a special module called, in this case, unnamed module. That's how it's going to look at that if you're on SE 9 or 10.

So this basically will lead us to what we call an unnamed module. All types must be associated with a module in Java SE 9 or 10. A type is considered a member of the unnamed module if it is in a package not associated with any module and loaded by the application.

Unnamed modules, again, in this case, would read all other modules-- remember that-- export all their packages. So they depend on all other modules. And they export all their packages.

They cannot have any dependencies declared on them and cannot be accessed by a named module. So named module has its own class called module-info.java file. So which means a named module is one with the module-info.java-- another module-info.java.

So now to be able to look at this migration where we went to migrate our application. Again, in this case, we have a couple of ways to do it. We can do either a top-down migration when, in this case, we'll go ahead and change the application JAR files into modules. So the league.jar file and the soccer become modules. So we migrated those first.

And now whats left for us is basically the library. The library, In this case, it is not modularized yet. So which means we added the module-info.java for the league and for the soccer modules. So that's why now they are modules, and they're not basically JAR flies like the old JAR files anymore. And now what's left for us is, in this case, the library.

Of course, now that we have the soccer and the league modularized, we pretty much have an idea. So we consider every single application module, and what does it require, and what does it export? So we look at the module league and what it requires, and what it exports as packages. The same thing with the soccer, we look at what it requires as modules, and what it exports as packages.

Then after that, so now, we can go ahead and run the jdep to check dependencies. Here's an example to where you can actually now find out about the dependencies, in this case, finding out about the league JAR file. It depends on other JAR files. And then the same thing with the soccer, depends on what other.

And then, of course, the display ASCII JAR file, it depends on what type of, in this case, JAR files are modules. That's basically what we have here. So we run the jdeps.

And let me run an example in front of you here. And you guys are going to do this, of course, in the practice. So here, for example, I have jdeps, and I run it. I just get a summary. And this will tell me about the basketball JAR files and then dependency in this case, and then, of course, the soccer JAR file, and then the display ASCII, and then the league.

So if I run this, I see now that the league.jar file depends on the display ASCII JAR file. The league JAR file depends on the java.base. And then the league JAR file depends on the java.logging, as an example.

I can go ahead also and, in this case, run it, in this case, by specifying, in this case, the [? class's ?] end of the [? build. ?] And then I can go ahead-- you guy are going to try this in the practice. We find that the classes depend on the display ASCII, java.base, and the java.logging.

You can even, by the way, look at recursive. You can use the minus r actually find out about the recursive, in this case, dependency, which means it's going to give us, in this case, all the so jdeps minus r minus s, and then minus cp. And then we specify the basketball, the soccer, and the display, and the jar, and the league.

And if I hit return and run this, you see now I found the basketball depending on the league.jar field the java.base, java.logging. The league also shows me about all the dependencies that the league depends on, in this case, which is basketball, soccer, display, java.base, java.logging, and then the soccer also. It show us how the JAR file depends on the basketball JAR file, the league.jar file, the base, the logging. And then, of course, the display ASCII depends on the java.base. So pretty much, we got all of them here. And that's what we have here.

So of course, we know that the soccer module, since we converted it into a module, so it has its own module-info.java where it says it requires the base, the logging, java.base, java.logging, even though not necessarily to explicitly list as a requirement, but we [? can ?] export soccer to league. That's what it has here.

And then the league module has a module-info.java. That pretty much, in this case, has the module league that requires the base, the logging, the soccer, and requires the display. Except that, wait a minute here. The display ASCII, unfortunately, it's a JAR file. So it can't be accessed on the class path because modules can't access classes on the class path. So again, what is needed here is some way to make it a module, even though it is not a module yet, is not one yet.

So the question here is, how do we now convert a library JAR to a module, which, in this case, our display ASCII JAR file to a module? Well, in our case here, we have a couple of ways to do it. We either write a module-info.java for it, for that library. Or we can go ahead and let it get converted automatically.

Sometimes, it might be a good idea to let it convert automatically. So of course, we know that if we now let it convert automatically, so put the library JAR file on the module path, and then boom, it will go ahead, in this case, and pretty much converts so that JAR file, as you see here.

By the way, any numbers after the name like dash 0, whatever, they're all gone. The module of the name-- or rather the name of the module that was, in this case, created automatically will be displayed dash ASCII. And you don't have the dash 0.1. And that's exactly what you have here.

So this converted into a module. And then this becomes an automatic module. Automatic module means it does not have the module-info.java file. That's what it means. And that's basically what we have here as that what we created.

And now, of course, here's is my now module league. Remember, the module league had a problem, in this case, and requires the JAR file. But then what we've done here is just by, in this case, running it, in this case, for the JAR file on the module path, and then automatically it gets converted into a module, and it becomes an automatic module. And now, of course, the league requires that automatic module, which is called display.ascii. That's basically what happened here.

So one thing that you need to remember about an automatic module is that it requires-- it exports all it's packages and requires all the other modules. That's why if you take a look here, you will see that the display ASCII, basically this now, as you see here, this is the typical application modularized. And now the display ASCII now is, of course, in this case, modularized.

The one thing that you need to remember is that the display ASCII now requires every other module. Remember, we said that it exports all its packages and requires all the other modules. And that's exactly what we have here.

So, one thing that you should say, or we should say about the automatic modules is that it is a JAR file that does not have a module declaration and is placed on the module path. It is basically nothing but a "real" module. It requires no changes to someone else's JAR files. It is given a name derived from the JAR file, except that the always dot extension, dot 0, whatever, it does not include it.

It requires all other modules, and can be required by other modules, and exports all its packages. Remember I said that also. It exports all its packages. Except that remember that it does not have its own module-info.java file.

Let's now take a look at the bottom-up migration. In our case here, let's assume that, in our case here, we migrate the library to a module, but then the league and the soccer stay as JAR files. That's what we have here. So that's the bottom-up.

So how do we go by now doing this bottom-up migration? Well, the display the display.ascii module, basically we're going to find out what it requires, what it exports. And then what we can do, in this case, is we can go ahead and use the jdeps.

And also we'll go ahead and generate for me, in this case here, we'll go ahead and generate the module, in this case, info. That can be used just by running jdeps dash dash generate dash module dash info. And that's basically what we have here.

So this basically allows us to create a module-info.java file based on all the dependencies that it's going to find. So here we run a module-info file. We have the display ASCII JAR files and writes to the module-info-file and display ASCII. And then it tries to create for you the module-info.java. Of course here, we'll end up with the league module.export display. And, of course, exports util, which, by the way, is not necessary here.

So now, once we put those JAR files on the class path, it requires all other modules. And we're going to end up, of course, in this case, having those convert into modules. Except that the exports all their packages. And they require all the other modules

And basically, here's a slide that pretty much tells us that we need to use the dash add, in this case, modules option, in this case, because the league.jar is running as an unnamed module. And, of course, the Java runtime, in this case, cannot determine what modules to resolve.

So we pretty much, in this case, add manually the display.ascii. And that's what we have done here, what's in the box here, dash dash add dash modules display.ascii. We added it manually here.

And, of course, at the end, we're going to end up, in this case, a fully modularized, in this case, application. Whereas you see here, the league depends on all the other modules. And the soccer depends on all the other modules.

Why? Because they are automatic in this case. We just pretty much convert them into automatic modules. And we know that automatic modules export all their packages and require all other modules. And that's what you see here.

Of course, and go ahead and run it. And when you run it, we're going to get the output here. So run it under java minus b. And then you have your dist league, and then the soccer JAR files, and then the library, and then, of course, minus League.jar, and main. And then pretty much this will go ahead and help us run the application.

Of course, this typically assumes that the library JAR file is under the control of the organization doing the migration. But in many cases, this may not be true. And you may have to, of course, either continue to use the library as an automatic module or wait until the library maintainer creates a modularized version of it.

You can do some module resolution here. You can use the dash show dash module resolution will limit modules to, again, limit the output. And then this pretty much allows you to see pretty much the, as you see here, the command, which can be used in this case. We'll try some of these examples in the practices.

Let's go ahead now and take a look at more on the libraries. In many cases in general, you can have a few libraries. And then you want to convert all of these into modules. You can do automatic in this case.

Let's assume that you have the jackson.core, and the jackson.databind, and the Jackson.annotations. These are libraries. And we want to convert them into modules.

So if they have converted using the automatic modules, then look what happened. They all are going to end up basically requiring all the other modules. And if we take a look at this, pretty much it looks a little bit messy showing you that all the libraries that we converted into modules, they pretty much end up requiring all the other modules.

For example, the jackson core requires the soccer, the league, the display ASCII, the logging, java.logging, java.base, and also the databind and the annotations. And it looks a little bit messy. But this is pretty much the nature of the automatic module.

Of course to run it, if you are not on the application with the jackson library, here's an example where you have the java minus p and then mods called lib minus m league/main. And if you run this, you're going to get this error that says, unable to make field private soccer SoccerTeam and HomeTeam. And accessible modules soccer does not opens soccer to module Jackson databyte.

And this, of course, is an issue. The only way for you because of the fact that libraries use reflection, and JDK 9 and 10, they do not use reflection. And that's why you end up having this problem. In general to solve these problems, what we need to do is you need to use the keyword opens. If you use the opens keyword, then, of course, this will allow you to, in this case, open a particular module for a library.

Here's an example. So you can go ahead and open the soccer to reflection from the jackson library by either putting the open for the entire module, which means the entire module is open to basically whichever. Or you can go ahead and use because we want to open just the package needed to all modules or to a specific module. So instead of using "open," it might be a good idea to use "opens." Because if you use open for the entire module, it's open to basically all the other modules.

Instead you can use opens. In this case, we can go ahead and write down module soccer. And then here, we can say, open soccer to jackson.databind. And that's it, not to everything. So that's why sometimes it might be a good idea to use the opens inside the module rather than open the entire module. Just for security it would be-- and, of course, for maintenance, it would be a nice idea to use opens in this case.

And now let's take a look that split packages. Well, one of the-- in general, one of the goal of split packages is how do we now basically handle the migration of a particular application that runs on SE 8, as an example? So what we can do is split the Java 8 into modules. And converting that Java 8 application that was organized for access control to be able to again make it.

So here, for example, I have my game.jar file that contains all those, in this case, classes. What we could do in this case, we can split this into modules. So here we can have the game module, and we can have the event module, as an example. So we can do that. And of course, then after that, all what you need to do is pretty much, in this case, look at your Java SE application design with a split package and see how we can now work this out.

So we can now look at the soccer.jar file. We say that implements the game. And we know that the soccer implements game, and then implements the game event. And then the soccer player implements the player. And then, of course, the soccer team implements the team.

And we can look at, in this case, the interfaces that provide the public API and the implementation using package-protected, not publicly available. So this pretty much example is straight particular design of a Java SE or early application where we split, in this case, packages that are used intentionally to achieve some degree of encapsulation. That's what we have here.

And the idea is that if a package name is reused in another JAR file, the classes in that package could be given package access, and, of course, therefore could be accessible to classes in the same package that are stored in another JAR file, but, of course, not accessible to other classes, in this case, that are not in that package. So of course here, two JAR files-- in two such JAR files that you see here, these two JAR files, basically can be now divided so that we can go ahead and modularize them. So here's how we do the migration, in this case, of split packages and JAR files to SE 9. So we can go ahead and convert that into-- so the League.jar JAR file becomes the league module, and then the soccer JAR file becomes the soccer module.

Of course, we know that addressing this split packages, encapsulation is achieved at the modular JAR level in the Java SE 9 or 10 through the use of qualified exports. Going to have the league that requires soccer, and then open the module soccer and export the soccer to league, as an example. So here, the API public and accessible to all, and then implementation public, but only accessible to league modules, as an example.

Now one of the problems that we have is the cyclic dependency. So here, the cyclic module dependencies are not typically permitted in SE 9. We know about that.

So here we have the module league that requires soccer. And then we open a module soccer, export soccer to league. And then it requires league.

So we have the league acquired soccer, and the soccer requires league. That's definitely, in this case, a cyclic redundancy. And we want to get rid of that. That's basically what we want to do.

So we can look at it. One possible approach is to remove the dependency that soccer has on league. We can do that. That's one way.

By, in this case, and instead create a new module that both the league and the soccer are dependent on. So that's one way. So we create basically a new module. And both, in this case, the league module and the soccer module depends on this new module that, in this case, we used.

That may be those who are slightly familiar with the database, the relation and mapping, remember the many-to-many, it is of the many-to-many by creating an associate class, and then so that we can create one-to-many, many-to-one. So just similarity, that they're different here. And this actually will lead us to the concept of Services, which we are going to see in the next lesson. That's pretty much the idea behind this.

So here's an example where, in this case, we have a cyclic redundancy between the competition and the basketball and the competition and the soccer. So we want to get rid of this. One way to get rid of this dependency is to create in this case, a game API module, and then have all of these, in this case, depend on the game API.

So we can have competition that depends on basketball and game, and then use the game API and have soccer and basketball depend on game API. So now competition depends on basketball and soccer. And then soccer and basketball depend on game API. And we got rid here, in this case, of the dependency. So now what we can do is we can make also competition requires game API transitively.

And that's basically what we want to show. So this actually lead us to a very interesting topic, which is related, in this case, to what we call Services. And we are going to cover this in the next lesson.

So here, what we've done is we use the jdeps to check the dependencies of individual JAR files in SE 8. We looked at the difference between top-down and bottom-up migration. We looked at using the class path and the module path to run the SE9 application. And then we looked at the split packages and how they can happen. And then we looked at the issue of the cyclic dependency, which, by the way, we solved using an extra module that the other modules depends on.

And, of course, we do have a few practices that we would like you to look at-- examine the league application, you running jdeps, migrating your application, adding a main module, migrating a library, and bottom-up migration, and adding the jackson library. So these are good practices. And we strongly advise you to try them. Please try them before you look at the solution. Thank you.

## 2. Practice 6-1: Examining the League Application - 21m

Now that we are done with lecturing of lessons six, let's go ahead and take a look at these practices. We start with practice 6-1. In this practice, we're going to examine an application written in SE 8 and assess how to migrate it to the modular SE 9. You will see some of the pitfalls of trying unorthodox approaches to achieve the encapsulation at the JAR level in the Java SE 8 and how the class path can exasperate some of these problems.

So first, they want us to start the NetBeans IDE 8. So that's one thing that I already did. So this is the 8.2 that I started. And then, of course, after that they want us to open the projects League, Soccer_1pkg and then Basketball_1pkg, which I already opened. That you see here.

And then after that, they want us to basically look at these projects. So under League, we do have, in this case, some packages-- the game, the main, and the util, and so forth. And then, of course-- so that's what I have over there.

And then, of course, after that, look at the other ones, basically examining them, looking at the League. So the League, as you see here, if you look at the libraries, contain Soccer_1pkg JAR file, Basketball_1pkg JAR file, and display.ascii0.1b 0 1 JAR file. So that's basically what it has.

And then, of course, looking at the other project, which is the soccer, and so that's basically what it has. It also has a game, a package, and a util package. And we can also look at the libraries here. It makes use of the League.jar file. And the util, as you see here, it has the game settings.

And then if we take a look at the basketball, it also has, in this case, a game folder, and a util folder, the game settings. And then, of course, if you look at the underneath libraries, it makes use of the League.jar file as you see here.

And then they want us to run, in this case, the league. And that's what we get. When you run it, that's the output pretty much, what we have here.

And then after that, they want us to, in this case, open a terminal under-- in this case, open the terminal and under the lob06 migration practices league and data, which are already here. And then run, in this case, this command, which is grep FINE from the soccer.log and show it one page a time. And that's pretty much what I have here.

Then they want us, after words, to examine, in this case, the Soccer_1pkg project. So we'll go ahead and, pretty much in this case, open it, [INAUDIBLE] Under, of course, in this case, the game package, they want to open, in this case, the dribble.java. That's what we see here. This class, again, implements a type of event, which is soccer event game.

And again, we should notice that the class is not public, as you see here. And this makes it more difficult to access these classes except via the public API of the league. The drawbacks is that the package name is and must be the same as that in the league project. It also means that all of these classes must be in the game package even though it may well make sense to organize them into two or more packages, for example soccer, a play in a soccer event, and so forth. That's basically what they-- again, all of this is part of the.

Again, try running the application with different library, so, in this case, in this time in the basketball a JAR file library. So open the main class, in this case in the main package of the league project. Just go ahead and do that. So here it is.

And then over there, we are going to get game type, instead of using soccer, we're going to go ahead and change it into basketball. And that's what we have here. And then we'll tell you, in this case, in our case here, to try to run it. So this is just to-- so we'll go ahead and try to run it in this case.

And then, of course, we get an error. And that's exactly what they want us to see. So we get an error. That's what it is. That's basically what they want us to do here.

And of course, if you right-click, in this case, on the league-- so this error, again, illustrates one of the dangers of splitting package names across different JAR files. If you look, in the game package, in the basketball and the Score_1pkg project and the soccer project, you would see that some of the class names exist in both packages. This is a problem because these identically name, the classes are different and contain different code, each pertaining to the game in question. So the drawback of how the class path works is involved here too because when a class is found on the class path, it will not be reloaded, even found again.

So when I click on the League project instead of properties, let's go ahead and do that, and then select the libraries. And as you see here, we select the libraries. Again, we should note that there are three libraries on the class path, in this case, the soccer, the basketball, and, in this case, and the third one, which is the displayAsk. And that's what we see over here.

So click on the soccer package, in this case, to highlight it. And then click Remove. So go ahead and remove that.

And then, of course, after that, we'll go ahead and now add the JAR library. So again, in this case, we'll go ahead and add the JAR library, in this case, folder. Navigate, in this case, to the labs. And let's go ahead and go look for the labs.

From labs, we go to Migration 6, and then practices, and then league, and then lib. And then over there, we select the Soccer_1pkg, in this case, an open it. And now it comes after basketball.

And then we click OK. And then we try to in the application again. But this time when you run it, guess what? You can go ahead and run it with, again, in this case, an output that you see here. So which means it works.

And now we can go ahead and change the get game type to soccer. So which means in the path now, the Soccer_1 now happens after the basketball. That's exactly what we have here. And that's why it worked.

So now we change this to soccer and then try to in the application again in this case. And so we'll go ahead and do that. And then you see, of course, there's an error. That's basically what they want us to do here.

Now, what we could do is-- so which means because the soccer comes after, in this case, basketball, that's why we have that. So we'll just go ahead and change this to basketball and then run it again. And that, of course, works properly.

So now in a terminal-- let me just see if I have-- so I have PWD. Oh, that's go to this, go to this. So let me go ahead now and take a look at-- open just at terminal. And in this terminal, I go ahead and, in this case, cd labs and 06 migration practices and league. And check whether the Java is, in this case, is 9, Java dash version, which is, again, 9.

And then now we'll go ahead and run java dash cp dist, in this case, forward slash asterisk, and then colon lib forward slash soccer package-- JAR file rater, and then lib, forward slash, display colon JAR file, and then main.Main. So java minus cp, and space dist, forward slash asterisk, colon lib, soccer colon lib, display JAR file, main.Main. I'm going to run this. And you see the output.

So we should note that you can use the asterisk instead of specifying the soccer package. The same thing display and the basketball. So of course, you should see, again, currently a modified application running in SE 9, it is not a modular application.

So as first move towards modularizing this application, again, just following basically the practice, that's what I'm doing. Just all what you're doing here is just following what they asked you to do in the practice. And that's why-- so I just ran this if you want.

So in the first move in this case, that's what I'm here right now basically towards, again, modularizing this application. A useful approach is to make each of the projects a separate module. However, we can predict that there will be a problem because of the common package names and the classes in the league project and, in this case, and in the soccer and basketball projects. And this configuration is called the split package and is not permitted between modules in SE 9. Additionally, the command line tool jdeps will not give us useful information about dependencies with these configuration because it won't see the JARs as distinct entries.

So what do we do? And what you find the league project to use new basketball and soccer projects that do not share a package, in this case, named between the API and its application. These projects named basketball and soccer have been set up so that all implementation are public. This is also not ideal. But we will address this issue later using the module system rather than attempting to address it using the class access modifier.

So in this case, we're going to close the projects, the basketball and the soccer 1.pkg projects. So we'll go ahead and do that. So we're going to close this project and close this project.

And then after that, we'll go ahead and click on the File tab, in this case, to expand the project. And they expanded basketball. So we do that, and then we open the two projects. So we open the other two projects, which, in this case, would be, in our case here, in the practice, we open the soccer and basketball.

That's what we're doing. That's what we have. And so that's basically what-- so we click on the file, and then we'll just expand, in this case, the league, and the soccer, and so forth just to see the classes.

And another thing that we want to do here is we want to copy the JAR file from the soccer distribution in this case this and then the soccer distribution. So we want to copy these, in this case, copy the soccer and the JAR file to the library files. That's basically what we want to do in this case. And so first, we'll start by expanding basketball, and soccer, and league. Let go ahead and do the same thing with league.

And so first of all, we are going to, in this case, delete these two here under the league. And then after that, we'll go ahead and, in this case, copy the soccer, in this case, expanding under soccer under league, and then copy the soccer.jar file into the League lib and so just by doing that, so here. So we have the soccer. Where is that soccer? Here it is.

So I'll just go ahead and copy this, and just put it inside the lib here. And then I can do the same thing for the basketball. And then, of course, put it inside the lib here. That's what we have. And pretty much that's what we have here.

And then, of course, after that, so we're done with this. We copied all those. And then we navigate to-- and then, of course, in this case, we have-- basically the whole thing is now created under the league.

In this case, we have-- so let me just see the factory here. So this factory here in the league project addressed some of the errors. So click, in this case, the top most of the errors, red marks to the right, and of the editor, a scroll down, this will take you to the error. Of course, this error is due to the implementation of the game interface.

So with the cursor on the same line, in this case, on the same line, press All Enter. And in this case, so that's place All Enter in this case. And click on the Suggestion icon on the left of the Editor pane. In this case, just showing this in this case.

And then so now we do have the suggestion. Pretty much all of this allows us to fix those errors. And that's what we have here. And so let me just disregard that. And so I do have this one here.

And do the same thing in here by doing a All Enter. And I need to just fix this one here. Pretty much all of this now come back to-- let me just quickly copy this here. We end up having this here as an example.

Well, here's a factory. And this basically has the other course. So I do Control-A, Control-C just quickly so I can fix this, Control-A, Control-V. And this, of course, will solve all your problems.

And this basically allows me to basically work with this here. So we get rid of this. And this is the example that I have here, which is the league that I have. And then, of course, I'm going to go ahead and close this one here. And this pretty much works properly. If I run this, then you see that it has the output without any problem.

And you can test the application, again, in this case. And pretty much I just tested it on that. It means you can also test on the command line if you want. And that's pretty much here what they want us to do in this practice.

## 3. Practice 6-2: Using jdeps to Determine Dependencies - 5m

Let's go ahead now and take a look at practice 6-2. Here we're going to use the jdeps to determine the dependencies. We use jdeps to examine the application and plan how you will complete a top down migration to a modular implementation because each JAR file will become a module you determine the dependencies for each JAR file.

So first we're going to run the jdeps on the League application, and this is the command that we're going to use, which is basically this one here. And if we run it, find out the JAR file depends on the display Ascii, the java dot base and the log in. Then after that, they want to, in this case, run the second command, where we run the summary, and then in this case, specify in this case, can substitute with the build classes for the dist League dot JAR file.

And this, of course, will take me to the next tab. [INAUDIBLE] load them and put them in the next tab. This will give me again in this case, the classes that depend on the display Ascii Java base and the law and the Java login. That's basically what we have.

And then, of course, after that, this is basically just showing yes in this case. A simple application, but you can, of course, see the main project, in this case. And then what about the soccer dot JAR basketball and display, and by adding the minus r, you do a recursive. In this case, a requirement of all these JAR files again will all be listed. In this case, this would be the next one with the minus r and you would see that this one here is in this tab. And then when I run it, this basically shows me whole thing here. The league JAR file, and then, of course, the display.

And that's what I have here. And by the way, you can also here I specified for the basketball and the display in the league JAR fire, but I can also specify that for the soccer if I want to in this case. I can go ahead and add the soccer, which I did not add, but I can go ahead and always add it in this case. So if I call it in this case under the after the call JAR file, I can do lib, and then I can do a column, in this case, a lib, and then specify the soccer JAR file, and then call and then after that. So if I run this, then in this case, I pretty much show everything if I wanted to show the whole thing.

And then after that pretty much here, we are in the level where pretty much we're running all of these, and then, of course, here we found out that there is some cyclic dependency, which is not like in SE 9. So one way to actually fix this is to use the jdeps that can write out a module dash info in this case. And that's what we're going to run here as a command, and I run this in the next tab.

So I did run it, and this is basically writing the modules for the league, the display, the basketball, and the soccer, so that's what I did. And then, of course, I can go ahead and look at them if I want. And then this is basically-- and then I can go ahead and also look at what's in the module dash info JAVA class for the League module.

And I did run this in the next tab, and that's what I found out. So basically, this is again just showing you what the league requires, the module requires, and then what it exports. That's basically what we have here. And this pretty much finishes this practice.

## 4. Practice 6-3: Migrating the Application - 8m

Let's take a look now at practice 6-3. Here we are going to migrate the application. So we begin the process of top-down migration for this practice and the remainder of these practices. We use a version of NetBeans that supports the SE 9 and its modulus, which means we're going to close the NetBeans 8 and work with the 9.

Here we're going to create a new modular project, which I pretty much already created here. And then, of course, we're going to create underneath the project, we're going to create different modules. OK? So we can go ahead and migrate every one of them. So under the project [? manager, ?] we create a new module, which is competition, which is here. And then we'll continue with that by, again, in this case, copying various packages from the version 8 in this case, which we have here, to the, in this case, the version 9. That's what we're going to do.

So following this basically step by step, copying, in this case, the different expand the league project in the source package like I showed you here. And then from there, go ahead and pretty much copy the different type of, in this case, of a packages, and copy the soccer and util packages from, again, in this case, the, in this case, packages from the 8 to the soccer module and by dragging that step by step. And then continue that with that. And do the same thing by creating a new module gameapi. And then you are going to do the same thing for the second one. And remember that, as we saw, duplicate package names are possibly in SE 8 [? across ?] JAR files but not permitted in SE 9.

So again, follow these instructions carefully and move the interface classes from the game package in competition to the gameapi package. In the gameapi, make sure that you move them to the gameapi package of the gameapi module. Again, in this case, do not copy, but move the classes. When you release the mouse click Refactor in the dialog the package name is different, and the IDE can help make the change. Again, the following are the, again, for the interface that you see-- Game, GameEvent, GameResult, Player, Team, and so forth.

Again, it may be helpful to note that, in NetBeans, interfaces are recognizable, because they have an icon that is different from the classes. You should note that you, again, may see an error-- a dialog box as dependencies are still not set up. If you do see a Warning, click Refactor again, and this should basically solve the problem.

And you continue with that basically, as you see here. And then after that, open the module-info.java. And then of course start adding all the required, in this case, just by following step by step, and look at what's required, and what's exported, and so [? in ?] under the soccer module, and the basketball module, and so forth. That's basically what you are going to do is the competition and so forth.

And then at the end you can go ahead and test it. So at the end you're going to end up having a basketball, and a competition, and a game, and a soccer. And then of course underneath here, the basketball, you're going to write the code that is required exactly following the steps in your activity guide of, in this case, the 6-3. So the basketball requires gameapi, requires logging, and exports basketball. Then the competition here requires gameapi, requires soccer, requires basketball, requires Java logging, and requires display ascii.

And then you have the gameapi that pretty much has the export. gameapi, pretty much following exactly what you were told here, of course, in the practice. That's basically what we're doing here. As you see, step by step, and that's what you are trying. And then of course under the soccer here, you also have the module-info.java here requires-- the soccer requires gameapi, the Java logging and exports the soccer.

And of course, don't forget that we already copied, in this case, all the Java classes. So here's the Java classes here [? under ?] the basketball. And then we also have, in this case, the game. And of course here's the main, and here's the util. We copied all of these from the old application, SE 8. And same thing here with the gameapi [INAUDIBLE] all the classes. If you remember, basically we kind of guided you step by step here by copying all of those here. And here it's pretty much what we see here. And that's exactly what I showed you.

And then the same thing under the soccer. Here's the soccer classes under the soccer package. And then of course you have, in this case, the util package. So you see, all of them now are inside. And that's basically the migration of that, in this case of the application. Again, following step by step exactly what we told you in this activity guide practice. And then at the end we just go ahead and move to the TeamGameManager and run the command. In fact, I do have this, which I already got there. And then I run it, and that's the output.

And that's pretty much what they want us to do in this practice. So the idea here is just follow step by step exactly what we told you here. And there is no way you are going to make a typo in this case.

## 5. Practice 6-4: Adding a main Module - 6m

Let's go ahead now and take a look at practice 6-4. Here, we're going to add a main module. In this practice, we are going to add another module named main so that the competition module represents the API of the application, and the main module calls that API. You also look at the module graph for the application to see how transitive dependencies might improve the design.

So here, what we're going to do is create a new module that calls the competition, create that. So this is basically what we have here. So we have a new module here that we created. And also what we have done here is basically add the following dependencies to the module-info for the main module, which is basically that's what we have. It requires logging, competition, and display.

And then, in this case, so we notice that even after adding, some of the packages in the competition module are not visible. So then, of course, in this case, in the module-info of the competition, which is this one here, now, of course, it's going to be-- we're going export game and utils. And that's what we have here.

Remove the required java.logging and requires display.ascii lines from the module-info of the competition. As you see there, gone. And pretty much in this case, so we've done that.

Move the PlayerDatabase classes to the main module. And in this case, we do have a PlayerDatabase and the PlayerDatabaseException inside the database, in this case, package. That's what we have inside the database package. That's what we did.

Of course, if the factoring does not work correctly, sometimes the development version of NetBeans does not complete the refactoring process correctly. If you have trouble with the refactoring functionality of NetBeans on this class, try either of the following. Otherwise, continue with, in this case, 2c.

So by canceling the refactoring, then copy the classes, delete the classes in the util package of the competition module, in the main class change the imports, and move the classes without refactoring. And then, of course, change the package for the PlayerDatabase class to database, and remove the line import from within the PlayerDatabase class. Add an import for the class util.settings in the PlayerDatabase class. Change the package for, in this case, the player and so forth.

That, of course, if things do not work. But in general, it works without any problem. Try that.

Clean and build the project. Examine the module graph In this case. Open the module-info.java in the main, and select the graph to view the module graph.

So here my main in this case. And that's what we have here. And of course, so open that. And so we'll go ahead and open this guy here, as you see here. And select the graph.

And this pretty much gives you an idea about how all that is done. That's basically what we are going to see. So kind of see better to what we have here. And maybe move these a little bit so you can see a little bit better, and so forth. So of course, you should notice that the display.ascii being an automated module requires all the other modules.

Again, change the competition module dependency on the gameapi module to transitive. That's what we have here. So we can see this inside, in this case, the competition. So it's transitive, gameapi. We already did that.

And then, of course, remove the main module direct dependency on the gameapi module by removing requires gameapi. So from the main module, that's basically why we don't have it here in the-- so we don't have it here, as you see.

And then, of course, another small improvement would be to limit the soccer and basketball module to export only to the competition. So that, of course, we'll see will be in our, in this case, is a [INAUDIBLE] soccer. And we see it here. And as you see here, explore the soccer to competition. And then also we inside the basketball, we have also exports basketball to competition. And that's basically what they asked us to do.

And that's what they want us to do in this practice.

## 6. Practice 6-5: Migrating a Library - 4m

Let's go ahead now and take a look at practice 6.5, migrating a library. In this practice, we migrate a display ASCII 01 dot BJAR to a modular library. You use the same name for the modular version of the library as was chosen automatically by the system when the JAR was loaded as an automatic module. That is display that ASCII, it's automatic name was based on the name of the JAR file.

So in the previous practices, we treated that JAR file as a library. However, in this practice, we assume that you have access to the JAR and can be modular and you can go ahead and modularize it. That's what we're going to do. So in our case here, we'll go ahead and open the project. So that's what I did, and then, of course, following pretty much the steps that they all asked us to do here. Let me just go ahead in this case and close this one here for now. And that's-- In fact, let me close all of these, and follow the steps so we can create a modular project called Display ASCII, and create a module in it. And then copy the two packages in that module, and that's basically what I have done here.

So we created a module, and then we created project as a module, and then we're inside. And then we copied these two from these two folders inside here, this module. And then, of course, I exported both. That's basically following exactly what they asked me to do. And then, of course, after that, we'll go ahead and build this module, and then we replace that display JAR file with the display JAR file. So in this case, we go through the File tab, and then we remove that JAR file from the team game project, and then we use the display JAR file.

And that's exactly what I have done here. So click on the file, in the file. So you see I replaced it, I removed it, by the way, and then I copied this from here to here, and that's basically. And then I got rid of the display JAR one be that we had before. And then, of course, Clean and Build, and basically that I already done.

And then, of course, run it. It ran properly without any problem. Here's the output, and then, of course, once I shut down NetBeans, and then they wanted us to open the module dash info dot JAVA, and then click on the graph and that shows me how in this case the main relies on that ascii that you see here. And all of this basically following all of this here. And that's what they want us to do in this practice.

## 7. Practice 6-6: Bottom-Up Migration - 10m

Let's go ahead and take a look at practice 6-6 here. It's the Bottom-Up Migration. In this practice, we look at the how bottom-up migration differs from top-down migration. Bottom-up migration is enabled by being able to use the class path and the module path together in the Java SE 9 application. You have completed the migration from the top-down, starting by modulizing the application itself, and eventually modulizing the display.ascii library.

However, given that the class path and the module path can both be used to run an application, it is possible to work in other direction. For example, you can first modulize display-ascii-0.1b.jar file, and run it on the module path while running the League.jar, Soccer.jar, and Basketball.jar back on the class path.

Then, you could continue the migration process by modulizing Basketball.jar, Soccer.jar, and League.jar. As you have already done all the modulization of these JAR files, it's not necessary to modulize them again. You can see how this bottom-up migration would work by simply running the application with some of its classes on the class path and some on the module path.

You could do this in the IDE by specifying which modules to place on the module path and JAR files to place on the class path. But it's much easier to use the command line to explore different options and that's what we do in this practice.

So in practice, we created these scripts, and ex1, ex2, all the way to ex6, and refer in turn to each other-- in this case, in turn to each other of the commands given in this practice. Of course, the scripts save some typing, but observe how, again, they work and experiment with them. And here, I'm going to just go ahead and show you each one of them.

And for example, we start with the first one, [? Exe.1, ?] which is pretty much this one here-- ex1, rather, and where, in this case, we're on it. But in this case, we pretty much are using the minus [? pcp ?] to specify in this case the-- some JAR files are loaded onto the class path. And minus p to specify that the display.ascii JAR module JAR is loaded onto the module path. And we navigate to that League directory in the practice, and then try this command.

Of course, when you try, it you're going to find an error like this. And that's exactly what they asked you to do. OK? And you get an error like this, a class not found. In this case, a class error, the no class defined found a error, and that's what we have over there. OK.

And then what are we going to do in this case is what is happening here. So we should remember that there-- here, we are attempting to run all the code except that the display.ascii module on the class path. In other words, everything except the display.ascii runs as an unnamed module.

So normally, the process of resolving modules is to follow the requirements until all modules have been loaded. But the unnamed module display, in [? other ?] module does not have any explicit requirements. Instead, it implicitly requires all other modules. So you need to add the display.ascii module so that it will be loaded.

OK, so we'll try, in this case, the ex2. OK, and this will be, in this case, specifying the ex2. When in this case, we use the dash dash modules display. OK, that's basically what we want it to. And of course, now, once you try it, it will go ahead and work without any problem. OK?

And then, of course, after that, we try some other commands that combine the use of class path and module path and this would be in ex3. And so and that's basically what we have here. So that's in ex3, which is this one here.

And so, in this case, we are basically, what we are doing in this particular case for ex3 is we have the java minus cp, and then a dist, then of course the basketball, then soccer minus p. And then, here, the display-ascii-0.1b.jar file. And then the dash dash module display module. Of course, instead of putting modularized jar display.ascii JAR file on the module path-- again, we put the display-ascii-0.1b.jar file on the class path. This causes it to become an automatic module named display.ascii that is then loaded using the --add-modules to add its automatic name. OK?

And we can see, again, more what is happening by adding the --show-module-resolution, in this case, if you want to do that.

And then, of course, after that, after that, we'll go ahead and, for example, we can try the command using the ex4. Let me go ahead and show you the ex4.

And here's the ex4, in this case-- where, in this case, we have the java --limit-module java.base comma java [INAUDIBLE] list dot show module resolution. That's the one that, you know, they want us to try-- if you remember, we said we can use the --show-module-resolution to the command again, but you need, again, to limit the module. Otherwise, you will see a very long list of a platform modules. That's basically we used in this case, the limit module that we see here. OK?

And of course, this-- we'll go ahead, in this case, and show you so you can go ahead and try it. And then pretty much, in this case, following the-- it will show you the, in this case, the output.

We can also try the one in ex4. Let me just go ahead and open that for you-- ex5, rather. Try the ex5. Here it is. And this basically, a command in this case, dash the-- has the dash dash module java.base.java.logging. A --show-module-resolution and then -cp, in this case, the submission basketball.jar, soccer.jar, and display a, you know, ascii. And then, of course, said --add-module display.

So of course, in this case, the resolution of these two commands are very similar. And in both cases, the resolution of the display.ascii shows the file it came from.

So however, in the first instance, where that file is and, more generalized, a JAR file, it is and marked as an automatic module. OK.

So and we can-- could do, by the way, add soccer. jar, basketball as a main module. You know try to think about it for a moment. So this can be done because of the dependency where classes in the module soccer and basketball implement interfaces in the game API module.

There are not-- you know, these are not the interfaces used in the league project. You know, in the league.jar. The competition module must, again, be combined with the soccer and the basketball modules. And the JAR-- league.jar file must be combined with the soccer.jar file and the basketball.jar. OK?

And so, again, the following is possible by having the, in this case, just following in our case here. Again, that's following the discussion. So again, the following is possible by having the league.jar file loaded on the class path, therefore on the main module; basketball.jar loaded on the class path, therefore an unnamed module, and the soccer.jar file loaded on the module path, therefore on an automatic module and named soccer. Of course, the display.ascii and named module loaded on the path-- the module path. OK.

So in this case, you can go ahead and try it, in this case, using the last one, which is the ex6. OK. And this is pretty much what we have here, where we have java --limit-modules java.base java.logging and show --show-module-resolution minus cp. And then the submission league.jar file, basketball.jar file, and then, of course, and then minus p. In this case, we have a display.ascii, and then the soccer.jar file, and then --add-module display.ascii. Soccer, in this case, main.

So we should notice that the --add-module needs to be used with at the automatic module soccer, now. As well as the display.ascii module. OK. This pretty much can go ahead and try this and that also will work properly.

So pretty much, this last example is not really a very realistic way to run the application, but it does illustrate how the class path and modular path can be combined to run a named module and automatic module and named modules in the same application. OK.

And that's pretty much, in this case, what they want us to do in this practice.

## 8. Practice 6-7: Adding the Jackson Library - 8m

Let's go ahead now and take a look at practice 6-7. Here we add the Jackson library. In this practice, we have another library to the application, this time a commonly used library used for the JSON support called Jackson.

So we put the JSON support code in its own module as it may be possible in the future that the application may support several types of storage, example SQL database, XML files, JSON files, and so forth. So here what we do is we create a new module and then the TeamGameManager called storage, and then, again, the code to interact with the JSON to store all the games in the competition that's already been written for you.

So we'll go ahead in the file browser-- or command line, go ahead, in this case, and copy the folder storage, in this case, in the practices to the Classes directory in the TeamGameManager storage, in this case. And of course, we'll just put and process these commands. And of course, this will add the storage package to the storage module, which we already have here.

So here's the storage package. And then all these are the classes that we added over there. That's basically what we have. We already created, in this case, a module called storage.

And then, of course, in this case, we'll go ahead, in this case, and open the module-info. And as the JSON code will be working to store an array of game types, adding the following again, in this case, would be requires gameapi. This should clear any errors.

And then, of course, because the main module, we need access to the classes in the storage package. And so, in this case, add the following to the module-info file for the storage module exports storage, which we already have here, exports storage, that we have here. And that requires annotation.

So again, following step by step, we can go ahead and, in this case, have the storage module requires the storage [INAUDIBLE] over there. And then, of course, under Main class, we'll go ahead and find the point where createAndPlayAllGames, in this case, method has just been called on the league object. In this case, add again, the line below this with the necessary code to save all, in this case, the game as JSON data.

So we have all of this here, by the way, in this here. And that's pretty much what they asked us to [INAUDIBLE]. So save to a JSON file, which we have here. And then here's the code that we needed to add.

And then, of course, try running the application. The application should run and produce the [? legal ?] result. But you see some error in this case.

And this is because the jackson.databind is using a reflection. This is pretty much the issue that we have here is because, in this case, again, [INAUDIBLE] solve this because the jackson.databind module is using a reflection to examine a field of the Soccer class. This field is private. So open is required to allow this happen. So if the field were public, then exports would work.

So in this case, we modify, in this case, the module-info.java of the soccer module. Let's go ahead and take a look at that. So it's already added here.

And you see here, it's open soccer to the jackson.databind. That's what we have here. That's what we added so that all of that works.

And then check whether the loading game works by loading a set of games and using those games to instantiate a league object. And again, the code lines in the Main class. And this would be here. And basically, this is what we have here as a code.

And, of course, just following the steps step-by-step. And here's storage Jackson util and getTheGame from, in this case, a JSON file. So here is pretty much the code that we have here.

Basically, the code needed to be added because, in this case, we can go ahead and create an instance of a league we have here. And we have, again, in this case, and that takes-- we have constructor in this case. That takes care of that.

And instantiate a new league, in this case, object using the Game array. And so that's what we have here inside the league. And let me just go ahead and look at the league in this case.

And we have-- this is the constructor that they want us to add, which is basically this one here in the Main class. Change the reference in the getDataGrid method, In this case, call to use this new League object that we have here. And all of this is basically inside my Main class here.

This is my Main class. DisplayDetail, that's basically what we have here, getGrid. And that's what they ask us to do.

Again, try running the application. And of course, this way-- notice that the results are different every time. And go ahead and [INAUDIBLE] that. Try it again. See, the results are different every time the run.

And this would be basically what needs to be done in this practice. Of course, the whole idea here is to be able to, in this case, work with the Jackson library. That's what you wanted to do in this practice.

## 9. Skill Check: Migration - Score 80% or higher to pass

Skill Check: Migration

View Skill Check
