# 7: Services
   
1. Services - 15m
2. Practice 7-1: Creating Services - 13m
3. Practice 7-2: More Services - 6m
4. Skill Check: Services - Score 80% or higher to pass


## 1. Services - 15m

Let's go ahead now and take a look at the services that we just discussed earlier in the previous last. So we are going to look at how services are supported in the SE 9 and 10, the distinction between a service supplying a concrete object versus a proxy object, and how services help address cyclic dependency.

Let's start with a service-based design. So let's assume now we have the example that we've been working on and basically that a league competition. And so we have the main module that depends on display.ascii. Main depends on competition. Competition depends on GameAPI transitively, and then competition depends on basketball and soccer. And of course, basketball and soccer depend on GameAPI.

But imagine that in addition to the basketball and the soccer, we maybe want to add another game, which could be any other game. In this case, could be maybe softball, could be baseball, could be, and so forth. So in our case here, we are, again, as you see here, we're going to end up having that new module that we added will depend on the GameAPI.

And then the competition will depend on that new module that we added, which represents some kind of a game. Right now, we have basketball and soccer, but we can add softball. We can add tennis. We can add baseball, football, and so forth.

So now, we want to just take a look at the service relationship. In general, we say we can have a game as an interface. Because after all, a game can be played as a basketball game, or as a soccer game, or as a baseball game, or as a football game, and so forth. And then we can have a competition module that uses the game to take care of its whatever competition information it wants to use.

And then, we can now have the soccer, in this case, a class that implements the game interface. Basically that's how we look at it. So we can have, for example, the league uses the game interface. But then the soccer implements that game interface. As an example. The league is within the competition, as an example.

So the way we are going to express the service relationship in Java SE 9 is we can say now that the module competition uses the game interface inside the GameAPI module. OK. So now, we have a new keyword called uses. Now, that's called the consumer module, and then we have the provider module.

This would be the soccer module. And here we can say, soccer module provides the game interface of the game module with a soccer class, under the soccer module. So now we've seen something in new keywords uses and provides with. That's basically what we have here.

What we could do is we can make use of a ServiceLoader class. We can now create a ServiceLoader of type game, and we can specify here the definition of the ServiceLoader. It turns out that it's a class, part of Java SE 9 and 10.

And this class is a facility to load implementations of service. Of service. So service is a well-known interface or class for which zero, one, or many service providers exist. A service provider would be the one that implements the interface in this case.

So here we have, so we can, again, in this case, the ServiceLoader as you see here going back to our API. Let's take a look at the methods, and one of the methods that we have is the Load that will allow us to create a new ServiceLoader for the given service type using the current thread's context class loader. That's what we have here.

So we go ahead and load an instance of the game, again, into the ServiceLoader. And then we create an array list of games called providers. And then we use a for loop for every current game in, again, from the game that we have. We go ahead and add the current game to the providers. And now we have a list, an array list, of, in this case, games. And that return the providers.

Now, choosing a provider class. We need to, again, choose. In this case, we know that the competition uses the game. And then the soccer and the basketball provides, both of them provide a game. So everyone implements the game interface.

The question that we have here is how do we now choose the provider class. In that case, it would be a good idea to have the game interface made declare a getType method that must be implemented by the soccer and the basketball classes, so that we can go ahead so the get type method can be used later on to determine if the provider supports the type of the game that we want or that we desire.

So for example, the code can be written this way. Where we got a game ServiceLoader that loads a game and then we use the for loop. And when we iterate through the whole game, and then we specify. If the current game invoke a .getType is, of course, to soccer, which means of type soccer then return the current game.

And if you finish iterating through the hole, in this case, a loop. And if, for example, in this case, the whole loop is finished, but then, of course, no provider is needed, is found. Then, in that case, we'll go ahead and throw a new runtime exception that says no suitable service provider is found in this case.

This pretty much allows us to work with services. So here's an example where, in this case, we can have the competition make use of the game, and then the basketball and the soccer provides that game interface. The providing means implement that interface.

And of course, what we can do is because we know that a cyclic dependency, when you have cyclic dependency. Example, we can have module A that requires modules B, and then module B requires module A. Well, we should know that before we had the game interface in its own module, GameAPI, and then we made the competition uses that game.

What we could do is we can move the game inside the competition module. So we should know that it is not a cyclic dependency if module A uses an implementation that lives in module B while module B requires module A. That's perfectly [? acceptable. ?] So which means here the interfaces can be in any module. And in the simple example application, it makes sense to put actually the game interface inside the competition module. And that's what we did.

All right. And then, of course, now we do have a competition uses the game. And then basketball and soccer and any other type of a sports game can also implement the game like maybe a basketball, or a baseball, or football, and so forth. That's the idea behind this.

This means that we're going to have an interface called Game, and it has getType, and getHomeTeam, and getAwayTeam, and so forth. And then the provider. And we have another interface called GameProvider that has getGame, getTeam, and then some classes will implement these.

So for example here, we can look at our example, the team manager application with additional services, and now we can have the competition that contains the tournament type as an interface and the game as an interface. We can make the league and the knockout implement the tournament type. And then the basketball and soccer implement the game.

And we can see this in the code. You guys are going to implement this. So we do have here in your second exercise of lesson, we have the game, which happens to be an interface. And it has its own abstract methods. And then, of course, we have the game provider, which is also another interface.

And then here in my soccer, I can now have a class called SoccerProvider, and the SoccerProvider implements the GameProvider. All right. And then we can do the same thing inside for the basketball. And you folks are going to try this. So then we have the basketball provider that implements the GameProvider. Implements all those methods.

And we can do the same thing within this case. If you remember, we also have the league and the knockout that implements the TournamentType. So we can look now at the competition. And the competition has a game, and they have the league here. That implements the TournamentType. And the knockout, also that implements the TournamentType, and that's what we have here.

So you are going to try this in the practice. So at the end, you're going to have, for example, the competition module will export game, exports gameapi, exports util, and then uses the GameProvider and the TournamentType interfaces as services. And then you will have the league and the knockout.

These both require the competition, and the league provides the TournamentType with the league class that implements the TournamentType interface, and then the knockout will require competition and provides the TournamentType through the knockout class that implements, in this case, the interface.

And the same thing with the basketball and the soccer. They both, again, require competition, require all the apis. And as you see here, the basketball opens the basketball to the jackson.databind. Same thing with soccer. And then the basketball [? provokes ?] the GameProvider with the BasketballProvider. We've seen the example of how that implementation is done.

And then the same thing with the soccer. It provides the GameProvider with the SoccerProvider class. That implements the interface GameProvider. And you are going to try this in the practice. In fact, if you take a look at all of this, you can look at all of these inside.

So here, you can open and as you see, it uses the [INAUDIBLE] and provides the TournamentType with the league and the knockout. And then you can see other ones too. So basically, pretty much all of them are similar to what I just showed you in the slide. And that's pretty much what I wanted to say about services.

As you see, services are really quite important. And we can make use of module that uses a proxy, which is an interface. And then the classes can actually provide the implementation of that interface. And definitely, this addresses the cyclic dependency issue that we discussed that.

We do have a couple of practices. One is to create service, and then the other one to add more services. So this is a couple of nice practices. We strongly advise you to try them. Please try them before you look at their solution. Thank you.

## 2. Practice 7-1: Creating Services - 13m

Now that we're done with lecturing Lesson 7, let's go ahead and create some services. We're going to start with practice 7.1. In this practice, we'll modify the Team Game Manager, an application, so that the basketball and soccer modules provide services. This is a superior approach to that currently taken and allows the addition of further team games without recompiling the Team Game Manager, except for the main class, which most likely would be created in its own project.

So this first thing, or rather, the first thing here to consider is how to acquire the necessary Java objects to create a league of soccer games and basketball games. In the Team Game Manager application, the creator of a new implementation of the game type can also create unique implementation of the team and a player to work with the game type. These new team and player types must implement team and player, but they could have other methods that are available to the game, a type object, or after casting, to the class that sets up and runs the league, in this case, the main class. Of course, for this reason, the factory method for creating, say, a soccer object, either needs to provide the functionality to also create a player and team objects, that are compatible with that soccer object, or needs to provide a proxy or a factory object to do this.

In this practice, we use the latter approach. It is simpler, because you are creating only one object, which in turn, creates the soccer player and team object. It also allows you to call on, in this case, the normal constructors on soccer team and game rather than having to call a no argument constructor, and thus, provide the method for populating the objects in a second step.

So in this practice we're going to create an interface in the game API, a package, called "game," again, another game provider. And this game provider here basically is this one here. And in this case, the game API, and that's the one that we have here. And it has "get game," "get player," "get team," and "get type," and these are abstract methods. That's basically what we have here.

And what we're going to do in this case is we are going to, in this case, create an implementation of this interface. So first we are going to look under the soccer, a package. And we have in this case the soccer provider, and we make it implement the game provider. So it's going to end up implementing the "get name," "get player," "get team," and "get a type," which, by the way, they're all explained here step-by-step how to basically code all of these.

And then we modify the factory class to use the services, instead of an extension object, by using the new keyword, as it currently does. So we open the factory class in the game package. So in this case, we go ahead and open the factory class, in this case, the game package. And so the factory is in the competition module. So go ahead and do that.

Here is my factory. So in this case, as you see here, pretty much we created a new method in the factory called a "get provider." That we have here. And then, of course, we code that.

So in this case, we have the get provider, which happens to be a static method. And we'll go ahead, in this case, and check, of course, in this case, if the provider, in this case, a load method on the service loader. And we get an instance of the a game provider, and add that, and then use the for-loop, kind of similar to what we've seen in the lesson.

And so get the current provider. Set it to provider, in this case. And then, of course, check the [INAUDIBLE], no return to runtime. Otherwise, return the provider, and that's what we have here.

That's basically what we have. And we have also the create team, a method that we need to implement. This is all, by the way, explained step-by-step here, pretty much step-by-step.

Here's the create team that I was talking about, and here's the create team. And then, of course, after that, we'll go ahead and create, in this case, a create team. Here is create game. You have the create creed game also that is implemented here, following, again, exactly what they asked us to do.

And then they asked us to create a player, and we have that. And that's basically what we're doing here, step-by-step. And of course, we might, in this case, model the Java. We'll go ahead and say that the competition uses the game provider. So we added that.

And pretty much, step-by-step they're telling us exactly what to add. So that's basically what I'm here right now. And add the provider statements, in this case, to the soccer and the export, out of the export soccer. So we have that.

So here the game provider with the soccer provider, and do the same thing in the basketball. Let's go ahead and do that. So this is pretty much straightforward. You see it here. So or rather, this is the game API would like to see, one of the-- so you see, it provides the game provider with the soccer provider, and do the same thing inside the basketball.

Where we have now, it provides the game provider with the basketball provider. That's basically what we're doing. So all of this is basically clean. And so that's basically what we are doing in this case, step-by-step.

Remove the unnecessary dependencies, in this case, in the module DAS Java of the competition module. Now we, again, in this case, they are no longer required, these guys here. So that's why we don't have them anymore.

And they're, in this case, a competition, a module. So we don't have them anymore. We just have the uses, the game provider, and that's good enough. So we don't have required soccer and basketball.

And so that's basically what we have. And, of course, determine how many times the game provider is being created. And so again, in this case, and determine how many in the factory class.

In this case, just go ahead just inside the loop that erased through the available game provider. Again, add the line A, in this case, a current provider to the console. And that's basically what we have here in the A factory.

And as you see here, and that's the code that they asked us to write down here. So run the application as, in this case, with a soccer the game type, and this would be our, in this case, and looking at, in the case, in the main. And that's basically-- so we're running this as the soccer type.

And then after that, we add the code to ensure the game provider is acquired when needed. So declare the game provider. Use the same name, the provider, and then the lead, the declaration game provider. And then here, in the get provider, in this case, method. But before the call to the service load, in this case, add this line.

So you get the get type and then type of provider. We already know about this. This is all inside here. So that's basically what we have as a code.

And we have the get provided here. So again, here we just check if it's-- and so basically just following the steps step-by-step, in this case. And this is the code that they asked us to do.

And then after that, invoke the get provider by passing the game type inside. And that's pretty much following step-by-step. That's what happens if there is no suitable A service. In this case, for example, change the game type again, in this case, to be, in this case, not a soccer and not a basketball. And you can go ahead and specify that and run the application and see what happens.

You are going to get a NullPointerException. So this is just kind of showing us how we can work with all of this. And of course, by clicking on Properties, and then we have the main under main, in this case. Which means if you go, in this case, to a main and opening the classes here, you will see that we specify soccer.

And if you run this with the soccer, we get the output. And imagine now, they told us to change this. Instead of soccer, let's go ahead and put hockey or anything that's not soccer or basketball. Let's go ahead and basically try, in this case, hockey and see what happened.

And if you run this, of course, we are going to get definitely an error, a RuntimeException, no question about that. And that's why we said, there's no need to specify in this case, because-- and then if we play soccer, then that typo, and then, of course, save it. And then when you run it, that, of course, we run property. And that's the output. And that's pretty much what they want us to do in this practice.

## 3. Practice 7-2: More Services - 6m

Let's go ahead now and take a look at practice 7-2. In this practice, we examine how services can be used for all the aspects of the application's functionality. For example, in the TeamGameManager application, services can be used to provide additional competition type, for example, knockout competition, display tabs, for example, a graphical display, storage types, for example, storage to a database, and so forth.

So in this practice, we look at how the TeamGameManager can be extended to provide another type of competition. Because you've already coded and configured services for the type of a game to be managed, you won't do any coding this time. Instead you will examine a completed application to see how the service implementation differs from the one you just created. So here we open the second practice, 7-2, in this case. And that is in the solution, which I already opened here.

And then, of course, they want us to examine, in this case, the Main class. So if you take a look at the Main class, which I already opened here, you would see now that we have the game type, and we have the competition type. And that's exactly what they want us to have here. And that competition can be a knockout or a league.

And try running the application, and that's basically what you get. You get the output, which you see here. That's pretty much what we have here as an example.

And of course, try changing the competition type and other and/or the game type. Run the application again, and it should respond with the application appropriate results. Try changing the composition type and/or the game type and just to see what you get here. For example, instead of having this, I can go ahead, in this case, and try, for example, the league, as an example.

And then I'll go ahead and run it. And I should be able to see a different output here. That's basically what we have here. And we had it before as a knockout. And if you run it, that's what you get as an output.

And of course-- again, looking at that, so we've done that. And of course, we should notice when you scroll down, in the case, the main, we should not this in this case how the tournament type, in this case, makes use of the getTournament method here that you see.

Examine again the TournamentFactory, which is this one here. And the TournamentFactory, here it is if you want to examine it. Open it.

You should notice that it is simpler than the Factory class that we've seen earlier as the getTournament static method. And the getTournament, that one takes a tournament type, a game, and the array of teams. And then the other one, a name here.

And of course, that's what we have here. So pretty much here showing us how that works. And we here see how it uses the populate method, pretty much following what they asked us to read here. And that's where I am here.

Then we examine the Knockout class. We open the Knockout class, which is this one here. And that's the Knockout class. And they just want us to open that. Again notice that-- and like the three classes that implement the game, Game, Team, and Player, Knockout as it is returned directly by the ServiceLoader class must have a no argument constructor. That's what we see here.

Of course, if you would like, you can also go through the application under the examples in lesson two an open and that project is what we're talking about. Open this-- we already opened this before. You will see that in is further-- that it is further development compared to the 7. So you would see that it is a further development of the one that we are doing in practice 7.

And this is basically how you find it. It's under the examples of lesson two. And we've already opened this before. And you can go ahead and dig in and take a look, just to have an idea what we added over there. And that's pretty much what they want us to do in this practice.

## 4. Skill Check: Services - Score 80% or higher to pass

Skill Check: Services

View Skill Check
