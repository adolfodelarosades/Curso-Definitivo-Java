# 7: Services
   
1. Services - 15m
2. Practice 7-1: Creating Services - 13m
3. Practice 7-2: More Services - 6m
4. Skill Check: Services - Score 80% or higher to pass


## 1. Services - 15m

Let's go ahead now and take a look at the services that we just discussed earlier in the previous last. So we are going to look at how services are supported in the SE 9 and 10, the distinction between a service supplying a concrete object versus a proxy object, and how services help address cyclic dependency.

Let's start with a service-based design. So let's assume now we have the example that we've been working on and basically that a league competition. And so we have the main module that depends on display.ascii. Main depends on competition. Competition depends on GameAPI transitively, and then competition depends on basketball and soccer. And of course, basketball and soccer depend on GameAPI.

But imagine that in addition to the basketball and the soccer, we maybe want to add another game, which could be any other game. In this case, could be maybe softball, could be baseball, could be, and so forth. So in our case here, we are, again, as you see here, we're going to end up having that new module that we added will depend on the GameAPI.

And then the competition will depend on that new module that we added, which represents some kind of a game. Right now, we have basketball and soccer, but we can add softball. We can add tennis. We can add baseball, football, and so forth.

So now, we want to just take a look at the service relationship. In general, we say we can have a game as an interface. Because after all, a game can be played as a basketball game, or as a soccer game, or as a baseball game, or as a football game, and so forth. And then we can have a competition module that uses the game to take care of its whatever competition information it wants to use.

And then, we can now have the soccer, in this case, a class that implements the game interface. Basically that's how we look at it. So we can have, for example, the league uses the game interface. But then the soccer implements that game interface. As an example. The league is within the competition, as an example.

So the way we are going to express the service relationship in Java SE 9 is we can say now that the module competition uses the game interface inside the GameAPI module. OK. So now, we have a new keyword called uses. Now, that's called the consumer module, and then we have the provider module.

This would be the soccer module. And here we can say, soccer module provides the game interface of the game module with a soccer class, under the soccer module. So now we've seen something in new keywords uses and provides with. That's basically what we have here.

What we could do is we can make use of a ServiceLoader class. We can now create a ServiceLoader of type game, and we can specify here the definition of the ServiceLoader. It turns out that it's a class, part of Java SE 9 and 10.

And this class is a facility to load implementations of service. Of service. So service is a well-known interface or class for which zero, one, or many service providers exist. A service provider would be the one that implements the interface in this case.

So here we have, so we can, again, in this case, the ServiceLoader as you see here going back to our API. Let's take a look at the methods, and one of the methods that we have is the Load that will allow us to create a new ServiceLoader for the given service type using the current thread's context class loader. That's what we have here.

So we go ahead and load an instance of the game, again, into the ServiceLoader. And then we create an array list of games called providers. And then we use a for loop for every current game in, again, from the game that we have. We go ahead and add the current game to the providers. And now we have a list, an array list, of, in this case, games. And that return the providers.

Now, choosing a provider class. We need to, again, choose. In this case, we know that the competition uses the game. And then the soccer and the basketball provides, both of them provide a game. So everyone implements the game interface.

The question that we have here is how do we now choose the provider class. In that case, it would be a good idea to have the game interface made declare a getType method that must be implemented by the soccer and the basketball classes, so that we can go ahead so the get type method can be used later on to determine if the provider supports the type of the game that we want or that we desire.

So for example, the code can be written this way. Where we got a game ServiceLoader that loads a game and then we use the for loop. And when we iterate through the whole game, and then we specify. If the current game invoke a .getType is, of course, to soccer, which means of type soccer then return the current game.

And if you finish iterating through the hole, in this case, a loop. And if, for example, in this case, the whole loop is finished, but then, of course, no provider is needed, is found. Then, in that case, we'll go ahead and throw a new runtime exception that says no suitable service provider is found in this case.

This pretty much allows us to work with services. So here's an example where, in this case, we can have the competition make use of the game, and then the basketball and the soccer provides that game interface. The providing means implement that interface.

And of course, what we can do is because we know that a cyclic dependency, when you have cyclic dependency. Example, we can have module A that requires modules B, and then module B requires module A. Well, we should know that before we had the game interface in its own module, GameAPI, and then we made the competition uses that game.

What we could do is we can move the game inside the competition module. So we should know that it is not a cyclic dependency if module A uses an implementation that lives in module B while module B requires module A. That's perfectly [? acceptable. ?] So which means here the interfaces can be in any module. And in the simple example application, it makes sense to put actually the game interface inside the competition module. And that's what we did.

All right. And then, of course, now we do have a competition uses the game. And then basketball and soccer and any other type of a sports game can also implement the game like maybe a basketball, or a baseball, or football, and so forth. That's the idea behind this.

This means that we're going to have an interface called Game, and it has getType, and getHomeTeam, and getAwayTeam, and so forth. And then the provider. And we have another interface called GameProvider that has getGame, getTeam, and then some classes will implement these.

So for example here, we can look at our example, the team manager application with additional services, and now we can have the competition that contains the tournament type as an interface and the game as an interface. We can make the league and the knockout implement the tournament type. And then the basketball and soccer implement the game.

And we can see this in the code. You guys are going to implement this. So we do have here in your second exercise of lesson, we have the game, which happens to be an interface. And it has its own abstract methods. And then, of course, we have the game provider, which is also another interface.

And then here in my soccer, I can now have a class called SoccerProvider, and the SoccerProvider implements the GameProvider. All right. And then we can do the same thing inside for the basketball. And you folks are going to try this. So then we have the basketball provider that implements the GameProvider. Implements all those methods.

And we can do the same thing within this case. If you remember, we also have the league and the knockout that implements the TournamentType. So we can look now at the competition. And the competition has a game, and they have the league here. That implements the TournamentType. And the knockout, also that implements the TournamentType, and that's what we have here.

So you are going to try this in the practice. So at the end, you're going to have, for example, the competition module will export game, exports gameapi, exports util, and then uses the GameProvider and the TournamentType interfaces as services. And then you will have the league and the knockout.

These both require the competition, and the league provides the TournamentType with the league class that implements the TournamentType interface, and then the knockout will require competition and provides the TournamentType through the knockout class that implements, in this case, the interface.

And the same thing with the basketball and the soccer. They both, again, require competition, require all the apis. And as you see here, the basketball opens the basketball to the jackson.databind. Same thing with soccer. And then the basketball [? provokes ?] the GameProvider with the BasketballProvider. We've seen the example of how that implementation is done.

And then the same thing with the soccer. It provides the GameProvider with the SoccerProvider class. That implements the interface GameProvider. And you are going to try this in the practice. In fact, if you take a look at all of this, you can look at all of these inside.

So here, you can open and as you see, it uses the [INAUDIBLE] and provides the TournamentType with the league and the knockout. And then you can see other ones too. So basically, pretty much all of them are similar to what I just showed you in the slide. And that's pretty much what I wanted to say about services.

As you see, services are really quite important. And we can make use of module that uses a proxy, which is an interface. And then the classes can actually provide the implementation of that interface. And definitely, this addresses the cyclic dependency issue that we discussed that.

We do have a couple of practices. One is to create service, and then the other one to add more services. So this is a couple of nice practices. We strongly advise you to try them. Please try them before you look at their solution. Thank you.

## 2. Practice 7-1: Creating Services - 13m
## 3. Practice 7-2: More Services - 6m
## 4. Skill Check: Services - Score 80% or higher to pass
