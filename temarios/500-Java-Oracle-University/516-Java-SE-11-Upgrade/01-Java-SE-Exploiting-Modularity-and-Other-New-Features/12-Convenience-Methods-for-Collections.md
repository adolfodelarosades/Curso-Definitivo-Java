# 12: Convenience Methods for Collections

1. Convenience Methods for Collections - 17m
2. Practice 12-1: of() - 5m
3. Practice 12-2: ofEntries() - 3m
4. Practice 12-3: Randomized Iteration Order - 2m
5. Skill Check: Convenience Methods for collections - Score 80% or higher to pass

## 1. Convenience Methods for Collections - 17m

Let's go ahead now and take a look at convenience methods for collections. These are new methods that we added in SE 9 and 10 for collections. And in this lesson, we are going to identify the goals of convenience methods, call the of and ofEntry methods from the List Set and Map interfaces, identify appropriate situations for using these convenience methods, and identify the implications of using these convenience methods.

So what are convenience methods? Basically, they're created with the criteria in mind-- what are common tasks developers perform, where does boilerplate coding encumber the developers, and what are tasks developers would like to perform? Again, the goal here is to empower the developer, reduce boilerplate code, improve readability, improve performance, and get the same amount of work done by typing less code.

Here are some of the convenience methods that basically we have seen. And we added in the SE9-- you're going to see some of them here-- the equals, compare, and mismatch. You'll see that. What else? We've seen the if as, the or, the stream, and requireNonNullElse or requireNonNullElseGet, and check index of the-- these are for the objects, and then we've seen the dropWhile, takeWhile, and so forth.

So the key collections here are the list. List-- basically elements are ordered according to how there are added. Elements are searchable by index and duplicates are allowed. The set-- elements cannot be sorted by index and duplicates are not allowed. And of course for a map, we have elements that are a key value pair and duplicates are not allowed. So of course, an example of a list-- ArrayList, LinkedList, Vector. For the set, you have a HashSet, a LinkedHashSet, TreeSet, and for the map, you can have a HashMap, a LinkedHashMap, a HashTable, and a TreeMap.

So now, creating a collection. Well, Java SE 8 allows us to create a collection by creating an ArrayList and then using the Add method. In Java SE 9 and 10, now we can do the same work using a new method called the static method called the of, in this case, method. So here, we can go ahead and create a list just using the of. And for the set also, we can create a HashSet for example here, and then we can use the Add method to add the elements to it. Or we can use the of method on the set, which is also a static method that is part of the set. And that also can add the elements to the set, as you see. This is new in SE 9 and 10.

The map also has the same thing. You create a HashMap and then add put, use the put method by adding key value pairs to it. Or you can use the SE 9 by using the of method. That takes a key value and a key value and keep on going on that. And you can go ahead and add that quickly. All of these were added to the API.

Of course here, the of convenience method is overloaded. How many a variants of the of methods exist in the set? You can go out and look at the documentation, or you can look quickly at the JShell. So here, I just used the JShell and set up often, then clicked the tab twice, and then you see that it's basically about 12. 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12. 12. The last one is the vararg, which means you have more than 10 elements. With 10 elements, it's just to avoid calling the garbage collector all the time, because you know whenever you have a new collection is changed, a new collection is created inside it. The old one has to be garbage collected.

So here, basically overloading, in this case, the of method. That's what we said. So again in this case, you have zero elements, and you have the vararg, greater than 10 elements, or you have a maximum of 10 elements. Again, the smallest return a collection of zero element, the largest return 10 elements. And then the vararg is, of course, in this case, is used to all the other sizes a greater than 10.

Why overload the of method? Of course, this is very useful, because overloading provides a performance and space efficiency. Varargs cause performance overhead, like I mentioned to you, were temporary arrays allocation, initialization, and garbage collection has to happen because every time you change the size, a new array is created or a new collection is created. Avoid vararg by specifying the variant with a parameter of 10 or less. This covers, again, the majority of the use cases anyway.

So this is really done for the purpose of performance. That's the purpose overhead. That's why most of the cases use 10 parameters or less. Use those instead of using vararg, because if you use the vararg and you have more elements, then of course, you're going to somehow make use of the garbage collection a little bit more.

So here's an example where you create an of map with the eight elements. So this is a map that basically using the of method and adding, in this case, the key value pairs. There are eight of them. That's not bad, as long as they are not-- and we can see an example about that. So here, the first one is using the of method for a list. We could run that. That's created a list for you-- the of. Or you can go ahead in this case and use the second one, which is in this case using creating a set. Using the method pretty much is going to do the same thing. As you see, prints exactly the same thing.

And in the third exercise, you're going to work with maps. Rather, it is not exercise. Example. And if you print those, pretty much you get the same thing. Using the of method also. That works. And that's what we have here.

So up to 10 elements, we got no problem. Of course, if it is now greater than 10 elements, then of course, in this case, it would be a good idea to use the of entries. So if a Map needs more than 10 elements, key and value pairs must be boxed as an entry, so that there is no vararg variant for the method in the map interface. So instead, we use the of entries that accommodates returning a map of an intermediate size. So we use the of entries method, as you see here. And we can see this in the practice, in this case, of entries that you see here. Practice three. All right we've seen that.

Other the characteristics that we want to cover here is that the of and the of entry is returned an immutable collection. That's important. So methods like add, set, and remove throw UnsopportedOperationException. Immutability is definitely a good thing. Why? Because it's automatically there. Say if it provides opportunities for efficiency, especially space. And common case-- initialize a collection from known values with which, again, never change.

So of course, the no general-purpose immutable collection-- previously existing in JDK-- and we can have an unmodifiable wrapper-- are, again, poor substitute. So the access through the wrapper is unmodifiable. If you can access the underlying collection, it is still modifiable. So here, for example, in this example, we basically create a new HashSet, and then we add to it A and B. And now we get that test set, and then we pass it to the unmodifiable set, in this case. So the test set is, of course, unmodifiable.

To be able to also be unmodifiable, wrapper works so long as the tester too is accessed. In this case to ensure immutability, we would need to structure your code in such a way again, in this case, which removes all the possible references to the test set. So in Java SE nine, immutable collection solution is much more elegant for developers to use. And we see that in this example. So you see. And we have a test, and we can make it unmodifiable. And then if we try to add data to it, then you see you can go ahead to the test and still add the data.

But then you need to make it and also the test two changes even if you don't modify the test two directly. Because we just added through testing, we know that a test two is created from test, because of this line here in line 16.

For the non null value, null values are disallowed in List or Set elements, Map, Keys, or Values. This avoids later the NullPointerExceptions. This keeps code simple and less error-prone. Null values are reserved for special cases in the API. For example, what would it mean if a Map.get returns null? The entry is optioned or the entry is present but its value is not. So what would that mean if Map.compute discovered a null? Again, the returning null has the effect of removing the entry. So there is no effect to store the null into a Map And we can see this example here. You can see this example here in number five here. And if you take a look here, and if you try to run this, you get a NullPointerException.

In terms of no duplicates, of course, in this case, duplicates in Sets and Maps cause an IllegalArgumentException. The new API model collection literals. Again, in this case, literals expect you to explicitly know and state all values ahead of time. So any duplicates are an indication of an error. Here's an example, where we have here a duplicate, A, and we can see this in the example. This would be the last one. And of course, if you run this, guess what. You get an IllegalArgumentException. Duplicate element A, as you see here.

All right, so randomized iteration order. Again, the iteration order of Sets and Maps key is random. The order of HashSet and HashMap has always been unspecified. External factors affect the iteration order. Of course, the probability of an external factor occurring may have seemed low, so this lured developers into thinking the order was stable. Programs which relied on precise ordering occasionally broke. So true randomization prevents a false sense of security, and of course problematic code will be revealed sooner.

So in this example of an external factor, again, the program gets different inputs or a security enhancement made by Oracle. So this change only applies to Collections created with the of and the of entries methods. Collections created the previous way will have an iteration order identical to a collection created in SE 8.

And here, we just give you a small quiz. Which two are important consideration when deciding to use an off-factory method to create a list? First is whether the elements need to be added to the list later, and second is one of the list may contain a null value, or whether the list may contain values. So that would be A-- this case either whether the elements need to be added to the list later or whether the list may contain, in this case, a null value. That would be A and C.

And so here, we just saw some of the convenience methods that we added. And we looked at the of and the ofEntry for List, Set, and Map interfaces, and we looked at appropriate situations for using these convenience methods. And of course, identifying the implications of using these convenience methods. We do have some practices for this. We're going to have a practice using the of and one using ofEntry and one using the Randomized Iteration Order, which is also very useful. Please try these practices before you look at their solution. Thank you.

## 2. Practice 12-1: of() - 5m

Let's go ahead and take a look at the practices of lesson 12 now that we're finished with lecturing it. We're going to look at practice 12-1. Here, by the way, you can go ahead and open the JShell in NetBeans, or you can go ahead and do it as a project in NetBeans. I'm going to look at it as a project in NetBeans. You can do pretty much the same thing in the JShell, too, if you want.

So here's a project in this case where I have a test class. And we know, by the way, that although the idea here is that-- I'm here just trying in it in NetBeans as a project in this case, a modular project. But you still can create this list inside the JShell-- pretty much the same thing. So the idea is to see how convenient method can be used to create a list. You also explore the immutability of the list.

So in this practice, we have a list of integers of objects here, a 1, 2, 3, 4, 5-- or the 4, 8, 16, and 32. And that's basically what they want us to do. And then, of course, explore what immutability means in the context of a collection. Just how immutable is this? So try calling the add method on the Add list to add the next power of two, which will be 64. Or, try to set method on the test list to replace an in the collection.

So if you take a look at this, and let's go ahead and try this, and as you see here, if we try this pretty much, or maybe replace, so go ahead and try this just to give you an idea. And obviously in our case here, the idea is to explore what immutability means in the context of the collection. So when we try to add the method on the [INAUDIBLE] obviously should not work. So let's go ahead and do that. In this case, and you see it gives me an error, unsupported operation, so we can not do that.

And we can do the same thing, by the way, by, in this case, trying to set, in this case, use the set method on the test. This will replace an element in the collection with 0. Let's go ahead and do that. And this would be this one here. Pretty much you can do it, by the way, on the JShell, exactly the same thing here. The second element with, in this case, 2 with 0. And then if you run it, pretty much you are going to have the same problem, an error, as you see here. So this is, again, just showing you how, in this case, this pretty much does not work.

And so we tell you here, try replacing a list altogether. And pretty much you'll also have the same problem. If you are going to try the whole-- to pretty much change the-- so here, for example, I go ahead and try to change the list altogether. And that also will give me, in this case, an error. Rather, oh, in this case, it will go ahead and get a list of 0 in this case. And then we print out. So trying to replace a list altogether, a test list equal to a new list that contains a single variable, we create a new list by calling, in this case, the of method. And that, of course, would work, as you see here.

And of course the note that we should say on this is that, although you can outright replace the collection by pointing your reference variable point elsewhere, any other attempt to modify the collection results in an error message. That's what we have done. So before you create a collection using these convenience methods, it might be beneficial to, again, first consider how these lists will be treated by your program and if the data may need to be, in this case, modified later.

So we've done this on NetBeans. So these, you can still, by the way, try these exactly on JShell. Pretty much the result will be exactly the same.

## 3. Practice 12-2: ofEntries() - 3m

Let's go ahead now and take a look at practice 12-2. Here, you can, by the way, try using the JShell or NetBeans. In my case, I'm trying NetBeans, and we're going to see how the entry convenience method can be used to create a map. This method is very similar to the of method. They are both static factory methods, which produce immutable collections. However, the of entry method is designed for creating maps within to mediate other and determinate number of elements and requires each map entry to be boxed.

Again, this practice examines again, in this case, some fake holidays as they are associated to dates. So here, we do have in this case, we create a map called test map, and we use the genetics to specify that this map requires a string and a key and a month date value. And then, of course, use the of entry method from the map interface to set the values of the test map. Again, here we set the map, keys to five fake holidays, and then the values to also, in this case, some days, some holidays here that happen.

And of course, this is pretty much what we have here. And again, an example of creating a Monday off and then, of course, a April 1 and so forth. And that's what we have here. So pretty much here, we have a part two in this case that we are using in our case here. And so we do have a map made of string and a month day. And of course, we'll use the of entries, and then we enter the key and a value for every one. Use the of month and then January 16, February whatever. And then after that, we use the, in this case, [INAUDIBLE] use the foreach and print the key value pairs.

I right click on this and run it, that's what I get as an output. By the way, in the first part here, we just have a list, and pretty much what we've done in the first exercise. So that's pretty much what they want us to do. You can go out and try, by the way, on JShell. Pretty much exactly the same.

## 4. Practice 12-3: Randomized Iteration Order - 2m

Let's go ahead now and take a look at practice 12-3. Here we use the JShell or NetBeans-- I'm using NetBeans to examine a randomized iteration order of elements within a set. Because iteration order is randomized, writing code that depends on the iteration order is more easily revealed and can be addressed. So here we go ahead and create a set called test set, and use the generic to specify there type integer objects, use the of method from the set interface to create that set, and it's made of the set of these elements.

And then we write an enhanced for loop to iterate through the set, and then print that. So we shall observe that the order elements are printed, and when we run this few times, you will see that there is, in this case, a different output. When you run this we'll see different randomized output. Let's go ahead and take a look at that.

So here's test set using the element 0, 1, 2, 3, 4, 5, and then we use the for each for loop just to print that. And when we were on the program to see different orders, let's go ahead and try that. So we start again on it here, and you see now we have 2, 3, 0, 1, 4 5, run it again. Now 4, 5, 0, 1, 2, 3. Another one, 4, 5, and so forth. So you see to have different orders, because it is randomized, and that's pretty much what they want us to do in this practice.

## 5. Skill Check: Convenience Methods for collections - Score 80% or higher to pass

Skill Check: Convenience Methods for collections

View Skill Check
