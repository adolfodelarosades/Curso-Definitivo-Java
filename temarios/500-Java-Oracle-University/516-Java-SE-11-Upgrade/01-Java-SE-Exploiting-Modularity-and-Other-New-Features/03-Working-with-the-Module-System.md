# 3: Working with the Module System

1. Working with the Module System - 41m
2. Practice 3-1: Creating a Modular Application from the Command Line - 4m
3. Practice 3-2: Compiling Modules from the Command Line - 3m
4. Practice 3-3: Creating a Modular Application by Using NetBeans - 10m
5. Practice 3-4: Requiring a Module Transitively - 8m
6. Practice 3-5: Beginning to Modularize an Older Java Application - 5m
7. Skill Check: Working with the module system - Score 80% or higher to pass

## 1. Working with the Module System - 41m

Let's get into lesson three, which is on working with the module system. In this lesson, we are going to describe the purpose of the module-info class. We are going to create modules with defined module dependencies and module encapsulation. We also are going to talk about compiling modules and creating modular JAR files on the command line, and finish by describing how NetBeans IDE organize its folders for a source, compiled modules, and modular JAR files.

Let's start with the setting up modular dependencies and encapsulation. And we always of that type of question, which says, what is a module? Well, modularity adds a higher level of aggregation above packages. The key new language element here is the module, which is uniquely named, and its reusable group of related packages as well as resources, like images and XML files, and a module descriptor specify.

This module descriptor specifying the module's name, the module's dependencies, that is, other modules this module depends on, the packages it explicitly makes available to other modules-- of course, all other packages in the module are implicitly unavailable to other modules-- of course, the services it offers, and the services it consumes, and to what other modules it allows a reflection.

So, of course, let's take a look now at the module dependencies. And we're going to look at this with the keyword requires, which is quite an interesting keyword. And basically, what a requires does is it's a directive that specifies, in this case, that this module depends on another module. This relationship, of course, is called a module dependency. And every module must explicitly state its dependencies.

Of course, when a module A requires a module B, module A is said to be read Module B. And then Module B is read by module A in this case. So which means module A is said to read Module B. And Module B is read by module A.

And, of course, in addition, there is also a requires, in this case, transitive. And what requires transitive basically, it is pretty much an implied readability. The idea here is to specify a dependency on another module and to ensure that other modules reading your module also read that dependency, known as implied readability. And, of course, there is a requires static. requires static is a directive that indicates that a module is required at compile time, but is optional at run time.

We also have another keyword, which is exports. So pretty much exports, in this case, it's a directive that specifies one of the module's packages has public types. And their nested public and protected types should be accessible to code in all other modules. So here we have, like you see here, directives, the exports, package name directives specifies a package whose public types are accessible to all other modules.

And we have the exports package to, so which means package name to. This restricts the availability of an export package to a list of specific modules. So, they the export to directive enables you to specify in a comma-separated list precisely which modules or modules code can access the exported packages. This is known as a qualified export.

Now looking at graph 1, which is an interesting type of a graph here, we see that, in this case, the module system resolves the dependency expressed in its requires clauses by locating additional observable modules to fulfill those dependencies, and then, of course, resolves the dependents of the those modules, and so forth, and until, of course, every dependence of every module is fulfilled.

So here for example, we do have, in this case, a module c, which is to exports x, package x. And then it exports y. But that it exports package y only to d. That's the idea behind this.

And then as you see here, we make module b a requires, in this case, a module c, which means module b now has access to the package x of module c. And then we have more module d, which requires, in this case, of course, module c. And because, in this case, a module c decided to export y, the package y only to d. So which means, in this case, the-- in our case here, the b that you see package over there, has access to, in this case, package x, but not package d because c decided to export y only to d.

And, of course, another example is the one in graph 2, module graph 2. Again, this example that you see here, we have module c exports a package x to all the interested modules and package y just to d in this case, to module d. So which means, in this case, that in our case here, if we look at a module c, and this would be the diagram-- the blue here a rectangle, the big one here that you see, it has module c, it's called module c-- we see that in this case, the class L that you see here is visible to module b and d because it's in package x. And we know that Module b requires c and module d requires c. So that's good.

And then if you look at class N, which is in package x, so class N, in this case, as you see, it is not visible to Module b and d because it's not public. As you see here, we did not make it public. On the other hand, class L, it is public that you see here.

And then a class M is not visible to, in this case, module b because its package is y. And we know that y is only exported to module d based on what we wrote here in the module-import class. And class O here, which is in package z, is not visible outside c because package z is not exported. As you see here, module c exports only package x and package y specifically to d. And that's it.

Now, let's go ahead and get into the next slide and get into a transitive dependencies. So here we do have now, if you took a look at the example, or at least in this example that you see here, we have Module b that has a transitive dependency on c. So here we do have module c exports x and export y to b. And then we have module a that requires module b, but as you see here.

And then we have a module b requires c transitively. That's what we see here. So module b has a transitive dependency on c.

We should note that in the module graph, dependencies between modules are shown with the dotted line. And the transitive dependencies are showed with a solid line. So which means from b to c here, that's a transitive because the solid line. On the other hand, from module a to Module b, that a is with a dash. And that would means in this case it is, in our case here, dependency between the-- the dotted one, in this case, with the dependency between modules.

So which means here we decided that b requires c transitively. and there is a transitive dependency on that. So which means here that Module b must be, again, a transitively require module c. As you see here, module a must declare its own requirement for module c in this case. That, of course, in order for the module a to have access to the type N in this case.

So in our case here, if we have a scenario where the Module b provides an API, and for this reason, it is required by module a. So in addition, imagine that the API returns a type L. So that exists in package x in module c. So in order for module a to have access to this type L, either Module b must transitively require module c that you see over there on the graph, or module a must declare its own requirement for module c.

Let's not discuss the access types to types via reflection. So, of course, as you know, or as you might know, before JDK or Java SE 9 a reflection could be used to learn all about a types in a package and all members of a type, even if it's primitive member or other private members, whether you wanted to allow this capability or not, again, which means nothing was truly encapsulated, really, in the Java SE 1 through 8.

So one key motivation of this modularization system is a strong encapsulation. So which means, in this case, we have a module that may be set up to allow runtime only access to packages by using the opens. So we're going to use the opens.

And opens is a directive that allows you to specify a package so that all its types are accessible via reflection. This basically indicates types with a nonpublic access. We do also have another keyword, which is the opens to. And the opens to directive makes a package available to a list of specific modules at runtime but not compile time.

So, if we now use the opens for the package, it's similar to using exports. But it also makes all of its nonpublic types available via reflection. So this means that modules that contain injectable code should use the opens directive because injections work via reflection, of course. And, of course, all packages in a module can be made available to access via reflection by using the opens directive before the module directive.

And we see an example here where we have a opens module c, in this case, open module c, which is-- you open a module c. There is no s here as you see here. So what does it mean? What does it mean when we put an opens in from the module c here? It means that all packages in module c open to access by any other module via reflection.

And in the second example here, we do have module c, exports module c, and then opens y, and open z to b. So what does it mean? Well, it means that package y opens to all other modules because we just have opens, which means you can put an open right in front of the name of the module.

If you want to put it in front of the package, it's going to use an "s", opens. So, this means that package y open to all other modules to access via reflection. And, of course, we also have package z that open to Module b to access via reflection, which is, in this case, z is open to only b via, in this case, reflection.

Let's get now into an example Hello World modular application. So in this [INAUDIBLE] pretty much, this example is a simple one. And we call it Hello World application with a couple of modules. It will be, again, in this case, the idea is to use it to illustrate compiling and running modular applications.

So the third module is called greeting. And it's under the package greeting. We import Logger and import, of course, in this case, another package in the World. And then we have the class Hello that has a main method and, of course, a text, a [INAUDIBLE] string array, and then prints basically "Hello" and "World.say" calling the same method, which means in our module world, which is sitting in package world, we have the class World, which has a static method, say, which returns, in this case, a string, in this case, called "World."

So now looking at this example, let's just take a look at the structure, the word structure of file structure in this case. So if you take a look here, and at the mode source, we do have, in this case, the root directory same as module name for a multi-module compilation. So here, for example, we are greeting that contains, in this case, the greeting. And of course, which underneath, we have to Hello.java, which we've seen earlier here. That's the class Hello.java.

And then we do have another package world. And, of course, as you see here, end at the root, we have also the module-info.java, which is created for automatically. We've seen that in the example on NetBeans.

And then under the package world, we have another one, module-info.java, which is created for you. Of course, the first one here under the greeting, it will have a module called greeting. And it has requires world because we now are using world, as you see here, inside the class, in this case, Hello.

And in the second module-info.java under the module, in this case, in the package, as you see, world, we have world exports world, In this case, which exposed world package. And under the world package, we have the World.java, which is the Java class that we have over there.

Now, let's take a look at how-- let's take a look at how we compile and run modules. And we're going to do that at command line. That's what we want to do.

When, of course, compiling a single module, all source files must be compiled, including the module-info.java file. And, of course, the output folder, in this case, needs to be set to the directory you wish the modules to be placed in. Of course, if you do have a multi-module application, it can be compiled by using a sequence of single module compilations. But this, of course, is not ideal, as it requires a number of commands. And it cannot guarantee the dependencies.

So, what we could do in this case is we can go ahead and there's the multi-module compilation that can be specified with a command dash dash module dash source dash path option. Basically what it does, it's used to point to the root directory of the source file structure. So here we have a single one, which is javac dash, and then your output folder, and then the list of your source code file path, including the module-info. For multi-code, rather multi-module compilation, you have java.d, and then, of course, the output folder, and then the dash dash module dash source dash path root directory of the module sources, and then list of source code file paths.

Of course, you can get a description of a compiled module by using the command with, in this case, the dash dash module dash path that you see here at the end. This would get you a description of the compiled module. So you have java dash dash module path-- the path through the compiled module-- dash dash describe dash module name. So, of course, this using with the module dash path and the dash dash describe, module options, with, of course, the dash dash module path pointed to, in this case, the modular filter, or to the containing folder of the module folder.

And, of course, the description includes all the dependencies of the module and what packages it exports. If the module being described has not explicitly defined that it requires a java.base, and, of course, rely upon implicit inclusion, then the dash dash [INAUDIBLE] module displays this with, of course, in this case, the java.base mandated for this module. You would see that too.

Now, let's take a look at a single module compilation example. Well, in this example, which we see here on this slide, for every module to be compiled, the module-info.java file must be included in the list of the source files. And, of course, here we have javac dash and then mods for [INAUDIBLE] world. And then you have, in this case, the inclusion of module-info.java. And then you have the World.java, and then the second one, javac dash mods greeting. And then you have dash dash module path mods, and, of course, the module-info.java, and, of course, the Hello.java under the greeting package.

So the first one we do have, in this case, the compilation javac, in this case, which basically will have every module to be compiled. And the module-info.java must be, of course, included in the list. That's why we included it back. And the when the world is compiled first, as it has no dependencies on any other module.

In the second module to be compiled, we use, in this case, we must use the dash dash module dash path to point to the compiled world module. Of course, we do have the minus d. And that has the name of the module to be compiled as the name of the final directory in each path. This is not, again, mandatory for the single module compilation, but is recommended. Of course, the module name is, in this case, based on the package name and is recommended as a good practice to name the module the same as the principal package in the module. But this is not, again, mandatory.

And then as you see here, we see the structure of how all of that is created once we compile everything. You see the Hello.class, and the module-info.class, and then that's under greeting. And under world, you have the module-info. And then you have the World.class.

Now, let's take a look a multi-module compilation example. Let's go ahead and look at that multi-module compilation example. Here what we'll do is basically we're going to use the same thing, javac, in this case, use dash dash module dash source dash path so that javac can find the source code.

Of course, as you see here, in the first, in this case, example, what we have done in this case is that even though javac is only passed, in this case Hello.java, in this case, a file to compile, it can determine that modular compilation is required. So which means that the greeting module will be compiled, hello.java and the greeting modules, module-info.java file. And the world module will be combined, which is the world.java, and, of course, the module-info.java under the world module.

Of course, for the first compilation that you see here, the top one, we assume mods directory does not exist, so only saved files will be compiled. And, of course, for compilation where the compiled files already exist in the destination directory, only Hello.java will be compiled. Of course in the second, in this case, example, the [INAUDIBLE] [? find, ?] in this case, command is used to ensure that all source files are compiled every time the command line is run. That's why we have the [? find ?] here.

And of course, we see the last one checking module contents. So you can do java dash dash module dash path, mods, and then dash dash describe dash module we've seen before, greeting, and then, of course, exports greeting. And requires, as you see here, it pretty much have, in this case the dependencies in the as you see here written.

Let's take a look at creating a modular JAR file. So, in this case, we use the JAR command to create a modular JAR file. But as you see it in this command, we do have some options. So let's go ahead and take a look at these options.

We have the dash dash create. And this instructs that the JAR utility to create a new JAR file. We do have, in this case, a dash f. And that sets the path and name of the JAR file.

We have a dash capital C that sets the path to compile code of the module. And then we have a dash dash main-class. This sets the main class of the JAR file so it does not need to be passed, in this case, to the Java command.

And let's take a look at how we run a modular application. So if you running an end package model application, you see it this way-- java dash dash module dash path, and the path of the compiled module or modules, and then dash dash module [INAUDIBLE] module name, and then, of course, package name, and then your main class name. So we have the dash dash module path that has a shortened form of dash b. And then we have the dash dash module that has a shortened form of minus m.

So running an application packaged into a module JAR, assuming main class specified when clearing, here's how we see that, java dash dash module dash path, path to the JAR file, dash dash module, module name. Of course, running the Hello World application should be as simple as that which you see here. So we remember that we said the dash dash module dash path that has a shortened form of minus p, you see here, in the last one. And then the dash dash module has a shortened and form of minus m. So that's why, in this case, running the Hello World java would be java dash p jars, and then dash m greeting.

Let's take a look at a more complex module application, which is the TeamGameManager. Which, by the way, it is part of the practices that we do in our course, in this case, part of the practices. So let's take a look this team manager application.

As you see here, we do have pretty much, in this case, a requires and requires transitive. So the dash dash line means requires. And then the full arrow, in this case, full line with the arrow, that requires transitive.

And, of course, the next couple of slides here, look at more complex application, which is the team manager that we've seen. Of course, this application is used in the Migration and Services lessons titled "Migration" and "Services." And we'll take a look at that.

So here, we do have main, in this case, package-- rather module that depends on display.ascii too. We have a main that depends on competition. And we have, of course, in this competition, that depends transitively on gameapi. And then we have competition, in this case, it depends on basketball and soccer as an example. And then, of course, basketball and soccer depend on gameapi.

So now, let's take a look at what's happening here. So if we take a look at this example here, where we do have the main and the competition, which are in the same, in this case, white rectangle, classes within the main module require classes found in the competition module. And, of course, readability is granted in a couple of steps. First, in the module-info.java file of the main module options the module contains requires competition. And the module-info.java file of the competition module contains exports and then, of course, any package name.

So, in this case, why again does the design of a program here requires the main module to read from the competition module? It could be, again, that a class in the main module needs to instantiate an object type defined within a competition. Or it could be that a class within the main module needs to call a static method written in a class within computation. Of course, we know that the dotted line around indicates requires relationship between the main and module in the competition module.

Now, let's continue with this. So here we've seen requires and requires transitive. And requires transitive, in this case, would be between-- let's take a look and continue with the same example. We move now to the next one, which is competition requires gameapi transitivity.

So the relationship between module competition and gameapi is requires transitive. What does it mean? It means that the gameapi module contains interface types that are returned by the API in computation. This is a typical use of requires transitive. Of course in our case here, the basketball and soccer modules implement the interface in the gameapi module.

So the idea here is trying to see the effect of a requires transitive, which is, again, the same as requires relationship as shown earlier with one more major difference. A readability chain here is created. And classes in the main module can work with object types defined in the gameapi modules game package. And classes in the main module can also call methods defined in classes in the game package. That's the idea behind this.

Let's go ahead now and take a look NetBeans IDE and Java modules. We've seen an example about that on NetBeans. And we see that, of course, in the lesson two-- rather, in the practice of the lesson

So, we know we've seen example of creating a modular project in NetBeans. We already have seen that. So typically developers will use an IDE for a development.

And the IDE will make some aspects of working, in this case, with more convenient. Of course, here we just showed you on the right side, the screenshot of NetBeans IDE, which, by the way, we showed you this as an example earlier. And we're going to see these, of course, in the next lessons.

So different IDE will treat modular JAR-- rather Java, in different ways. In NetBeans using the Projects tab, the module module-info.java file is shown in the default package. That's how it's shown, in this case, in NetBeans.

And you can see here, we have a TeamGameManager project. And underneath, you have different modules-- basketball, competition, gameapi, and main, soccer, and so forth. And of course, in our case here, the idea is that by using an IDE, it makes it a lot easier and convenient to work with these.

Now of course, creating a modular project in NetBeans pretty much is straightforward. When we see that, of course, in NetBeans when we do the practices. The creating a JAR when building a project, in this case, so when building is pretty much a project property option under NetBeans, so you may not find this happens with every NetBeans installed.

And the file layout will be different for different IDEs. Again, here's the NetBeans layout that you see here as exposed using the File tab. You can click on the File tab. There's again a snapshot.

So you see that you do have-- if you go click on the File tab, and then go under the , modules you see the list of the modules-- basketball, competition, gameapi, main, soccer, and storage. So on running the application in NetBeans, the Java classes will be compiled and placed in the build/modules folder that you see over there.

And then, of course, you do have also under the dist, D-I-S-T, you've got your JAR files. These JAR files [INAUDIBLE] every single modules. So I'm building the application in NetBeans. The Java classes will be compiled, packaged in JARs. And the JARs are placed and the dist, in this case, folder.

Of course, the source code for the compilation is under source, module, classes, and so forth, package, and the class file name. And as you see over there, there under src, then basketball.class, and then classes, then basketball, then util underneath. You've got your Basketball.java-- Basket.java, Basketball.java, and so forth. And that's pretty much what I wanted to say about, in this case, the discussion of, in our case here, working with the module system.

Now, in this module, it turns out that we do have a couple of quizzes. So the first quiz here says, up to how many modular JAR files are created when TeamGameManager is compiled in NetBeans? If you take a look at all of this and look at the example that we've seen earlier, it's actually eight.

So the answer in this case is i. The number of modular JAR files is the same as, in this case, the number of modules. If there are eight modules, than up to eight modular JAR files can be created.

Here's another small quiz that says, the main module contains a class which instantiates an object defined in the competition module. competition exports its packages. main requires competition. Will the code still compile if that requires statement is commented out in this case? Take a look and see what you think.

This actually-- the answer would be b, no. Why? Because exporting packages only specifies what material could potentially be read from a module. One more step is required to turn the potential into reality by specifying that one module requires another.

Here's another small quiz. What two things would you change about this code to set up a requires a relationship directly from main to gameapi? Look carefully here. We have module main requires competition, module competition requires transitive gameapi, and module gameapi exports gameapi.

So here what we need to do is we need to remove the transitive keyword from the competition module, module statement, requires transitive gameapi. WE need to take that. We need to that this-- we need to take this transitive, in this case, keyword. We need to get rid of it.

And, of course, it should instead say requires api. That's what it should do. An add the requires gameapi statement to the main module.

Another small quiz. Well, we tell you here, you want the gameapi module to export the game package to both the competition and the basketball modules. Which code example shows how this can be done? Take a look carefully. We have a-- read carefully-- and then b.

Well, if you take a look carefully, you would see that b, in this case, is the answer. Where in this case to find an answer, again, you need to open the project in the example in the lesson titled "Why Modules," and, of course, experiment with the code. So you get to do that.

We have exports game to competition. So we said [INAUDIBLE] the gameapi module to explore the game package to both the competition and the basketball. If you remember in the lesson, we said we can say exports to, and then we separate the two modules with comma. That's why we comma separated it competition comma basketball.

So in summary, let's take a look at some summary of keywords. So we know that we have export package. This declarers which package is eligible to be read. We have exports package to modules. That declares which package is eligible to be read by specific module.

We have a requires module that specifies another module to be read from. And then we have a requires transitive module that specifies another module to read from. The relationship is transitive in that indirect access is given to modules requiring the current module.

These are, of course, restricted keywords. Their creation won't break existing code. Of course, they're only available in the context of the module-info class.

Another summary of accessibility between classes. And this pretty much tells us that these are the accessibility that we had from JDK 1 through JDK 8. We had public, remember, and protected, package, and private.

Well, starting JDK 9 and up-- 9, 10, and 11, ad so forth-- in this case, accessibility, public, it no longer means accessible to everyone. So you see, you have more than one meaning in public. We have public to everyone. We have public, but only to a specific module. And we are public only within a module. And then we still have protected, package, and private. Of course, you must edit the module-info classes to specify how modules read from each other.

And that's pretty much what I wanted to say about this lesson. So, of course, we do have-- basically what we have done here is we looked at the y modules. We looked at the purpose of module-info class.

We described the modular JAR files. We described the concept of readability and how does that differ from access. And, of course, we describe the purpose of exports to, requires transitive, and so forth. And, of course, we worked with a modular-aware program.

We do have some practices that we want you to do. And please go ahead and try them. And then, of course, we'll take a look at them later on. Thank you.

## 2. Practice 3-1: Creating a Modular Application from the Command Line - 4m

OK, now that we are done with lesson three, let's go ahead and take a look at its practices. And we start with practice 3-1. Here, we're going to create a modular application from a command line.

So the assumption is that we have completed the lecture and reviewed the overview for this practice. So first, they want us to open a terminal in the Home Oracle Labs 03 Modular System Practices. And that's what I did. OK. We opened a terminal.

And then, of course, after that, we make, in this case, a directory, practice03_01modularsystem, which I already did here. So I pretty much copied and pasted all the commands that I used. OK?

So we're here. And then we CD the practice in this case three. And that's what we have. Then we make a directory here, greetings. That's basically what I have done here, where we go ahead and make a directory in this case.

And then after that, we'll see CD into that, and then we touch main. We edit the main. And then create some code in it. And that code is related to the code that we have here. I already did that.

And then, of course, in the lab practice03_01modularsystem, we create, in this case, a classes folder, which I already did here. So that's the classes folder.

And then after that, we can go ahead and CD up, up, and then make-- that's what I did, actually, created it. And then after that, we'll go ahead and continue with that where we see the dot dot being created.

And then we'll do a Java C minus D. And then we pretty much compile that. And that will be, in this case, somewhere in here.

And then after that, we'll go ahead, in this case, and run it. And that's what I did here. And that's the output when I run it.

And then after that, we wanted to CD SRC. That's what they asked us to do. And then make D actually Hello and then move com to Hello. And that's what we end up with.

And then after that, CD Hello and attach module-info.Java, create that. And then create that inside. So I did all of this here and did the G edit and then created all of that.

And then after that, we'll go ahead and compile and then run it to get the output. And that's basically what we have here. And that's what they want us to do in practice 3-1.

## 3. Practice 3-2: Compiling Modules from the Command Line - 3m

Let's get into practice 3-2. Here we're going to compile modules from a command line. In this practice, you are going to see a shortcut to compile all modules at once. You don't need to specify each individual module in a class for compilation like you saw in the previous practice. For this shortcut to work, it's important to name modules and their directories consistently.

So first, we want to be make sure that we are, in this case, in the right directory. So PWD here will do that for me, so I'm there. And then after that, we delete your compiled code by removing the mods directory. And pretty much, that's what we have here. And then after that, they want us to compile all modules. This is the command we use to compile all the modules. Again, we should note this automatically creates a directory that is the same as the name given in the module-info file.

And then, we pretty much have run this here, and we took care of it. Then after that, they want us to, in this case, run the application. And that's what we have done here. So we did run the application. Here's the output. And then after that, they want us to get into the navigate in the File Explorer to the Hello directory and open the module-info class in the gedit and change that name from hello to test. And this is all done here.

So as you see here, it's all changed. That's what we have. And then, of course, after that, they want us to compile again, and you should be able to see an error. And that's exactly what we have here when we compile again. And now we get the error. And that's basically what they want us to do for this practice.

## 4. Practice 3-3: Creating a Modular Application by Using NetBeans - 10m

Let's go ahead and take a look at Practice 3-3. Here we're going to create a modular application by using NetBeans. We create a modular Java application in NetBeans. Of course, we start by seeing how modules read from each other and how NetBeans allows you to compile many modules at once.

So the first thing we need to do is basically go through all the steps step by step when we open NetBeans and create a new project. In this case, File, Project, New Project. And then we select the Java modular project from the list, and then click Next, and then name the project, and so forth. That's pretty much what we have.

So by the new project, and then select in this case the Java modular project. Next. And then we give it a name and so forth.

And that's the one that we already have here. And then, of course, after that they want us to, in this case, create a new module within the project by right-clicking on the project, Creating a New Module, which is quite simple in the sense New, and then New Module, and then give it a name. In this case, Hello. That's pretty much what they want us to do. And then click Finish, which I already have done.

So it's already there. So here's your hello module. And that's what we have here.

And then, of course, after that, we should note that the module info class is automatically created. And that's what you see here in the classes under this default package. Even though this default package really does not exist. And we already discussed this in the lecture.

And here's your, in this case, module-info that we have over there. And so that's basically what we have.

And of course, after that we create a com.greeting package in the Hello module. And this would be this one here, which you already have. And a com, a package, which is pretty much straightforward. Again, that's all that you need to do. Right-click, and New, and then a Java package. And then you're good to go. Basically, that's what it is.

Which already kind of we, in this case, guide you step by step. And then we create a new Java main class in this case under the project, which is pretty much also straightforward. New, and then your Java class.

And in this case, you want the main Java class. That's basically what it is. I mean, you have a couple of ways to do that. You can go ahead in this case a New, and then select Other. And then from there, you can go ahead and find your Java, and then your Java main class in this case, which is this one here. Select it. And that's basically what we have done.

And then, of course, we want to put this code in it. And that's what we have here.

So if you take a look here, pretty much we already have it. And we have it open here. That's what we have. And then, of course, pretty much after that, we are basically-- so we create the package, create the class, compile, and run the program. That's what we have here. And pretty much this is what we have here.

So we go ahead and run it. And that's what we get as an output as you see here. Let me just increase the fonts a little bit so you can see that. And that's basically what they want us to do in this case.

Then after that we create another module. In this case called People, which is straightforward again. New, and then Module. And then after that call it People.

And this would be in our case here the module that we have here, which is created. That's what we have.

And then after that-- so once we've created that module, we create a com name, a package under the module. And that's what we have here. Under the process we have a com.name package, which is pretty much again in this case straightforward just by right-clicking on the module here and just creating a new Java package. And name it com dot, in this case, name, and then you're good to go.

You already have it. So we do not want to, in this case, recreate this.

And then, of course, inside we are going to create in this case a new Java class called Names, which contains this code. And as you see here, it's under package com.name. Let's go ahead and look at that.

So here it is. So here it is, and basically called Names. And it has a getName that returns in this case a string. And it's a static method as you see here.

And that's basically what they want us in this case to create. So it has a static method called getNames.

And then after that we, modify the module-info of the people module so that it exports the com.name package. And that's basically by looking, because this is automatically created. So now we wanted this, a module exports com.name. That's what we have here.

And then pretty much that's what they asked us. And then, of course, don't forget that we modified the module-info of the Hello module that is going to require in this case the People module. And that's what we have here.

And it requires the People module. That's what we have over there. So as you see, the Hello module requires the module People. And then the People module exports in this case the package com.name, this package here.

And after that, we modify the greeting in the main method that includes the name found in this case in the Names class. So the print statement will look like this. And this is basically what they want us-- so modify in this case the greeting in the main method to include, which means in our case here this main method that we have in the main class here.

We see that now we have a system.out.println and a hello. And then as you see here, it calls the getName, which happens to be a static method. That's why it's called through the name of the class. And that's basically what they want us to do here.

And don't forget that we need to import com.names, which we already have here. So we imported that.

And then after that all that we do is build the project. So you right-click in this case and click on Build. You can do Clean and Build, too. That's also another-- which means it will go ahead and compile that.

And by the way, just because it has two different, in this case, modules, that's why in the file underneath, in this case the destination, we see that we have now two JAR files; one representing the first module, the Hello module, and the other one representing the People module. So that's just to kind of show you in this case how all of that works.

And then, of course, after that, all that we do is run the project. Of course, the project is going to go ahead in this case and print hello, because as you see it prints hello, and then gets the name, which happens to be Duke. That's why the output will be in this case, "Hello Duke!"

And of course, we have seen this. Just by looking at, in this case, the names class, that returns a Duke. And then in the main class here that has the Main method, we print hello, and then we invoke the getName, a static method on names, which we know for sure is going to go ahead and return in this case Duke.

And that's why when we run this, the output in this case will be "Hello Duke!" And that's exactly what they want us to do in this case.

And that's pretty much what they want us to do in Practice 3-3.

## 5. Practice 3-4: Requiring a Module Transitively - 8m

Let's take a look now at practice 3-4. Here, we're going to require a module transitively. In this practice, we're going to continue working on the modular Java application from the previous practice. But here, we'll create a new module and examine the effects of requiring a module transitively.

So in this practice, we are going to pretty much, in this case, create a new module called conversation. And create, in this case, a package called conduct question inside that module. And then create a class called, in this case, questions that will contain this code. It has basically a method called GET QUESTION, which happens to be a static method that returns, in this case, this string. OK?

So let's take a look at that. So here's we created a new module. Again, it's so simple by just creating a new module and then give it a name, which in this case called Conversation. Inside now, we have a questions class that basically is inside the com.questions package that we created.

And it has GET QUESTION static method that returns the string called How Are You. OK? And that's basically what they want us to do. So we did that.

And then after that, in my main class, we'll go ahead and, in this case, append the return string from calling GET QUESTION to print the statement in the main method. So let's go ahead and take a look at that.

So in my main class in my main method, now we'll print hello and then the GET NAME that comes from the names class. And they'll be people module, which is under con.name. And then we append do it, in this case, as space. And then GET QUESTION called from the questions, in this case, a class, which is this one here. OK? Which happens to be a static method. And that's what they want us to do here. OK?

And then, of course, we need to take care of the import. And that's what we have here. So we took care of the import, so we got the com.question.questions. OK? So we imported that so that the code works properly.

And then here, what we did is when we, of course, in this case, we're going to get into the modifying the module-info class of the conversation so that it exports the question package. Let's go ahead and do that, which we already have it here. So here it is.

So this will export the com.question package. All right? So that's good.

And then, of course, here we modify the module-info of the people module to require the conversation transitively. And that, of course, will be here under, in our case, under the people.

And we right click and open this. And we see here now this we already know that people exports to com.naming. And that in this time, it's going to require a conversation by transitively. That's what we have here. OK? That's good.

And that's what we did here. OK? And then, of course, we should note that although the hello does not explicitly require conversation, classes within the module can still read, in this case, the transitivity allows the readability up to the requirement chain. Hello requires people, which requires, again, conversation transitively.

So that's why when we run the project, this should work without any problem because hello module still has access to the conversation module because we know that hello, in this case, requires people. And people requires the conversation transitively. So that should work without any problems.

If we run the project, this will work properly without any problem. So you see? Hello, Duke, and then how are you. So that's basically exactly what we wanted to see.

Now, the question is, how about if we decide to-- what if people no longer requires conversation transitively? So how about if you remove the transitive keyword and see what happen, in this case, in the module-info of the people module. Let's go ahead and try that and see what happens.

So in that case, we just remove this transitive keyword and see what happens. OK? Of course, as you see here, if we now run this, see? Suddenly now we have errors. OK? Suddenly we have an error here that says pretty much a com.question is declared in a module conversation, but module hello does not read it. So suddenly now we have a problem. OK?

And that's exactly what they want us to do. So basically, here, when we move try to run this one here, I mean, you know we already see the error, but you still can't run it. And you are going to get an error anyway. So run anyway. And you should be able to get an error here. That's exactly what they want us to do.

But still, we caught it right there at the compilation level. Now we have this error. That's basically what they want us to do. And then, of course, without transitively hello module cannot read from conversation. That's exactly what we want.

Now, what if conversation exports only to people? How about if we do that just to see what? Add the keyword transitive back to required. Let's go ahead and do that.

So now, if we go back to here and add a transitive. OK? So that's what we have here. So now it's all fixed. So it's all good now. OK. Let's get rid of this output. OK. So it's all good. OK? As you see, no more errors.

And now, what they want us to do is, OK, they said go ahead and add the key words, in this case, and modify the module-info of the conversation. A module specify that the conversation exports com.question to people, only to people. OK?

So let's go ahead and do that. So in my conversation in this case, and then exports. And then we say here to people. OK? That's what we want.

And then if we save that, guess what? And so now we have exports com.question to people exactly where they want us to do here. OK? People.

Try running, in this case, the project. And guess what? It has also the error. So you see? And why? Because that's exactly, we're breaking in this case, the transitively. And that's why we get an error here. OK?

So that's just to kind of give you an idea about how. And we've seen this in the lesson. And now we actually can see it when we try it in the practice.

Let's go ahead and get rid of it. OK? And then we Save. And then we run it. And of course, now it works without any problem. OK? And that's exactly what they want us to do in this practice.

## 6. Practice 3-5: Beginning to Modularize an Older Java Application - 5m

Let's take a look now at practice 3-5. Here, we're going to start modularizing in all the Java application. We're going to see how modularization affects the program's readability of certain Java API. Your application focus on the Java's Logger class. More information about migrating a Java application to work with SE 9 and 10 modularization is provided in a later lesson.

So here, we're going to import the project. First of all, we're going to get the project, open it. And then you'll notice that the program won't run because it does not recognize the logger, in this case, object. And that's what we have here. OK?

And we do have RMAN class. That makes use of Logger. And as you see here, it basically does not recognize that because it's part of SE 9, which is in the form of a module.

So if we run it, let me try to run it, we get this error. OK? Run anyway, and we get this error. Obviously, because we need to have a mechanism by which we could get to the Logger, in this case, class, just part of the API.

So, one way, again, if we try to run it, so one way is to create, in this case, a module. So we can go ahead and right click on the source package. New other module, Java module name for, click Next and Finish. And then that's basically what I already have done.

So under the source package, New, Other, and then Java, and then Java Module. Click Next and then click Finish. It says it already exists because I already did it. So as you see here, so that module is created.

Guess what? We still have a problem. It's not going to run. You know? So if we run it, then of course, in this case, you still cannot run it. OK? And that's exactly what we have done. We still have that error.

So with the modularization of the Java SE 9 and 10, Java packages themselves have been, in this case, stored into modules. Not all Java packages are automatically accessible to a modular application. A large number of packages are stored in the Java.base module. There is no need to explicitly require this module because it's automatically accessible to all modules.

The Logger class is stored in the Java.login. So that's why, in this case, it would be explicitly. So one way to actually handle that is why not open the module dash info and require the, in this case, the Java.login. That's what we do. OK?

And that's exactly what we have here. So if we now just can copy this, and then put it inside this one here, and just paste it there. And now, of course, we look at it, in this case. And as you see here, and that's basically what they want us to do focusing on this. And then run the program again.

And let's go ahead and do that. And if you run the program, in this case, this basically would lead us to, in our case, here to just do some changes here in the main by just importing the Logger. OK? That's what I wanted to do.

So if we now import this and then save all this, suddenly now it works perfectly. If I run this, then, in this case, it will go ahead and give me the output. So what we have done here is we started modularizing an old application. First, we created a module dash info Java in it.

And then because we know that the main class here, the main method, pretty much, or the main class here makes use of the logger. So we had to now inside my, in this case, module dash info class, I had to require, in this case, the Java.login. And that, of course, we fix,

Then, of course, don't forget that you also need to import the Logger class. And that's what we've done. And of course, it works properly. And that's what they want us to do in this practice number, in this case, 3-5.

## 7. Skill Check: Working with the module system - Score 80% or higher to pass

Skill Check: Working with the module system

View Skill Check

