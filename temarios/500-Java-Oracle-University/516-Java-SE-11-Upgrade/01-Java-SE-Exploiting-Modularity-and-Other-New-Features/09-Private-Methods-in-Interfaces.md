# 9: Private Methods in Interfaces

1. Private Methods in Interfaces - 19m
2. Practice 9-1: Java SE 7 Interfaces - 4m
3. Practice 9-2: Java SE 8 Default Methods - 4m
4. Practice 9-3: Java SE 9 Private Methods - 3m
5. Skill Check: Private Methods in Interfaces - Score 80% or higher to pass

## 1. Private Methods in Interfaces - 19m

OK, let's go ahead now and take a look at a private methods in interfaces. This would be lesson nine. In this lesson, we are going to use the default methods in interfaces.

We're going to identify when it is likeable to implement a default method in an interface. Identify how inheritance rules, in this case, apply to methods implemented in interfaces. And this pretty much are part of the SE 8. And use private methods in interfaces, which is part of SE 9 and 10.

And then identify when it's a likeable to implement a private method in an interface. So in SE 7, we pretty much did not have default and static methods inside that interface. What we typically have is just abstract methods. And so an interface that has, in this case, an abstract method, and we can go ahead and implement those methods in the class that implements the interface.

Starting Java SE 9 and 10, we introduced the ability to implement a private method in an interface. Now, one thing that you need to remember is once you declare a method as private, it will be accessed only from a default method inside the interface itself. OK? So we're going to take a look at that.

So we know that in Java SE 7 and prior, interfaces in Java contained abstract methods. And they cannot contain instance variables. What you could add in an interface is the static, in this case, final variables like the one that we see here as an example, where we have the interface called Accessible that has overdraft fee, which happens to be a static final variable set to 25. And then we have a couple of abstract methods-- verifyDeposit and Withdraw deposit-- that need to be implemented by the class that implements this interface. OK?

So again, in Java SE 7, those abstract methods must be implemented later. If one class implements an interface, you'll write your implementation logic inside that class. And if many classes implement the same interface, then you'll write your implementation logic many times in the different type of classes.

You know, what if most classes implement the exact same logic? So obviously, this would be a duplication of code. OK? And that's a bad idea.

So that's why we came up with the idea of, in this case, here's an example where, in this case, I have a basic checking class that implements the Accessible interface, which I end up implementing the verifyDeposit and the verifyWithdraw.

It turns out that in this method, we both verify deposit, and we verifyWithdraw. We verify the pin, and verify the amount is greater than zero. It turns out that that code exists in both methods, the verifyDeposit and the verifyWithdraw. OK? Except that in the verifyWithdraw method, we also verified the account balance won't go negative.

So we can also have a class called restricted checking that implements Accessible. Journal that it does the same thing pretty much. It implements the verifyDeposit, which verify the PIN and the amount is greater than zero. And the verifyWithdraw will do the verify the PIN, verify the amount greater than zero, verify the account balance won't go negative. And also in addition, verify the withdraw is under the transaction limit.

So a small quiz here, pretty much just to get the, if you want, the ball rolling. Says what is true about code duplication? If you take a look at or read all of them, you will see that the answer would be, in this case, c, where if you need to make an edit, you will have to search all the cases where the code is duplicated. This is obviously tedious, inefficient, and it's a bad idea to actually use that.

So now, let's take a look at what we have done in Java SE 8. So in Java SE 8, we introduced the fact that if we have now a code that needs to be implemented in a method again and again in the classes that implement the particular interface, why not create what we call a default method here?

So default methods help minimize code duplication. Why? Because they provide the single location to write and edit the code. They can be overridden later by the classes that implement the interface. And so that's basically the idea behind default methods.

So here's an example when, in this case, we do have interface Accessible. And we decided that the verify deposit and the withdraw deposit, both of them, are going to be default methods, which means they can be used as they are by the classes that implement the interface and are accessible. Or you can go ahead and have the class also override those methods if you wish to.

So here, pretty much all once we have a class that implements the Accessible interface that you see here, then that class can go ahead, in this case, and use the default methods that are part of the interface, in this case, Accessible. OK?

So again, you can override the default methods and call the interface implementation. Here's an example where, for example, the restricted checking, that implements the Accessible. We decided to override the verifyWithdraw. OK? By calling the interface implementation, which is accessible.super.verify.

And then in addition, verify the withdraw, which is under a transaction limit because we had to add that to it. You know? Which by the way, did not exist in the implementation of the verifyWithdraw, which is a default method inside the accessible interface. OK? So

We could do that. And just call it here through the super, call the verifyWithdraw of the interface. And then in addition, add some code to verify the withdraw is under the transaction limit.

So again, what about the problems of multiple inheritance? We know that for the type, a class implements multiple interfaces. That's basically well-known. And for the behavior, a class implements interfaces containing multiple default method. Special rules exist to prevent complications. We can see we are going to see these special rules in the next couple of slides.

In terms of the state, we know that a call to a variable cannot have multiple potential values. We know about that. OK? This is actually one of the issues that we had when we deal with multiple inheritance in the C++.

So here are some rules. The first rule, by the way, this also exists in our Java SE 8 course. But you know, just for review, we're adding them here. We say that rule number one it says that a superclass method takes priority over an interface default method. Which means now, if we have, in this case, a class A, and of course, that has a method M, and then we have an interface B that has a default method, then now we decide to create a class D that extends and implement B.

It turns out that in this case, the method is going to work would be the method that belongs to the superclass. That's why we say the superclass method may be concrete or abstract. But in this case, we say that a superclass method takes priority over an interface, which means, in this case, we have an implementation of the method M inside a class A. And then an implementation of method M inside class B, then that extends and implements B will be using the M method of the class A. OK?

And we always tell you only consider the interface default if no method exists from the superclass. And you can see, by the way, these examples we do have examples from your lesson. You can open them.

Here's an example, in this case, where we do have, in this case, A, which happens to be a class. It has M here that prints abstract class A. And then we have an interface B that implements an M method that prints interface B. And then we have class D that extends A and implements B.

So if we test that and create an instance of then called the M, if you run this, definitely you will see that it's using the method in class A.

So continuing with the rules, now we see rule number two. Rule number two says a subclass interface default method takes priority over supertype interface default method. What we mean by that is we do have an interface B that happens to be a super interface that has a default method M. And then we create an interface C that extends the, in this case, the interface B. And then we make class D implement C.

Here, you will see that the method that class D will use will be the one of a subclass interface. OK? You can also see this example, in this case, of course, in the next project, where, in this case, we have an interface B. And we have interface C that extends B. We have D that implements C, and then the test.

And if you take a look here and run it, pretty much you will also have that it's using the method of interface C, which happens to be the sub-interface. That's exactly what we want to say here. OK?

And then one rule called Rule Three. Rule Three here, let's assume that we have now two interfaces, B and C, independent. They both implement the default method called M. And then D now implements both interfaces B and C.

So the question here, which one is going to be used in this case? Well, the rule says if there is a conflict, treat the default method as abstract. So which means the concrete class must provide its own implementation. This may include a call to a specific interface method, if they want. OK?

So for example here, we decided to call the method in interface, in this case, here we decided to call the method in interface B, where we'd B.super.m, as an example. OK?

And you can see this example also here. This would be in the third one. And here's my interface B that has its own M implementation, my interface C, and then D implements both. And then, of course, here because we create an instance and call the method M.

And because in this case we did override, so it called the method of the interface B. That's why if you run it, that's what we're going to see here in this case. If we, rather, run the test class. That's what we want to do.

And then that CC is calling the interface B due to the fact that D, in this case, the M method in D calls the method in the interface B. OK? And that's what we have here.

All right. Continuing with that, now we know that interfaces don't replace abstract classes. Which means an interface does not let you store instance variables. So an abstract class may contain instance fields or instance variables.

To avoid complications caused by multiple inheritance of state, a class cannot extend multiple abstract classes. We know about that. This is not allowed in Java. In Java, it's single inheritance. We cannot have a class that extends two classes.

And by the way, you can try this in the practice. That would be the last one. If you take a look here, it's already giving us errors here. And that makes sense because D cannot extend two classes. If you move your mouse on the top, it says implements expected, in this case. But unfortunately, here, we wanted it to extend two classes, which basically is not allowed in Java. That's why you have this.

Of course, we do have another small, in this case, another quiz where it says the Accessible interface only verifies if a transaction is appropriate. Why can't this interface also store and modify an account balance? And if you look at this, we say that if you read all of these the answers here, you would see that d basically is the way to go.

Where if the interface had a balance instance field, this could potentially lead to a multiple inheritance of state. And that's basically why, in this case, we don't have that.

So now, what we're going to do is introduce the private method. So if you take a look at this code that we've seen in the Accessible interface, it turns out that the default method here has duplicate code. We verify the PIN and verify the amount is greater than zero. This is duplicated.

And maybe this information is a little bit sensitive. It might be a good idea to maybe implement this internally in another method. OK? So we can go ahead and implement it as a default method called verified transaction, that you see here. And then we have the verifyDeposit calling on the verifyTransaction and the verifyWithdraw calls the verifyTransaction. And the verifyTransaction verified the PIN and the amount is greater than zero.

Now, to even make it better, in this case, why not instead of just putting it in its own default method, why not put it in its own private method? So of course, the default of it must be public, as you see here, which means the class that implements the interface has access to verifyTransaction. And maybe we should not do that.

And so, again, they can be called from almost anywhere. Return values may not mean anything outside the context of other methods. And it's dangerous if the method returns information you don't want exposed.

So that's why, for example here, when you're calling that verifyTransaction, basically, as you see here, you can access it without any problem because you know that, in this case, a restricted checking has access to the default method because it's public. And then, of course, now we can call the verifyTransaction. And maybe it's a bad idea to actually call it directly.

Why not, in this case, make the method private? This method here, verifyTransaction? Instead of having it default, let's go ahead and make it private, which means it's not, in this case. As you see here, a better strategy is to make it private.

Private interface methods are more secure. They can't be called from elsewhere. They limit the risk of exposing sensitive information. They can't be overridden. They can't be called from a class which implements the interface. And of course, a private interface method lead to more maintainable and readable code. And of course, they don't lead to inheritance complications.

So all these advantages basically allow us to add these private methods in the Java SE 9 and 10. And now, we can make the verifyTransaction private. And if it's private, it can be called only from the default methods that we have inside the interface, which means the verifyTransaction can be called from the default method verifyDeposit or verifyWithdraw. And that makes more sense.

So here are some of the types of methods in Java SE 9 and 10. So we tell you the access modifier and method type. So for public abstract, yes, it's supported. A private abstract, compiler error, does not exist. A public default, yes. Private default, does not exist.

A public static, yes. A private static, yes. And then private, of course, yes.

And then, of course, here just a small quiz. If a private method is written in an interface, where can that method be called from? From any other method within the interface. That would be A.

So in summary, we just showed you how the concept of default methods and the rules. You know about that. And then we also showed you the new private method that we created in Java SE 9 and 10.

Of course, we have a bunch of practices here where we first work with the SE 7 interfaces. And then SE 8 default methods. And then SE 9 private methods. Please try these practices before you look at the solutions. Thank you.

## 2. Practice 9-1: Java SE 7 Interfaces - 4m

Now that we are done with the lecture of lesson 9, let's go out and take a look that its practices. We start with practice Java SE 7 interfaces. Here we create the BasicChecking classes and implement the Accessible interface according to the rules in SE 7. We should observe certain limitation and see the motivation behind enhancing the capabilities of interfaces in future versions.

So here, we do have basically, in this case, a module, in this case, called main. And then we have packages-- rather a package called com.example.interfaces. And then, in this case, we'll go ahead and have the interface Accessible, which has a couple of, in this case-- so here is pretty much we have the main module.

Underneath this is basically a module. Basically it is just a regular module. There is nothing do it. And then it has the Accessible interface, which has two methods, abstract methods, verifyDeposit and verifyWithdrawal.

And then what do we do, in this case, we'll go ahead and make a couple of classes that implement these. One is the BasicChecking. And this is the BasicChecking, which pretty much, in this case-- the BasicChecking here has implement Accessible, which going to end up-- it has a constructor. And it has verifyPIN, getBalance, and setBalance, and verifyDeposit. And as you know, the verifyDeposit and verifyWithdrawal, those are implemented by these classes, so in verifyWithdrawal.

But in this case, as you see, we see the common code that we see here. So this is common code that we see it again here. And the same thing with RestrictedChecking, so pretty much it also has some common code that we also see it, in this case, again and again, in the next class too. That's basically what we have.

And then, of course, we have a deposit, withdrawal, and so forth. And then we have a TestClass where we just go ahead and deposit, and withdrawal just by calling the deposit and withdrawal on the account. And this is, again, restricted. We could have also created an instance of BasicChecking if you want.

If we run this, pretty much you get an output. And that's basically what it says here. Amount cannot be negative, and so forth, based on the code.

So what's interesting about here is that we have duplication of code that you see here. We can see it here. We can see it in the verifyDeposit. And we can also see it in the BasicChecking, the same thing and the verifyWithdrawal and the verifyDeposit as you see the same type of code. And we're hoping that the newer version will avoid these duplication of code. That's basically what we wanted to see in these practice.

## 3. Practice 9-2: Java SE 8 Default Methods - 4m

Let's take a look at practice 9-2. Here, we're going to use the Java SE 8 default method. So we begin correcting some of the code duplication in the previous practice by, in this case, implementing the method, verifyDeposit, as, in this case, default methods.

So basically, in this case, we do have an interface. Except that in the interface, we have the verifyDeposit, which now is implemented inside the interface. And the verifyWithdrawal is also implemented over there. And then verifyPIN and getBalance, those are [INAUDIBLE] methods that need to be implemented by the BasicChecking and the RestrictedChecking classes.

So the BasicChecking now implements Accessible, which means it will implement only verify-- in this case, will implement these two methods, verify the pin, and get the balance. And that's what we have. In terms of the rest, we can go ahead and make use of the end of [? quarter ?] deposit and withdrawal. These are methods that belong to the class.

Restricted also implement those verifyPIN and getBalance. But then, of course, we can now make use-- if this classes want to make use of the two methods, verifyWithdrawal and verifyDeposit, we can use them directly [? part of. ?] So here we can go ahead and deposit and withdraw.

And then, of course, these, in this case, account of type RestrictedChecking, we know that it implements the Accessible, which means it has access to, in this case, the default method verifyDeposit and, of course, verifyWithdrawal. Which by the way, in this case-- here by the way, in our case here, when we look at the rest of the checking, we see, in this case, that it has a constructor, and that it overrides the verifyWithdrawal by adding some restriction here. So it overrides that. But then, it does not-- it makes use directly of, in this case, the other method, which is the verifyDeposit. That will use it automatically.

And that's why here, the verifyWithdrawal, that is called part of it uses the one of the super interface, of the interface itself. And here it calls the verifyDeposit method and the verifyWithdrawal that again, it was, in this case, overridden inside the class.

And so that's basically-- but still when you look at the code, in this case, inside the implementation, we still have some code, some common code. This one here, and this one here, pretty much they're all inside both, in the verifyDeposit and the verifyWithdrawal.

And maybe we do not want to show this code. Maybe you want to just use it internally inside the interface. That's basically what we want.

And then, of course, if we test it, pretty much it would be the same thing. Test it, and you get the output. That's what they want us to do in this practice. Hopefully the next revision, which is SE 9 and 10, now we are going to make use of that private method.

## 4. Practice 9-3: Java SE 9 Private Methods - 3m

Let's take a look now at practice 9-3. Here, we are going to introduce the private methods. So we'll continue refining our code to minimize code duplication.

Again, we'll notice that the verify deposit and verify withdrawal methods duplicate some of the code we've seen that. Both method verify the PIN number and check that the amount requested is greater than zero. This kind of code duplication can be safely minimized in lesson nine and with the introduction of the payment method. That's exactly what we are going to do here. OK?

So in our case here, we have now the access interface. And the access interface here we have the verify that is going to make use of the verify transaction method, which by the way we implemented as a private. By the way, remember that the verify deposit is still a default method. And the verify withdrawal is still a default method.

But here, we took all that common code that we've seen before-- remember I was highlighting these-- and I said this code should be in a private method, especially if it's a sensitive type of code, then it would be private. And then it would be accessed only from within the methods inside the interface. And that's what we have done.

Of course, we still in the basic check [INAUDIBLE] accessible. We'll go ahead and make use of the default methods. And then the restricted check-in still makes use of the default methods that we've seen, except that it still overwrites the verify withdrawal. OK? That used the verify withdrawal of the interface. And then makes use of the verified deposit as is. It just overwrites that. OK?

So the advantage here is that we now created a private method, which is called only within the methods inside the interface. OK? That's basically what it is. And then, of course, the test would be exactly the same. Pretty much gives us the same type of interface.

So the goal here is that by putting all that common code inside this private method, which is called in this case within the verify deposit and the verify withdrawal, which are part of the interface. So this method will never be accessed from outside. And that is a good practice. OK?

Which means now we have a mechanism by which or this new flexibility in SE 9 and 10 by which we can create a private method that contains some sensitive information. And it will be only accessed from within, in this case, the methods inside the interface.

## 5. Skill Check: Private Methods in Interfaces - Score 80% or higher to pass

Skill Check: Private Methods in Interfaces

View Skill Check
