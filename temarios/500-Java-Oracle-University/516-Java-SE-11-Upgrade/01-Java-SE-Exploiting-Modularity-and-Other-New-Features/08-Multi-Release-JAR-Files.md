# 8: Multi-Release JAR Files

1. Multi-Release JAR Files - 16m
2. Practice 8-1: Multirelease JAR files - 6m
3. Skill Check: MultiRelease JAR Files - Score 80% or higher to pass

## 1. Multi-Release JAR Files - 16m

Let's go ahead now and take a look lesson 8. In lesson 8, we're going to discuss multi-release JAR files. Here, we're going to describe the problem of JAR files are intended to solve, and create a multi-release JAR file that runs on the class path in SE 9 and 10 or an earlier version, and creates a modular multi-release JAR file that runs on the class path or module path in Java SE 9 or 10, and on the class path on an earlier version.

So let's first look at the multi-release JAR file. We all know packaging an application for different JDKs. We've done that before in JDK 7, and 8, and 6, and so forth. And maintaining and releasing an application targeting different JDKs is typically difficult. Prior to SE 9 and 10, when packaging the application code for different JDKs, you need to create a separate application JAR for everyone.

So for example here, we compile the code for JDK 7. And we compile the code for JDK 8. And we create two JAR files, one for 7 and one for 8.

Now looking at packaging and application for different JDK versions, it turns out that in JDK 9 and 10, we now have a new way of packaging application code so that it can support multiple JDK versions in a single JAR file. These JAR file is called multi-release JAR file. So for example, here's an example where, in this case, we have a multi-release JAR file where we have an application that has some classes that were compiled using the JDK 8, and then a couple of additional classes that are compiled using JDK 9, most probably using some features that are part of JDK 9 and 10.

So what is a multi-release JAR file? Pretty much, a multi-release JAR file, which we call MRJAR, is a single unit of distribution compatible with multiple major Java platform versions. So example here, we can have a multi-release JAR file that can work on SE 8 and SE 9. And it contains files complied for SE 8, plus addition files-- classes rather, compiled for JDK 9. Most probably, the ones that are compiled, or additional ones that are compiled for JDK 9 take advantage of some APIs that are offered only by Java SE 9 and 10. And they're not part of JDK 8, or release 8, or SE 8.

So pretty much in this case, if we run it in SE 8, then we used all basically the files that are in the root directory that basically uses all the APIs from SE 8. If your run it on SE 9, most probably there is now another folder that will contain the classes that are built using the upgraded API and part of the SE 9. Let's take a look at that.

So first, we're going to to look at the structure of a multi-release JAR file. So the JAR has root directory which contains a directory structure representing packages and classes. And the META-INF directory is used to store metadata about the JAR file. And, of course, it contains the META-INF and the MANIFEST file containing its attributes. That's typically how we see it here.

So we are com.foo and then the classes. And then you have your entries in the typical JAR file that looks exactly like this. That's typically how we see it.

So continue with this structure of multi-release. So a multi-release JAR file extends the META-INF directory to store classes that are specified to a JDK version. And by the way, it starts with version 9 and then 10, and 11, and so forth. These classes are specific to a particular JDK version and are contained in a version subdirectory under META-INF directory or folder.

So the versions directory may contain many subdirectories, each of them named as a JDK version. Currently we start with 9 and then 10. However, again, new versions of the Java are released, they will be, again, supported as possible directory names.

So which means now if you look at the structure, it basically looks like this, where, in this case, we have entries in the multi-release JAR file first of all. And then then root, which is com.foo, we have the ListUtil.class, SorterType, and SortUtil, and the TestMultiRelease classes, four of them.

And then under the META-INF, now you have a folder called versions. And underneath, it has a number 9. It has com.foo. And then it has ListUtil, and then SortUtil, which, by the way, happens to exist in the root directory. Except that these were implemented using the new features of the SE 9. That's the idea behind this. So these are classes used only when you're on the SE 9.

So which means, now looking at an example of the structure of multi-release JAR file, if a multi-release JAR file is used in an environment that does not support the multi-release JAR file, it would be treated as a regular JAR file. So in pre-JDK 9, which is 8, and 7, and so forth, the content in the root directory will be used. And everything out of the META-INF version 9 will be ignored, as simple as that. Which means the only four classes that are going to be used here is the ListUtil, SorterType, and SortUtil, and TestMultiRelease, and then the root. Those will be, in this case, the four ones that are going to be used.

If you now use the JDK 9, there are two additional classes that will be used. So the ListUtil and the SortUtil classes and then the META-INF version 9 directory will be used instead of the ListUtil, and SortUtil, and the root directory. That's typically what it is.

So if more than one version of a class exists in the multi-release, the JDK will use first the one it finds. And the search began in the directory tree whose name matches the JDK major version number that we have 9, or 10, or later on, 11, and so forth so the search continues with a successfully lower number directory until finally it reaches the root directory.

So for example, here, the ListUtil class has more than one version in the JAR file, and then for the JDK version 9, the search starts are the META-INF version 9 folder. For the JDK 8 or earlier, the search starts exactly at root because the JDK 9 is supported as a directory name. And in this case, pretty much it's ignored by the JDK 8.

So now looking at creating a multi-release JAR file. Let's go ahead and take a look at that. So the jar tool has now been enhanced in JDK 9 and 10 to support creating multi-release JAR files.

So the JAR file now-- rather the jar tool accepts a new option called dash dash release. And the syntax would be like this, jar, and then your options, dash dash release, and then your N, and then other options. The N, again, represents the JDK 9 and up. That's basically what it means.

So which means now, as an example here, so creating a multi-release JAR file, we do have some classes compiling JDK 7 and then some classes under the, in this case, classes dash 9. com.foo, ListUtil and SortUtil, those compile under JDK 9. So now we can use this command jar dash dash create dash file foo.jar file, and then the main class in this case, and then, of course, the command to release the-- or rather to create a multi-release, it's called a TestMultiRelease, and then minus c, the mods/mymod, and then, of course, the current directory, dash release 9 dash c classes-9.

So the classes-9 folder contains two classes compiled at the JDK 9. ListUtil is a class that performs the same function as the ListUtil under the root folder. But it uses features only available in SE 9, as an example. Of course, running this multi JAR file under version 8, basically only the classes that are located in the root will be used. And anything that is under, in this case, the 9, will be ignored.

If you want to list the entries in the foo.jar file that we created, then you can just write jar dash dash list, dash dash file foo.jar. And then pretty much, this gives you the classes and the root, and then the classes under the versions 9 and then, of course a folder.

Of course after that, you can go ahead and run this JAR file either on SE 7, pretty much java dash jar foo.jar, and that's it. Or you can run it under 9. Pretty much java.jar, foo.jar, and boom, and it gets your output pretty much either way. But when you run it on SE 9, really the two classes that are going to be used is the ones that are under the versions and then the release name, which is, in this case, release number, which is 9, which are these two classes, ListUtil under the META-INF version 9 com.foo, and then the SortUtil, same way.

And we can go ahead and try an example. So here's-- you guys are going to try this in the practice. So here we are running the application under JDK 8, as you see here, slash user Java JDK bin Java, and then run it. And that's basically the output.

Or we can go ahead and run it under 9. Let me just do a clear here. And then we could run it now under 9. And pretty much in this case-- typo here-- and the output pretty much will be the same or similar.

So creating a modular multi-release JAR file. How about if you want to create a multi-release JARs file? So here's pretty much the same project converted to a modular project by adding the module-info.java. So we added this under here right under root, in this case, a directory. And then of course, once we do that, now, of course, the root now will be compiled, in this case, because of the module-info.class. So that needs to be compiled with the Java SE 9 or 10.

So here is a command, again, to create a modular multi-release JAR file, modular_foo.jar file, and also sets the main class to com.foo.TestMultiRelease. And that's what you see here, jar dash dash create, dash dash file, modular_foo.jar dash dash main class, and then com.foo.TestMultiRelease, minus C, mods/mymod and dash dash release 9 minus C classes-9. And that's what you have here.

So of course, you can list the entries. If you list the entries, you'll see that all the classes are there. Except that now the root directory has a module-info.class listed because we added that.

And now to run it, pretty much you can run it on 7 java dash jar modular_foo.jar, boom, it does the same thing. You can run it also on 9, which is exactly the same.

Now because we added that module-info.java, now we can also run it on what we call a module path. And you can just say java, minus p modular_foo.jar, minus m, mymod. And then that also will run it, in this case, under the module path.

What we did is we added minus m minus m mymod. So this pretty much allows you to see how the JAR file is run on the module path. And the output is the same as the example where the JAR was run on the class path because, of course, there is no modularity specific functionality.

And of course, in this practice for this lesson, there is an example of multi-release JAR file that has a different functionality when run on the class path than it has when you run it on the module path. And you folks are going to try this in the practice. That's why we said when you try it, the output might be different when I run that earlier.

And that's pretty much what I wanted to say about this multi-release JAR file. So we do have one nice practice multi-release JAR files that we'd like to try. That's in practice 8-1. Please try it before looking at the solution. Thank you.

## 2. Practice 8-1: Multirelease JAR files - 6m

Now that we are done with lesson 8, let's go ahead and take a look at 8's practices. We're going to do one practice for it. It's practice 8-1. Here, we're going to deal with multi-release JAR files. In this practice, you will look at an application that is designed to run on SE 8 or Java SE 9.

The application is a simple version of the TeamGameManager application. It is different from previous versions of this application you worked with in the following ways-- no persistence, no use of Jackson library to persist sets of games, only one competition type A league, displays soccer and basketball by default when running the application, it will play and display a soccer league and a basketball league, and uses a multi-release JAR file, and can be run using SE 8 or SE 9.

So we'll navigate to the 08 multi-release examples and the MR staging TeamGameManager. And then we open, in this case, a terminal. And then we'll run this command here. Let's go ahead and do that.

So I already have this already opened. And here it is. And if I run it, pretty much does the output.

And then after that, I'll go ahead and run it using the SE 9. And that, of course, we'll be in the next one, which is this one here. And that should run without any problem, in this case. Let's go ahead and do that. And that's the output. So it's running.

And now what we want to do is in the next step, what we want to do is we'll go ahead and remove, in this case, the JAR file and run it again and see what happens in the 9. So we'll do an rm, in this case, dist forward slash soccer. And then we'll go ahead and run it again. So I run in this case.

And now what we want to do is run it using, in this case the 8 version. And we run it, or course, we are going to have an error. That's exactly what they want us to do pretty much.

So when we run it, we'll go ahead and find an error. And that's exactly what we have, no class def found error. And that's what we have as an error here so far when I run it.

So now we examine the material. So in this [? stage, ?] we double-click on the icon Oracle home and on the desktop. And let's go ahead and do that, in this case.

And we double-click on that. And then they want us to click on the Oracle, in this case, and in this case, double-click on the icon Oracle home on the desktop, and browse in this case, this guy here. So we'll click on this. And then browse, in this case, to a forward slash user-- rather lab 8.

So we'll go ahead to Labs, and lab 8, Multi-release, and then, Examples, and then the MR Staging, and then the distribution. That's what we do. And then right-click on the, in the case, the competition JAR file, and open it, in this case, with the Archive Manager. That's what we have.

That's pretty much just following exactly what they asked me to do here. This will help you see the content of the JAR file. And then we see it here. And then, of course, on the game that we see here, that's-- and we have the factory.class. [INAUDIBLE] we've seen all that.

And of course, this is how the multi-release feature works. If the application is started in Java SE 8, all the classes under version 9 are ignored. But if you start the competition with, in this case-- in our case here, Java SE 9, then of course, you will see the ones under the version in this case, under the version.

So under the META-INF, you have that version, and then you have the 9. And under the 9, you have your Game class, which is this one here that if you run it under 9. That's basically what we mean by that. And that's pretty much what they want us to do in this practice.

## 3. Skill Check: MultiRelease JAR Files - Score 80% or higher to pass

Skill Check: MultiRelease JAR Files

View Skill Check


