# 4: The Modular JDK
   
1. The Modular JDK - 22m
2. Practice 4-1: Listing the Platform Modules in JDK 9 - 2m
3. Practice 4-2: Resolving Java EE Modules at Runtime on the Classpath - 3m
4. Skill Check: Modular JDK - Score 80% or higher to pass

## 1. The Modular JDK - 22m

Let's go ahead now and take a look at The Modular JDK, which will be, in this case, lesson 4. Here, we're going to investigate how actually the JVM, now, is divided into modules. So we're going to describe the modular JDK. We're going to list the Java SE modules, the Enterprise Edition modules, which, by the way, are going to be deprecated from the JDK 9 10 and up, describe changes to the installed JDK/JRE image and explain the encapsulation policy for JDK Internals API.

So let's start with the modular JDK. Well, JDK 9 and 10 enables modular development all the way down. So in a sense, your application will be modular. Libraries are modular. You will also have a modular JDK, and you have a modular tool that pretty much allows you to discover the modules inside the JDK. And of course, the Java language and the JVM [INAUDIBLE] all this modular system.

So before the JDK 9 and 10, the JDK was huge and monolithic. But of course, that basically was the consequence of an increase in the download time, startup time, and the memory footprint. It was just huge, colossal. So in JDK 9-- 9 and 10 rather, the monolithic JDK is broken into a bunch of modules. It now consists of about 90-something modules. Every module is well-defined a piece of functionality of the JDK.

Again, all various frameworks that were part of the prior release of JDK are now broken into a bunch of modules. Example, you have the Logging, the Swing, and [? Installing ?] and so forth. Lots of times we've got all these Swing API and a bunch of other APIs that get installed with the JDK 8 and 7 and so forth but we never use them. And so it's like having all these bags full of clothes that you never use, and you're pretty much traveling with them all over, and they're just taking space for nothing.

So the modular JDK now makes it more scalable to small devices, which means use only what's needed and improves security and maintainability and improves, of course, application performance and no question about that. We're going to see an example when we create a custom image. And if you want to look at the list-- in this case, the modules-- in JDK 9 and 10, you just go ahead and do that. So let's go ahead and take a look at this as an example.

So here, for example, we can go ahead and look at the list of the modules. So I can go ahead and list the modules. Here are all the modules that are in the JDK 9. 10, of course, is very, very similar to 9. I can go here and count how many modules by running java --list module and then pipe it into wc -l. This will tell me that there are 99 of them here.

So that's basically what we have here. And of course, the Java SE modules-- basically, in this Java, that SE module, this module does not contain any code but has only dependencies declared in the module descriptor. So here I have module-- in this case-- java.se. And inside, it shows that it requires transitive java.desktop, requires transitive java.sql, and so forth. That's basically--

So in the module descriptor, a requires transitive clause is listed for every single module that is part of the SE specification. Of course, when you say requires java.se in the module, all these modules will be available to you. So it's a high level one, and it just requires all the modules. It has nothing inside it.

And of course, these modules are classified into a couple of categories if you want. We have the standard modules, which are the java.whatever-- prefix for the module. These are part of the SE specification. For example, the java.sql for database connectivity, the xml for XML processing, the java.logging for logging, and so forth. And then you have the second category, which is modules not defined in the Java SE 9 platform. They are jdk. and our prefix for a module names, and they are specific to the JDK. Example, jdk.jshell-- we'll take a look at that later on, policytool, [? httpserver, ?] and so forth.

And here's the graph that represents the dependency. As you see here, Java SE basically depends on all the different type of modules inside, and then other modules depend on other ones and so forth. That's basically the way it is. And if you take a look, you can see that java.base, every other module depends on the java.base.

So the base module, which is java.base, every module depends on java.base. But this module does not depend on any other module. And the base module exports all the platform core packages. In this case, would be the java.lang, java.io, java.net, and java.util.

On the other hand, the com.sun.crypto and then the sun.nio and the sun.reflect.annotation and so forth, those that are concealed packages. But the ones that are available to all the rest of the-- even to the application would be the module java.base, which contains the java.lang. It explores the java.lang package, the java.io, the java.net, and the java.util. That's what it does. So pretty much it would be the default one that basically is available to all the rest of the other modules.

OK, so if you want to get a list of the packagers a platform module contains, you can go ahead and use the --describe-module. Here's an example where you can say java --describe-module java.base. And this will give you basically all the list of the that package that exports. Let's go ahead and take a look at that as an example.

So go ahead and set it for a java --describe-module java.base, and this gives me all the packages. I could do it also for the SE. And as you see here, it requires, all those, a transitive in this case. We already discussed that earlier. So you can see the java.base exports the java.math package as an example. But there are other ones too.

Now also, how about the location of some of the tools? Here are some of the tools and where they're located. The javac for compilation is inside the jdk.compiler module. The java is inside the java.base module, jshell inside the jdk.shell, jdeps inside the jdk.jdeps-- we'll take a look at jdeps later on-- and jlink is under the jdk.jlink module. We'll use these jshell, jdeps, and jlink later on in different lessons.

Now, speaking of the Enterprise Edition modules, those that existed in the SE 8 and 7 and so forth, let's just take a look at what happened to them inside JDK 9 and 10. There are various technologies in the Enterprise Edition that are shipped with JDK. The list of these [INAUDIBLE] modules are, like, the corba, the .activation, annotation.common, transaction, bind, and so forth. These modules are deprecated for removal in JDK 9 and 10 and will be removed in the future. Because of this, they are disabled by default in JDK 9 and 10.

So here's a graph about the Enterprise Edition, as you see, the java.se.ee. And then underneath, you have the java.xml.ws for web services, and the corba, the transaction, and so forth. Now, the Enterprise Edition modules are not resolved by default when you compile or run the code on the class path.

So the code on the class path, typically with references to the classes in these API will fail with a NoDefClassFoundError or a ClassNotFoundException. The policy of not resolving these modules is the first step towards removing these APIs from the SE and the JDK in the future releases. What you can do is you can use the option --add-module, the command-line option to ensure that the module with the API is resolved at startup.

And for that, let's see an example. Here, if I run the JAXBCustomer here, we're going to find that it's going to have a problem. And this problem, because of the fact that the javax.xml.bind is not there. And to resolve the java.xml.bind module at runtime and ensure the JAXB API are available at runtime, we specify, again, the command by using the -- module. Let's go ahead and look at this as an example.

And let's go ahead and run this. If you are on it like that, you see that we have now error enabled to initialize a main class with the com.example.JAXBCustomer caused by the java.lang.NoClassDefFoundError and under the javax.xml.bind.JAXB. We can solve this by, again, using the --module and then javax.xml.bind, if you're done this, then of course, it's going to give us an output. See now, we have a-- we solve that problem, and that's basically what we see here.

There are also some changes that happen to the installation of the JDK JRE image, so here, just to give you an idea, is basically how the JDK 8-- it has the bind, the JRE, and then under the JRE, you have the bin and then the library RT.jar and Tools.jar and so forth. JDK 9, on the other hand, is different. All that JRE directory and the Tools.jar and the RT.jar-- they're not there anymore, and we can see this as an example. So for that, let me just go ahead and just look at them so I can browse my computer and [INAUDIBLE] and then a right on the Oracle and go one level up, one level up. And then underneath here, I can go to the USR, and then from there, I can find my Java.

So here is the installation of JDK. Again, as you see here, you have your JRE underneath, and you have libraries, all of those here underneath. And the JDK, in this case, a 9, is different, so you don't have that JRE anymore, as you see here.

So of course, there are some changes in the JDK and the JRE layout, so again, in JDK 9 and 10, code that assumes the following about the JDK layout will fail, which is library that contains RT.jar. Presence of RT.jar and Tools.jar is not there anymore. Class and resource files previously stored in the LibRT.jar and LibTools.jar and LibDT.jar and various other internal jar files are stored in more efficient format in implementation specific files in the lib directory. And then of course, you can see that basically under here, and then you can find all of them.

Now, looking at JDK Internals API-- well, here, pretty much what we have in term using the JDK Internals API, we have again, in this case, the JDK API and where we have the public API Java.star and JavaX and org [? dots ?] and so forth. And then you have the Internals, which is the Sun and the com.sun and the JDK, all of those in Internals. And of course, over there, you have critical and noncritical. The critical APIs are available in the jdk.unsupported module, and then the noncritical-- they're encapsulated in the JDK 9 and 10.

So using the JDK Internal API, continue with them. The JDK consists of public API and internal API. The public API are used to develop portable Java applications, which are all installed inside the java-dot and the javax-dot and the org-dot packages. And if it works in a JDK version, that means we'll continue to work in JDK version N plus 1, meaning 9 and then 10, 11, and so forth.

Internals API, on the other hand, are used to implement the JDK itself. They are in the com.sun and Sun and JDK packages. They are not meant to be used by developers, which means one thing that is [INAUDIBLE] missing, is what? Is the reflection.

So before modularization in JDK dat-- 9. It was, again, 9 and 10-- it was possible to use any public class every-- even if those classes made up the JDK Internal API. JDK Internal API, such as [INAUDIBLE] classes that have been used by developers, like in this case, a base 64 encoding and so forth and the sun.misc.unsafe and so forth.

So now, in JDK 9 encapsulation, policies for JDK internals are, in this case, different. So now, we're going to have access to the BASE64 encoder or BASE64 decoder. Instead, you have access to the java.ttl.base64, which is introduced in JDK 8.

Let's just discuss, a little bit, the illegal access to JDK Internals in JDK 9 and 10. Some tools and libraries use reflection to access part of the JDK Internals. That was in AC 8 and 7 and so forth. These illegal reflective access, starting JDK 9 and 10, will be disabled in the future release of the JDK.

So in JDK 9 and 10, it is permitted by default and warn-- and a warning is issued. For example, in this case, here's some of the warning that you get, and let's just see an example about that. So let's see. This example is going to run it that we've seen that, so you see you get a bunch of warnings here that you see. And that's basically what we see here in a-- that's basically what we see here.

So you see a warning like this, contact again the maintainer of the tool or library. Basically, that's what it is. So this pretty much here showing you that the line indicates the exact jar file whose code use reflection to access an internal part of the JDK. Now, as you know, a reflection is not allowed in JDK 9 and up, 10 and so forth. That's basically what it is.

So to solve this problem, typically, we need to, in this case, to disable the warning on the library. In this case, a base-- library by library basis, you can use the --add-opens, and that allow you to get rid of those warnings. Again, this time, the warning is not issued because the Java invocation explicitly [INAUDIBLE] the reflective access.

So as you can see, you may need to specify more than one --add-opens flags to cover all the reflective access operations that are attempted by libraries on the classpath. Here is, we see, a couple here on the slide. So of course, here, just a-- pretty much a diagram that shows you some illegal access to JDK Internals in JDK 9, so you can see these type of errors here that says illegal access error that you see over there.

And of course, we finish here just by looking up, in this case, a small quiz. And in the small quiz, it says in JDK SE 9, which-- 10, of course-- which namespace contains modules that are not defined in the JDK-- in the Java SE 9 platform specification, but are instead specific to the JDK? And if you take a look at this, you will be, in this case, B, java-dot.

And which three directories are not present in the JDK 9? If you look carefully, there are, A, JRE, and they are, B, in this case, the RT.jar file, and then of course, D, which is the Tools.jar file. Those are not there anymore-- A, B, and D. And these are just additional resources if you want to read a little bit more about that.

So in this particular lesson, we looked at the modular JDK. We listed the Java SE modules and also the Enterprise Edition modules. We described the changes to the installed JDK JRE image between 8 and 9, and explained the encapsulation policy of the JDK internals.

We do have a couple of practices that we definitely advise you to please try them. Firstly, listing the platform modules in JDK 8, and then resolving the Enterprise Edition module on the classpath at runtime. Pretty much similar to what I have done in the example, except that you're going to use the dash add-- the previous one that we just looked carefully here, which is the --add-opens. So go ahead and try these before you look at their solution. Thank you.

## 2. Practice 4-1: Listing the Platform Modules in JDK 9 - 2m

OK. Now that we're done with lecturing lesson four, let's go ahead and look at these practices. We'll start with practice 4-1. Here, we are going to list the platform modules in the JDK 9, by just running Java space dash dash list dash modules. Let's go ahead and do that.

So here it is under the command line. In this case, Java [INAUDIBLE]. So if I hit Return, that will, of course, will list all the modules. That's pretty much what they want us to do. OK? That's what we see.

OK? What we could do is I can go ahead and, in this case, run another command to count how many modules I have over there. So I can write Java space dash dash list dash modules. And then pipe it into WC minus L.

This will give me the fact that in this JVM that we installed here, the JDK 9, has 99 modules. And that's pretty much what they want us to do in this practice.

## 3. Practice 4-2: Resolving Java EE Modules at Runtime on the Classpath - 3m

Let's take a look now at practice 4-2. Here, we're going to resolve the Java EE modules at runtime on the classpath. So in this practice, we'll resolve the Java EE module at the command line by using the dash dash add my dash module switch. In JDK 9 and 10, the Java EE modules are deprecated for removal and would be removed in the future release. Because of this, they are disabled by default in JDK 9. OK?

So we can open a terminal and browse to the JAXBdemo. And again, this project contains two source files-- customer.Java and JAXB.customer.Java. Both these files invoke JAXB API, which are part of the Java.xml.bindmodule. This module is deprecated for removal.

So we are going to execute, in this case. So we'll get into that and then we'll execute that command. And that's exactly what we have done here.

And then I'll execute the command. And then guess what? I now end up with an error. OK? That's what I have here. OK? That's what I have when I run it.

And so that's basically what I got as an error. And as you see here, it is exactly what I have here. And now to fix this problem, we cannot resolve the Java.xml.bind Java EE module at runtime by using the dash add, dash modile switch and specify the module to be added. And that's exactly how we should do that. OK?

And that's what I have done. So in this case, I just basically added this to the command line. And then when I run it, it runs properly and gives me the output. And that's exactly what the output that they want us to see, in this case, as an output when I run it. That's what I have. And that's pretty much what they want us to do for this practice.

## 4. Skill Check: Modular JDK - Score 80% or higher to pass

Skill Check: Modular JDK

View Skill Check
