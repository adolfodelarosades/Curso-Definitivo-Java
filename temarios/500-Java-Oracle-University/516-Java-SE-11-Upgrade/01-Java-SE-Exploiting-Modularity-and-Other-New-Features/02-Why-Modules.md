# 2: Why Modules?

1. Why Modules? - 31m
2. Practice 2-1: Creating Services - 6m
3. Skill Check: Why Modules - Score 80% or higher to pass

## 1. Why Modules? - 31m

Let's go ahead now and take a look at lesson two. In lesson two, we're going to talk about, why modules? That would be a good question to answer. So for this lesson, we are going to describe the aspect of the Java SE 8 that can contribute to different types of errors. And we're going to take a look at-- by the way, not just eight. Eight and seven and six and so forth. And describe the features introduced in the SE 9 and 10 design that helps to reduce the number of errors and have them occur earlier in the development process. And of course, describe the purpose of Encapsulation, Interfaces, and explicit dependencies.

So starting with the module system overview. Well modules are pretty much a fundamental new kind of Java programming component. So basically, we changed fundamentally how we work with the JVM. Even the JVM itself, we changed it. The JVM now-- JDK, Java SE 9 and 10, they actually contain modules rather than JAV files-- those packaging files.

So the module system supports programming in the large. The large means the high level. In a sense, you don't get into the low-level programming where you may see maybe using lambda expressions and streams to write some classes that handle different type of business logic for you. Fine. That would be the low level. Here, we're talking about a high level where we basically show you how to build an application so you can deploy it, a job application deployed using modules.

So this modulization is built into the Java language itself, and it's usable at many, many different levels. It's used at the application level with the applications that you are coding, implementing. The libraries that you make use of, they're also based on modules, and the JDK itself, like I said. The JDK itself also now would be in this case handed using modules. And to be able to understand the different levels, let me go ahead and use a diagram so you can see the JDK level, the library's level, and of course, the application level.

And lets use a pen just as an example here. So imagine that you have here a platform. Let's assume that you have a hardware platform that would be your, in this case, hardware server, and would be any type of a server. And of course, to make a machine work, what you need to do is install an operating system. So here's our operating system. And then of course, after that, if you want to run Java, you need to install a JVM. So that's your JVM. And then after that, you have your application plus the libraries that the application needs. Those would be your applications. And of course, any libraries that you want, in this case, to use. And this is pretty much following what we have said here.

So in that case, I'd say--

[ERROR SOUND]

Let me just ex that. These would be basically any libraries that are needed for your application. And what we have done here pretty much, we changed fundamentally the JVM itself, the libraries, and the applications that you are building. They all are going to now use modules. That's basically what we want to say here. So this module system addresses reliability, maintainability, and security, and supports core supports, creation of applications that can be scaled for small computing devices. Because now, in one of the lessons, we are going to learn how to create your own custom image which is going to have a very low footprint.

So here are the levels that showed you more or less on the diagram that I just drew in front of you. Or you can look at it this way, where you got your JDK. JDK now is all using modules, and then you have all your libraries also implemented based on the module system, and then your application's JAR files that also are based on your module system too. We still JAR them, because a JAR file is nothing but a zip file. We still JAR our modules into JAR files.

So now, speaking of JAR files, well, we all know how Java SE 8 addresses maintainability and reliability. Basically, we know that SE 8 and previous ones, previous JDKs, are strong typing based and make use of Encapsulation. We also make use of Interfaces and of Codependencies. This is all part of the Java technology.

So we all know that in Java, you can go ahead and have a class, extend another class. We know that in Java, we have second inheritance, and we can have a class that implements one-on-one interfaces. Nothing is new here. Pretty much even in JDK 9 and 10, we still basically use the same concept.

Now of course, whenever we build applications using JDK 8 and previous ones, we basically know that the class level unit of reuse would be, in this case, any type of class or set of classes that we want to maybe put into a library that we can go ahead and make use of. So we know that encapsulation is handled through the access control. We know that the API provided by interfaces that you implement have a class implement, and then of course we know that dependencies are done through imports. That's the import. Different type of classes that you make use of inside your class and inside your application.

And we know also that in Java SE 8 and the previous versions, we typically make use of packages. So in general, if you want a package and you want to make it available to a class inside another package, then that package that you want to make available must be given public accessibility in order to be accessible from another package. That's typically how we've done it using the JAVA SE 8 and previous versions. That's how it works.

And then of course, because a particular class in your package wants to have access to a particular class, then of course, that class must be in your library, must be in this case accessible. It is directly accessible from any package in any JAR file, even if it's not likable or not desirable. This is one of the problems that we had in the JDK 8 and the previous ones is that if you want a class to be out from a particular package, want to be accessed by other classes or from different packages, you have no choice but to make it publicly accessible. And so other classes can access it from different packages. And even though, unfortunately, in some cases, it's not likable from the maintenance point of view, from the security point of view, and so forth.

And this is how we've done it before. The way basically we make classes accessible or make different packages accessible to other classes in other packages, we use the concept of the JAR files. So JAR files, and then we can distribute these JAR files. Unfortunately, the distribution has a bunch of issues. JAR files are typically used for packaging the class files, for your application. Or even sometimes in most cases there are a bunch of libraries and they're composed of a bunch of packages with some additional beta data. That would be, in this case, the main class to run them and then the classpath entries and the module release flags and so forth.

And they're added to the classpath in order for their content, or if you want, classes, are made available to the JDK for compilation and running. That's typically how we did it. So some applications may have hundreds of JAR files in the classpath. And basically, we have to work with that classpath in the different scripting type of languages and to move into other scripting languages to be able to make these JAR files or these classes inside these JAR files available for usage.

Of course, we do have a problem with the classpath. JAR files in the classpath can have duplicate classes IN other packages too. This is how we did it. And of course, the way actually the Java runtime tries to load every class as it finds it. So that's why we have to put them in the path so that the runtime will load the class that we're looking for. It typically uses the first class it finds in the classpath. That's typically how we did it, even if another similarly-named class exists. But as long as it's not the first one in the classpath, then we're good to go. We know that the first one that we have in the classpath is the one that is needed, and then we're happy with that.

Except that unfortunately, isn't it's not always the case. In some cases, it might be in this case a mistake where we can go ahead and say, well, unfortunately, instead of picking up or grabbing the first class that we want to use, for some reason, it's not in the classpath anymore, and now it's using another class. Even though it has the same name, but it has different features. It might belong to a different package, and that definitely would be a problem. So the first class could be the wrong class if several versions of the library exist in the classpath.

And of course, lots of these problems may happen only under specific operation conditions that require a particular class. So in general, we always end up having these type of problems where we try to put the class that we're looking for or we want to use as the first one in the classpath. But sometimes problems happen, and suddenly now it's not there anymore, and that definitely will create a problem.

So in terms of continuing with the JAR file dependency problems, we know that classpath permits many versions of library, including duplicated files. So the problems we have-- there are no explicit dependencies, there is no proscription on split packages, there is no proscription on cyclic dependencies-- actually, this is one of the biggest problems that we have in JDK 8 and before, or applications built using JDK 8 and before-- and of course, all public classes in the Java files are accessible, which actually is not always likable. It's not always desirable. And that definitely can be a problem.

So let's just use as an example just so that we can have an idea here-- so we have here a JAR duplicate class problem here, where we do have a class-- a main class, in this case-- in the application JAR file that makes use of a class inside the library called Util. So as long as the main class finds that Util class as the first one on the classpath, we're good to go. But sometimes, maybe you want to add more features. If you want to add more options to your application, most probably those options will be now captured in this case in another package called Optional Features.

And it turns out that that package also has another class called Util. As you see here, we do have the first one, which has a class called Util, and then the second one has also another class called Util. But as long as we know that the first one is located as the first one in the classpath, so we got now no problem in this case in terms of the classpath loading. Or we know that the first one is picked by the main class before the first with the second Util class, which is located under the package that contains the Optional Features, and we're good to go.

But it's not always the case. Sometimes, somehow, for some reason, a class is not there anymore. And then what's going to happen is now, the main class is going to look for a class that is with the name Util, and then it wants to go ahead and make use of it. Except that unfortunately, this class, even though its name is Util, it's going to give you the wrong results. It's going to do the wrong things for you simply because it is not the right Util class that we're looking for. The first one somehow disappeared. And this is definitely a huge problem in the JDK 8 applications and the previous ones too. So obviously, this would be a problem, and of course, in this case, we're going to have the wrong results, the wrong behavior, if you will.

So to fix this problem, we created this new feature, which is the at-large feature, if you want, the high-level feature, which is using the modules and the modular JAR files. So in this case, look what we have done. In JDK 1 through 8 applications, we all knew that there are different type of modifiers. We have access modifiers. We have the public, where it's universal. Everybody acts as that class. Protected is accessed by only the inherited class or to the extended classes. Even though they are located in different packages, package is the default, which means the class accesses another class within the same package. And private is accessed only within the class, which means only the methods within the class can access that method or that private variable.

Well we changed that in JDK 9 and 10, and now we use the public to everyone. So it's similar to the first public that you have here, but then we have now two other publics. So that public that we used have, know, or use in JDK 1 through 8, now it no longer means accessible to everyone. Now we can make public, but only to specific modules, and public only within the module. See, now we changed. So these are two new features that we added, and of course, we're going to discuss how we do that in the different lessons.

Protected is still the same package and private is still pretty much the same as in the previous JDKs. So look at JDK 10 now, for example. In using it, you will see now you can make a class public to everyone, or public but only to a specific module, and public only within a particular model.

So it turns out that this module system has lots and lots of advantages, and addresses again some of the issues at the unit of distribution or use levels like dependencies and encapsulation and interfaces. We're going to see many examples of that. And the unit of reuse, in this case, is the module. So it is a full-fledged type of Java component, and it explicitly declares dependencies on other modules and what packages it makes available to other modules. So here, we are going to have what we call a module can acquire another module, and a module can export different packages if they want. So only the public interfaces in those available packages are visible outside the module.

So now, this Java modular system helps us now build applications with no missing dependencies, with no cyclic dependencies, and with no split packages. So this is a huge advantage. No question about that.

So now, when we look at the concept of the modules-- if we look at the access across non-modular JAR files, we know that because you are going to make a class accessed by another class, so that particular class must be publicly accessible. It is of course directly accessible from any package in any job files, even if it is not likable. And that's basically how we did it all the time. Except that if we look at the module system-- so here, a diagram that shows us the access across modules-- let's assume that here we have a couple of modules.

We have module A that contains a couple of packages, X and Y, and then we have module B that contains three packages, L, M, and N. Now what we're going to do is we're going to make module A requires module B, but then module B says, wait a minute. You require me, but I'm going to export to you only package L. Ah, you see now what we're saying-- for example, think about that package Y. It can access, in this case, the classes in the package M of module B, and that's it. It cannot access in this case the packages in package L, and of course, it cannot access the classes in this case in package N.

Which means now, even though we made A, and module A requires module B, but then module B says OK, I'm going to export only package M. I'm going to export only package M. Again, the way it works is a module can require another module, but then a module can export only packages. That's basically how we're going to see that. So that's why, in this case, we can say that in our case here, module A classes, in this case, can have access to only in this case classes in the package M, and that's it. Which means the classes in package L and N, you cannot access them from module A. So that's how we show you now that package M is not accessible, simply because modules B decided to export only package N, and that's it.

And we do have a very nice application that we are going to look at, and this is called a tournament-type of an application, where here we have the main class that makes use, in this case, or requires the competition module. And then of course, in some of the competition modules, we have a couple of interfaces, terminal type, and game, and then we do have the classes in the module league and knock out that implement the tournament type-- in this case, interface-- and the class in a module. Basketball and soccer implements the interface game. We're going to see all of this as an example.

Now, if you want to work with, in this case, the concept of modules, this is what you're going to see. Let's just take a look at the module competition. It turns out that here, a module will have a class called-- so it turns out that here, we have the module competition, and the module competition has a class-- every module has a class called module-info.java. And here, we are just showing you the code inside that. In this case, module-info.java class. So it has the name Module Competition. So that competition would be a module, and we decided that this competition exports the game package, and exports the game API package, and exports the Util package, and then uses the game provider and part of the game API and the tournament type. These are basically interfaces.

So we're going to learn about that export and uses in the next lessons that we are going to see in this course. Here are the examples or what type of code would be inside the module-info.java for the module league and the module knockout. So the module league requires competition. So you see how module competition exports packages, and then module league requires a module, in this case called competition, and then provides the tournament type with the league, which means the league will implement the 10 minute type. We see that.

And then the module knockout requires competition, and then provides the tournament type with the knockout. Which means one class inside the knockout is going to implement the tournament type. We'll see that. And here's some code that you can have in the module-info.java for the modules basketball and soccer. So look at the module basketball. Requires competition, requires the Java.logging. That's part of the API. And opens basketball to databind. We'll understand about opens later on. There is opens and open. We'll take a look at that some point in time.

And then provides the game provider with the basketball a provider, so there's a class called basketball provider that implements the game provider interface. And then for the soccer module, again, this would be a code written inside the module-info.java. That will be, in this case, inside the module soccer. So this requires a competition. It requires a java.logging, opens soccer to databind, and provides the game provider through with the soccer provider, which means the soccer provider class implements the game provider interface, and we see that at some point in time.

So just to show you an example about that-- of course, we're going to look at more examples later on, but I'm going to just show you an example here. So here's an example. So this is the old soccer manager application, which basically has packages. For example, here I have an event package, and I have a play package, and I have a Util package. And then inside every package, you have Java classes. This is how we've done it before. Now in the module, you see how even the icon of the old application uses an icon like a cup of coffee. This one here uses the different icon, which is this one here.

And if you take a look here, these are different modules. So, for example, the basketball, and the default package, which is like a root package here. We have the module-info.java. Basically, that's where do you write your require-- requires competition, requires a java.logging, opens basketball to a jackson.databind, and then provides the game providers through the basketball provider class.

And then we see an example of the competition. The competition also has a module-info.java that contains, in this case, the code, or if you want the definition or the declaration of your module competition. That exports game, game API Util, and then uses the game provider and the tournament type. We'll learn about all of those keywords in the next modules-- exports and users and so forth.

And here is the game. The game has a factory, key class, and has a tournament. So that's a package under the competition, and the game API also has all these classes. And then of course, under that, we have the knockout module, which pretty much acquires competition and provides the tournament type with the knockout class. And then it has a couple of packages-- knockout and a knockout Util. And then the same thing with the league-- it has also a module-info.java, and then we have the main. If you remember, the main-- we made it, in this case, require competition. Requires logging [INAUDIBLE], and then requires a display.ascii too, and then storage.

These are all basically A modules. Here's the soccer, which also has a module-info.java. Requires competition, requires logging. Exports soccer to [INAUDIBLE]. You see now, exports to opens to-- we'll learn about all of this later on. Provides with. We'll learn about all of these in the next few lessons. And here we have the module-info, which in this case requires the annotations and the jackson, the cords, the databind, and requires transitive. Here's something that we a just looked at. And so we're going to look at all of this-- exports and require transitive, uses, and so forth. So we're going to see all of these.

So this is just to show you an example. It's pretty much the same application except that now, of course, it's called a team game manager. And the other one also pretty much has the same thing. It has 1, 2, 3, 4, 5, 6, 7, 8-- 8 modules, and we learn about these throughout the course.

So in summary, we just looked at how the use of JAR files as the unit of the submission SE 8 can contribute to different errors, and we looked at how modular design can help to reduce this number of errors. And then we're going to look, of course, in different levels to how all of this is going to happen. And then the purpose of encapsulation interfaces and explicit dependencies. You pretty much know about that from the old JDK. We do have a practice. We're going to look at that at some point in time. So once you finished the lesson, always try the practices, and then we take a look at them later on. Thank you.

## 2. Practice 2-1: Creating Services - 6m

Now that we're done with Lesson 2, let's go ahead and take a look at these practices. And here we have a Practice 2-1 where we examine a modular application. Here, we're going to open a project called SoccerManager, and that was implemented in Java SE 8 to manage a soccer league. The application tracks games and totals, the goals and points scored to determine the league winner. Every time you run the application it creates and plays all the games to determine a new league winner.

The second project is a modular one created and of the Java SE 9. And that one illustrates, in this case, the modules, and, of course, using Java SE 9 and services, the functionality can be modularized and extended easily. Again later, we'll discover that these are services, while important, is only one advantage of using the Java SE 9 for applications.

So first, they're going to ask us to open, in this case, the Soccer. So first, they are going to ask us to open the SoccerManager project. And that's and then examples. Let's go ahead and do that. So File, Open a Project, and then look at, in this case, a Lesson 2. And then open the SoccerManager.

This is just a Java SE 8 application really much. It has, in this case, a bunch of packages where we have the event, a package that contains a bunch of classes. And then the play package contains a bunch of classes. And then the Soccer a package contains a bunch of classes.

And then they ask us to run it. OK? Run this application. So right click and run it. And this will give us some output. In this case, just an output of teams playing each other and so forth. OK, and the scores and so forth. That's what we have. So that's what we have.

And then, of course, after that, so we've seen what classes we have in every single folder. And then after that, they want us to open another project. But this time, this project is modularized. It's called TeamGameManager. OK? This TeamGameManager, as you see, it has now a different, in this case, a modules. OK?

So this module, for example, has these packages. This first one has the module_info.java which we'll discuss later on in the different lessons. And then, of course, as you see here, it has also packages that contain Java classes-- basketball and util and the same thing with the competition module and the knockout league, main soccer, and storage. OK?

If you run it, this also will give us some output. Here it is, pretty much. Kind of similar to what we've seen-- the one that we've seen using, in this case, the application that was implemented in SE 8. Now, of course, they ask us to look at the different type of modules. We can do a little bit of examination here by expanding the different module and looking at the different classes inside, inside the Competition, the Knockout.

And here are some classes over there. And here's a Knockout class. And, of course, every module has its own module class called a module dash for that job. OK, basically. And so the basketball provides the function to run a set of basketball games. Competition provides the factory services to create any kind of competition with any kind of game as long as there is a service that supports that game or competition.

Knockout provides the functionality to manage a knockout-style competition. League provides the functionality to manage a league-style competition. Main is used to set the application in motion and determines which services to use. And Soccer provides the functionality to run a set of soccer games. That's basically what we have, OK?

And this is pretty much what they want us-- and then, of course, the Storage provides the functionality for storing games. You can easily extend this or that. The application has a number of modules for storing to a database, like, you know, XML files or json files or any other storage functionality designed. OK? And that's basically what they want us to do in the practices of Lesson 2.

## 3. Skill Check: Why Modules - Score 80% or higher to pass

Skill Check: Why Modules

View Skill Check
