# 13: Convenience Methods for Arrays

1. Convenience Methods for Arrays - 21m
2. Practice 13-1: equals() - 4m
3. Practice 13-2: compare() - 3m
4. Practice 13-3: compareUnsigned() - 3m
5. Practice 13-4: mismatch() - 3m
6. Skill Check: Convenience Methods for Arrays - Score 80% or higher to pass

## 1. Convenience Methods for Arrays - 21m

Let's go ahead now and take a look at more convenient methods. But this is for arrays. Here, we're going to call convenient methods from the Arrays class, and identify an appropriate method for a given situation, and set a range when examining arrays through convenient methods.

So here we going to pretty much look at equating two arrays. Let's assume that everyone knows what is an array. Again, they're basically objects that store many values of a single data type. And arrays may exist of primitives or objects. And their length is finite and declared when instantiated.

Arrays are a common and fundamental level knowledge. We all know about that. And they are basically used everywhere.

Here's an example, array of integers. Or we can declare a second array too, or an array of [INAUDIBLE] size 2. And we can, say, assign the value 0 to the first element, then 1 to the second element. Or we can go ahead and create an array of strings and initialize with this array-- zero, one, two, three strings.

So, lots of times when we model DNA strands, we'll typically explore arrays conveyance, in this case, methods with different type of scenarios, which the DNA is otherwise known as deoxyribonucleic acid. So the DNA stands is or rather strand, is built from a series of nucleotides. They are adenine, and thymine, and guanine, and then cytosine-- A, T, G, C. And of course, we can represent the DNA strand in Java as a character array. So here's that character array called DNAStrand1, made of the, in this case, the series of nucleotides, which are A, A, G, T, C, T, G, and also so forth.

So the idea here is that we want to work with the DNA strands. And let's assume that we have several DNA strands. And we want to see if two strands match.

This, in general, is done maybe to solve a crime, maybe to verify paternity, maybe to identify patterns or mutation indication for medical condition. This pretty much how we apply different medication to different situations. That's what we have.

So here, we would like-- we could, again, do this in Java. We just go ahead and program that. We have now three arrays of DNA strands, 1, 2, and 3. That's what we have.

And then we can go ahead now and work with the DNA strands by using a for loop. We all know about that. We can use a for loop and pass strandA and strandB and then compare that, and see if they are the same. If they are the same, will return true. Otherwise they return false.

So we all know about this. And we can see this as an example where in my first exercise here, I can go ahead and use the for loop and then try to find out if the DNA strandA and DNA strandB arrays are pretty much the same. A, in this case, and B as an example, pass them, by calling, in this case, the method. And of course, when we're on this, it returns a true and false. It all depends what you're comparing in this case.

For example, if you're comparing, in this case, the first one to the second one, and they're false. But the first one to the third one, they're exactly the same. And that's why we get false and true. So that's what we have here as an example.

But starting Java SE 9, we introduced the new methods to the array class. And these let us work with this kind of scenarios more easily, the equals, the compare, compareUnsigned, and mismatch. Pretty much the goal of these convenience methods is to empower the developer, reduce the boilerplate code, improve readability, and get the same amount of work done by typing less code. That's the idea behind this.

So the equals is more convenient-- by the way, the equals was introduced in Java SE 8. It's basically is a static method of the array class. And it returns a Boolean, which basically, in this case, is equals or false. That's what we have.

And with Java SE 8, that's basically additional code was required to isolate some sequences to be able to do that. So unfortunately, it was not possible to use the method to specify a range within an array to examine. So for example, if you wanted to do cut the subsequence, we could not do it with the equals that was introduced in Java SE 8.

So we waited until SE 9 and 10. And now we do have a very nice method. We overloaded the equals method. Let's go ahead and take a look at that in the API.

So in this here now, if you go scroll down and look at the equals, here it is. So now we have the equals that we had earlier in the SE 9. But then also now we do have, in this case, the equals, which is overloaded. That's what we have here.

So you see now the equals starts with the first array, and then from index in the first array, the two index in the first array, and then the second array, and then the from index in the second array, and the two index, in this case, in the second array. And that's basically what we have here. And now we can go ahead and use this.

And so we can go ahead, in this case, and use this. If I just, for example, now wanted to run this with the first index and the end index between for the first one and the second one, and if I run this, of course, I will get an output. So in this case, would be my output, in this case would be false because they're not the same, as you see here, 6 and 7, as an example, and so forth. So that's basically what they want us to use now. So this is very, very powerful.

And now, many array types, we can go ahead. And basically here, these are variants to handle all array types. And here's an example.

And where we can go ahead now and use the equals and maybe by creating a DNA comparator by implementing the comparator interface. And then, of course, this will pretty much allows us to, again, in this case, manipulate IDEs a type of arrays, and compare them any way we want.

And this would be in my second one here, where we can go ahead and create the instance of the DNA comparator, which is this one here. That implements the compare method. And then we can go ahead and see it in my test method.

And then I can go ahead and run this and then check. But the first one gives me false. The second one gives me true. But this time, I made the DNA comparator that implements the comparator interface, which basically overrides the compare method in the function interface called comparator, which we already know about.

Following that, so here's an example. Here's just a small quiz. Given the following code, we do have a strand, DNAStrand6 and DNAStrand7. So you want to use the equals and then, of course, here by passing the DNAStrand6 between 1 and 2, and then DNAStrand7 between 4 and 5 and do the comparison.

If you do that, you will see that this basically gives me a false between 1 and 2, so 0, 1, and 2. So that's in A. And then 4 and 5-- 0, 1, 2, 3, 4, and 5, C and D. And those, of course, give me false in this case. And that's basically what I have here.

You can, by the way, try this in the practice too-- rather, In the example in your test. You can go ahead and try this and see what they give you, in this case. You can try these just by changing the indexes and then try them, if you want.

So how about if you want to compare the difference between the two arrays? Here, what do we want to do is, in this case, we can identify if two DNA strands differ. Can we calculate the magnitude of the difference? That's what we're interested by.

It turns out that in SE 9 and 10, we a introduced to a very, very interesting method called compare, which is a convenience method to accommodate this. This, again, let us test this method with, again, this following strands. So they differ only slightly.

But you can take a look here, you will see that basically between DNAStrand1 and DNAStrand2, we do have T at location 1, 2, 3, 4-- 0, 1, 2, 3. Though T in the first one, and the second one has C. So you can actually try these.

And this will lead us to use a very nice method called compare. And this compare, by the way-- this compare is now part of the API. And so we have a compare.

And it's overloaded by the way. It could pass two arrays. Or it can pass through arrays with indexes, too. So the from and the to index for the first one and the second one. So you see. And let's go ahead and try these.

So you see, for example, you have the comparison between C and D, 17. And that's what we have here. So here we did the compare between DNAStrand1 and DNAStrand2. And if you take a look here, you will see that in the third location, the first one has T, and the second one has C.

So we're going to look now at the difference, in this case, between these two characters. And we use, in this case, looking at T and C, they are 17 characters away from each other lexicographically. So that's basically-- so from C to T, it's a plus 17. And from T to C, it's minus 17. That's basically what we have here. And you can try these, by the way, in the example.

And let's see this in number three. And then we do have the compare. And when we run this, pretty much it gives us, again, in this case, the difference, which is 17 or minus 17. It all depends which array you're passing first and which array you're passing next-- second. Row.

So, you can also, by the way, use the absolute value with the compareUnsigned. Again, do you not care about the sign of a number? Are you interested in comparing only absolute values? The Java SE 9 and 10 introduced the static compareUnsigned method. Again, this by the way, works with a limited number of types, like a byte, a short, an int, and long arrays.

Of course, we have a variant of the compare method. 17 may not be meaningful answer in DNA. So characters probably aren't the best way to present nucleotides.

So thankfully, the compare method is overloaded. It handles all array types, primitives and objects. Genetic variants let you especially by comparison criteria any way you want, and, of course, optionally specify a range of search if you want. So here's an example of where we do a random search.

Here we use the DNAStrand4. And we start from location 2 to 5, and then Strand5, location 2 to 5. You know how the array index starts with 0, so 0, 1, 2, 3. So in this case, 0, 1, 2, 3, 4, and thus 2 to 5, which means 0 to 4-- or rather, in this case, 0, 1, 2-- 2 to 4.

So what you see here, pretty much if you do the comparison, you can go ahead and basically also find out how these-- we can look at this down here. We can go ahead and try these any way you want to. You could go ahead and basically try this as an example. And they're random, and see what happen. So that's, again, the difference between-- and so forth-- when you take a range.

Sometimes, we want to only compare to the first mismatch. So what if many elements differ from the array? Again, this method does not return the cumulative difference between all elements. It only returns the difference between the first mismatch. In this case, looking at the first mismatch, and then find out what's the problem here between A and T. Turn out that it's minus 19.

And how do we do that? Basically by using the, in this case, as an example here, the compare. And it gives me the difference, in this case, between the T and A, which is minus 19, which we already run.

So here in a quiz, it says, given the following code, you have the DNAStrand6 and DNAStrand7. And we want to do a compare where we go from 1 to 2 for the DNAStrand6 and then 4 to 5 in the DNAStrand7. And if you take a look at this, you will see that the answer, in this case, would be a negative 2. That's C.

And you can also, by the way, run this in the example, in this example, where we have, in this case, 2 and 4. So we'll just end comment this, and then run it. And that will give us, in this case, the minus 2 that we were looking for.

Sometimes what we want to do is we want to pinpoint the mismatch between the two arrays. Thankfully, we do have now another method that allows us to do that. So in this case, one last return to the DNA scenario is we've been measured-- rather, we're measured the difference between DNA strands.

And can we pinpoint the location where the arrays differ? Again, this could be the site of a dangerous mutation, for example. So here, for example, we want to look at where they start. Here, they start in a different location, 3, if we start from 0-- 0, 1, 2, 3, T and C.

Now the Java SE 9 introduces the mismatch. Mismatch is a method that's actually all the way down here. Let's go to the [? end. ?] Here's the mismatch. And as you see, it's overloaded. You can even use it with the indexes.

And here's an example. So here you see that we can go ahead and use the mismatch. In this example, it returns 3, the third location. If you remember, it's starting from 0.

This indicates two strings in this case, and then the difference between, in this case, these. And we can see this in this example. That would be in number 4 where we, in this case, we use the mismatch. And then if you run this, you will see that it's basically they differ at location 3, T and C, between, in this case, the strands 4 and 5, as an example, which is, in this case Strand1 and 2, in this case, that we're using.

We also have another mismatch that actually takes an array and the from index to the to index in the second one. We can do that too. So that also can be used. Here's an example where we want to compare the DNA strand 4 and 5, and then one location 4 to 11, and 1 to 8, as an example. We can also see this in the practice.

And if you're on this, we should be able to get, in this case, a 6. And that's what it is, you see here, as an output. All these examples are in your lab machine in the Example folder.

Here's a small quiz. Given the following strands, and we have the mismatch between, again, for DNAStrand6 is between 1 and 6. And 4 7, DNAStrand7 would be 0 and 5. If we take a look at all of this, you will see that the solution, in this case, will be a 3.

And we can see this also in the code if we just end comment this and run it. And as you see here, it gives us 3. That's exactly what it is.

So definitely, these are very, very useful convenience methods and that we looked at. And they're part of the Arrays class. And they work very nicely.

And we've seen the equals. We've seen the compare. And we've seen the mismatch. And that's pretty much what they want us to see in this lesson.

So we do have some practices. Please try them-- the equals, the compare, the compareUnsigned, then the mismatch, which are very straightforward. Please try them before you look at their solution. Thank you.

## 2. Practice 13-1: equals() - 4m

Now that we are done with lecturing lesson 13, let's go ahead and take a look at these practices. We're going to start with the first practice 13-1, here we're going to see how equals method examines two arrays. Again, this is a static method of the arrays class. It returns a Boolean indicating the equality between two arrays. You will conduct your exploration by creating a simple int arrays, but the same principles apply to working with arrays of other data types or any type of objects.

So we can use JShell in NetBeans. It happens that I'm using Net Beans here pretty much the same, and we'll go ahead, and in this case, create an array. So we have array one that contains this and then array two and then array three and then array four. Array four, as you see here, it has an extra element, and then we'll go ahead and use the equals in this case. We just wanted to find out about the equals method and see the comparison between all of them.

If we take a look at all of them here, you will see that here we're comparing array one to array two. Most probably this will be true, and then array one to array three will be the same thing. They're the same. Array one to array four will be different, so we'll go ahead in this case and run this. And that's what we get as an output. So in part 1, so the first one is true. Second one in this case is false, because this has 300, so that's not good. And then the third one is also false.

And then now we'll go ahead and try the equals with from zero to two for the array one, and then for array four from zero, in this case, to two. This should again, it gives me a true, and then after that, the last one, zero to two, array one and array two, that of course, zero to three, that of course, in this case, will give me a false. One thing that we want to talk about here is that what if we test beyond the bounds of an array? That would be good. So we should be able to get an error message that array index out of bound exception.

Let's go ahead and try that. This will try it if I just end comment this. And now we're trying the index 0 to 10, which is out of bound. Let's go in and see if that actually works, and then once we run this, you will see that we end up having an array out of bound exception. So that actually works in this case. That's pretty much what they want us to do in this practice.

By the way, you can try this in JShell or you can just go out and try it in NetBeans, pretty much the concept is exactly the same. JShell is just so that you can try the JShell and play with it. But you still can play with it and the IDE. Just the purpose here is really to find out how the equals a method works.

## 3. Practice 13-2: compare() - 3m

Let's take a look now at practice 13-2. Again, you can go ahead and, in this case, you can use JShell to see how the compare method, or you can use net means, pretty much the same. So this historic method of the Arrays class returns an int, that is the measurement of how different the two arrays are. You will continue experimenting with the in Array, but the same principle applies to working with other types if you want.

So here, we have a bunch of arrays. And we're going to use the compare method. Basically, that's what we're doing here. So pretty much, here we have, in this case, we created a bunch of arrays, array 1, 2, 3, pretty much the ones that we had before. And here, we do the compare.

The compare method here compares array 1 to array 2. So again, that's exactly the same, because they're exactly the same. And then, now, we'll do array 1 to array 3. And again, in that case, array 1 to array 3, the difference is between this. And as you see here, and this one in this case would be minus 1. And the same thing with array 1 to array 4, that's one, the difference. And that's basically what we have.

And then, you'll try and also with the index in the last ones too, between 0 and 2 and 0 and 2 for array 1 and array 2. And then, that 0. And then, the last one, which is between 0 2 and 0 3. And then, the difference is minus 1. Cause that's basically what they want us to do in this practice is pretty much, in this case, rather than returning the mathematical difference between two integers, the values 0 1 and of minus 1 are used to indicate the quality of which array contain the bigger elements, flipping the order affects the sign of the result.

If there are any additional meaning behind that results 1 or minus 1, just to be, again, thorough, let's, again, first see if the [? magnitude ?] of these results is consistent across the other scenarios. That's basically what we have done here. And if we take a look, pretty much, it works nicely. And we saw it here. And that's basically what we have here as a result. That's what they want us to do in this practice.

## 4. Practice 13-3: compareUnsigned() - 3m

Let's take a look now at a practice 13-3. Here we're going to use the compareUnsigned. You will, again, use JShell or NetBeans and look at how the compareUnsigned method can be used to examine two arrays and determine what is meant by unsigned. Again, this is a static method of the arrays class. It returns an int that is a measurement of how different the two arrays are. If you're ever confused about the values in an array, you can see a full list of its elements by typing the array's name in JShell or in NetBeans if you want. This practice, again, continues where the previous practice stopped.

And here pretty much we create some arrays, and then we'll go ahead, in this case, and then use the compareUnsigned. We'll also create here arrays of characters and then of course we'll go ahead and use the compare. That's what they want us to do in this case.

And so, again, in this case, just showing you this, so here is a compareUnsigned for integer. Remember where we said the compares are used for byte short int and long integer, if you remember. So that's why the compareUnsigned [INAUDIBLE]. And so here we have these arrays, and we go ahead and compare them. We use compareUnsigned-- array 1, array 3, and so forth. So in this case, change the value, minus 300 for the values of the third element of the array 3, and same thing 250, and so forth.

And then in the second one, we use two arrays of characters, then we use the compare. So we right-click and run this, and pretty much that's what we get. In the first one, you get either, in this case, the values, for example, between array 3 and array 1, and so forth. That's where we have the difference. And then in the last three ones, they're related to comparing the characters, in this case, between A and C, and B and D, and so forth. That's the idea behind this.

And then we changed it to Z, and that's why the comparison here is 24 minus 24, because the second element, in this case, of array 2 now, it's not D anymore. It's Z. And then we do the comparison. That's pretty much what they want us to do in this practice. Again, you can try it on JShell or NetBeans. Pretty much the concept is really the same.

## 5. Practice 13-4: mismatch() - 3m

Let's take a look now at a practice 13-4. Here, the JShell, I'm using NetBeans, pretty much exactly the same. So here we are going to use the mismatch method that can be used to pinpoint where an inequality first occurs between two arrays. The static method of the array class, it returns an int indicating the index that mismatches. You'll continue experimenting with simple int arrays here, but the same principle applies of working with arrays of other times. And that's basically what we have here, and then we use the mismatch. That's basically what we are doing in this particular practice. Let's show you that.

So here we have the arrays, pretty much the ones that we have, array 1, 2, 3, and 4. And here we do the mismatch. Again, mismatch here between array 1, index 0, 5, and in this case, between 1 and 4. You run that. That's basically minus 1 here, so that's what we have here. The mismatches down here, and then looking at the second one, array 1 and array 4, and between 0 and 5 and 0 and 6, so you see that the mismatch here would be in position 5. Makes sense.

0, 1, 2, 3, 4, 5. That's basically the difference. And then we do the same thing with the next want, array 4 and array 1, and that's still in 0, 5, And then we apply, we assign, a value 50 to number array of 4, and then in this case, the third element, and then the fourth to 50. And then we do the comparison first. So with this one here, we get 2, and then the second one we get 2, because this would be the mismatch, which telling us exactly that. This will be [INAUDIBLE] can be used to pinpoint where an inequality first happens or occurs between the two arrays, and that's what they want us to do in this practice.

## 6. Skill Check: Convenience Methods for Arrays - Score 80% or higher to pass

Skill Check: Convenience Methods for Arrays

View Skill Check
