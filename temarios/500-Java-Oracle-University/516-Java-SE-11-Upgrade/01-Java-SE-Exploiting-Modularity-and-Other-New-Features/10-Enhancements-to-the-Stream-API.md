# 10: Enhancements to the Stream API

1. Enhancements to the Stream API - 30m
2. Practice 10-1: takeWhile() - 8m
3. Practice 10-2: dropWhile() - 3m
4. Practice 10-3: iterate() - 5m
5. Practice 10-4: Converting an Optional to a Stream - 2m
6. Practice 10-5: or() - 4m
7. Practice 10-6: ifPresentOrElse() - 2m
8. Skill Check: Enhancements to the Stream API - Score 80% or higher to pass

## 1. Enhancements to the Stream API - 30m

Let's go ahead now and take a look at enhancements to the stream API. These are just some methods that we added to the streaming in Java SE 9 and 10, which are quite useful. This would be in Lesson 10.

So here, we can identify when to use dropWhile and takeWhile and iterate on streams, convert an option into a stream, and explain how a new Optional method or an ifPresentOrElse affect your ability to create a stream. So pretty much looking at evolving libraries, we know that one of the more benefit, if you want, of default methods is that many methods of the stream interface are default methods. And this includes new stream methods which have been added in the SE 9 and 10.

OK, so here are the ones that we are going to look takeWhile. takeWhile is a method that was added-- if you take a look here at my API, if I look at the stream interface in SE 8, and then I look here at the methods, you will see that there is no takeWhile and dropWhile. It just does not exist. So what we did is we added these two into the SE 9 and 10. So if we take a look here, you would see that we do have, in this case, a method-- dropWhile. Here it is. And then, of course, a takeWhile, which is somewhere in here. So that's what it is.

And we tell you in this case that the takeWhile returns-- if this stream is ordered, the stream consisting of the longest prefix of elements taken from the stream that matched the given predicate. As you see here, takeWhile takes a predicate. And then the dropWhile returns if this stream is ordered, the stream consisting of the remaining elements of this stream after dropping the longest prefix of the elements that match a given predicate.

And then, we also added one, which is the iterate. And if you take a look here at the iterate, which is, in this case, Hades. So we did overload the iterate method. And so that's basically what we have here, compared to the SE 8 that we have. We take a look at the SE 8 here-- methods-- and you can see all the methods that basically we have here. And we have this iterate here that takes a seed unary operator. As you see here, there is only one here. In SE 9 and 10, we did overload this now. That takes a seed, the predicate, and then, of course, unary operator. That's how we change the-- or if you want overload the P predicate. In this case, a method. And that's basically what we see here. And that's what we see here.

So in return, the sequential, a ordered stream produced by iterate application of the given next to have function to an initial element conditioned on satisfying the given has next predicate. That's what you see here. All right, so one small quiz here-- when you add a new abstract method to an interface, what happens to all the classes that implement that interface? Of course, in this case, the developer must provide method implementation for each class that implements the interface. That's basically what it is. That's C.

And now, changing a Java interface. Let's say your program relies on a particular library or interface. What happens if Oracle updates the interface? Well, adding a new abstract method breaks any code that implements the interface, obviously. This would upset developers. It's a bad idea. So adding a new default method, on the other hand, provides a very good solution. Default methods won't break any code that implements the interface, and they provide a common location for implementation. And this is good way to involve the libraries. That's basically what we want to do.

Now, let's take a look at new methods in the stream API interface. So to have developers, of course, recognize common use cases, and recognize common cause errors, and recognize situations that require lots of code, recognize situations that require boilerplate code, and recognize functionality developers wish they could in this case perform. So developers develop the API based on those observations. And if so, increase the convenience and readability of your writing code, and then offer more robust, powerful, precise methods. And that's basically what we have done in our case here.

So to understand this, a new takeWhile, dropWhile, and iterate, let's go ahead and look at examples. That's what we're going to do. So here's an example where, in this case, we have a financial product savings account. Contains balance and interest rate and fields, and we create a stream from a collection of savings accounts. So here I have an array list of saving accounts, and then I add to it and use the sub saving account that contains, in this case, a balance of $100, $200, $300, $400, and $500.

If you take a look here, you will see that this is an ordered list. That's what we have here. And then we'll use the stream method to convert that list into a stream. That's basically what we are doing here. So now, the stream is increased in the creator from an ordered list. That's what we have. And of course, accounts with balance less than $200 are subject to fee. So the financial institutions must identify all these accounts so that they can go ahead with that-- below minimum balance so that they can basically charge them a fee.

Because the list is ordered, we only need to identify the first element above the minimal balance. So this will again be our cutoff point. And of course, all elements afterwards won't match the minimum balance criteria. That's typically how we do it. So one way to do that is to use the takeWhile. takeWhile requires a predicate argument, in this case. So we should represent here where for every in this case account get the balance if it's less than $200, then basically return those. For every one, go ahead and charge them a fee.

So here, in terms of new stream called a prefix, which is based on the origin stream, starts at the beginning of the origin stream. And if the next element passes the predicate, it's included in the prefix. If the next element fails, omit that from the elements, and so forth. So the takeWhile method would be a short circuiting type of a method. So that works.

All right. So of course, here, calling the takeWhile on the Account List produces, in this case, the list of 100 and 200. That's basically what we have. How is this different from filtering? Pretty much similar. In this case, because it's ordered-- similar. That's basically it. And if you take a look here, you will see that we do have this as an example. And then we use a takeWhile, and taking on charge of this. So if I run this, then of course I get the output, which is 100 and 200. That makes sense. OK, this is just an example that we have here on your lab machines. You can try this.

And now, of course, how about if we have an ordered list? Here's an example where we added-- we have in this case 100, 300, 400, 500, and then 200. So this is unordered. And the question here is, if we now use the filter, then of course it's going to go ahead and get me the 100 then 200. But if I use the takeWhile, it's going to get me only 100. It's going to forget about the 200. So the filter operation has no short circuit mechanism and returns all elements which pass its predicate.

On the other hand, the takeWhile is a short circuit type of operation. When it encounters the first element which fails in its predicate criteria, then, of course, in that case, it will go ahead and stop. So that's why all that matters when it comes to takeWhile. So here it just returns, in our case here, 100, and that's that we get.

So obviously, we can go ahead and look at this in an example. This would be the second example, which is this one here. So you see, and then, of course, it's unordered. In this case, I wanted all the accounts less than 700. If I right click on this and run it, I get 100 and 200. But I don't get the 400, 500, because the cutoff here would be right over there.

So the question is, why do we use this? That would be the question. Well, here's a very good example where, in this case, we can see-- so the question here is, why should we use a takeWhile? Why do we call it takeWhile? Well, here's an example, where in this case, just as a very nice experiment, where we have a scenario which is a scientific experiment. You're continuously gathering experimental data. The number of data points could be infinite. You can't create an infinite list to look over. You can work with an infinite, in this case, stream.

An event happens which contaminates the future results. So let's assume here that all the data to the left of this peak, they're all good data, but then after that, data is contaminated. If you use the filter, it will return a mix of good and bad contamination data and fully contaminated data. And that's a bad idea. On the other hand, a takeWhile in your analysis will allow you to isolate the good data from the bad data, and that's exactly what we're looking for. So the takeWhile has that threshold. Once you meet that threshold-- this is a short circuit type of a method-- once you hit that threshold, that's it. Then it will stop, in this case, and that's exactly what we're looking for.

Now going back to the data that we have-- so getting back to the stream of our banking scenario-- now, accounts with balances equal to or above 250 earn a bonus. Because the list is ordered, we only need to identify the first element above the minimum balance. And then, of course, earlier accounts without the required minimum balance are ignored. Later accounts earn the bonus.

So to actually do that in this time, what we can do is we can use the dropWhile. So dropWhile requires a predicate argument. Again, we already have seen this in the API where we have the dropWhile-- here it is-- and it takes predicate-- that's exactly what occurred-- and returns a stream, as you see here.

So again, we should note that this is the same predicate as the takeWhile example. So the operation returns a new stream based on the original data, starts at the beginning of the original stream. The next element passes the predicate criteria omitted from the result, and if the next element fails the criteria, return a stream containing, in this case, that element and all the elements afterwards. And that's basically here, where we say it's less than 200, so you get 300, 400, 500, in this case. And then we give them a bonus, in this case.

So calling the dropWhile on the Account List produces a stream consisting of the last three elements, in case, 300, 400, and 500. So the first element to fail would be the 300. We include that and all the elements that come afterwards. So coincidentally, we know we've isolated all the accounts with the required minimum balance because the stream is ordered.

But how about if the stream is unordered? That also can work too. So in our case, here is an example where there are intermediate stream operations. So here, we can say the dropWhile-- the takeWhile and dropWhile. So for example, for the takeWhile returns-- in this case, 100, 300, because we want the account with a balance that's not 350. And then for the dropWhile, we want to balance that's less than 250, in this case, it becomes 300, as an example.

So we should also be aware, when we are on this in parallel for parallel streams, it will not return always the same result. The resulting stream may not be in an order you expect, so be careful with that when you run it in parallel. That's what we call nondeterministic operation. And the short cut or the short circuit type of operations are nondeterministic, like the findAny, findFirst, and so forth. The takeWhile and dropWhile pretty much are similar because they are short circuit matters.

So another thing that we want to discuss here is that, is there an alternative to generating this stream manually? So the previous stream relied on a collection where one line of code was required for every element in the collection. So here we have a collection. One solution is to use the stream iterates method, which by the way, we know it exists in in SE 8. So we have the iterate. That takes a seed unary operator and returns an affinity, which all the stream produced by iterative application of the function F and then initial element seed, producing a stream consisting of a seed. In this case, a seed, F seed, then the F to F seed, and so forth.

So we can go ahead and use that. Use the iterate, so use the iterate-- takes a new instance of an account, that's the seed, and then of course, in this case, the new instance of saving an account with a balance 100, and then we limit that to five. So the unary operator describes the element created in the next iteration, which in this case, getting a new instance of an account adding $100 to the balance, and we need to limit that to five of them. So we need to know how many elements you want ahead of time. Here, we have limit five.

What we have done in this case is we did overload the iterate method in SE 9 and 10, and that's what we see here. So in SE 9 and 10, now we have the iterate method that is overloaded, and here it is. So it takes a seed predicate that tells you about how's next and, of course, the unary operator. This returns a sequential order stream produced by iterative application of the given next function to an initial element condition on satisfying the given as next predicate. And that's what we see here.

So here, what if you don't know how many elements you will need to limit the stream to? And then what if values should be created at random increments. And then with Java SE 9 and 10, you only need to specify some limiting condition, and this is done through the new predicate-- a argument that we added. Here is an example-- where the stream iterated, he takes an instance, that's the seed, uses of the seven account in 100, and now we added the predicate. We said, as long as the balance is less than or equal to 500, go ahead and create accounts by adding 100 using the unary operator.

OK. So this reminds us of something that we've seen before in Java. It kind of looks like a full loop. So that's why we said there is similarities with a full loop. So the first argument is the starting condition, the second one describes the criteria required to continue the looping, and then, of course, the third argument describes what happens after every operation. And if you take a look here, pretty much similar to int i equals 0, i less than or equal to 500, and i plus 100. So that's basically what-- except that this is applied to streams.

And here's a small quiz. Again, a stream is created from a collection called the example collection. The collection contains integer objects. The objects exist in the following order-- 100, 200, 700, 400, and 300. What is the resulting stream after calling the following code? So we convert the example collection to a stream. takeWhile i-- well, i is less than 700, and for each, go ahead and print i. So if you take a look at all of this, you would see that the one that actually, in this case, because it's takeWhile, is going to return the first one, which is a-- 100, 200.

Now, one more thing that we added to the streams is we know that some of the short circuit methods actually return an Optional. So some of the methods of the stream API like findAny and findFirst return an object of type Optional. And Optional, in this case, is a class. And what we did-- we know that exists in SE 8, except that in SE 9 and 10, we added more methods to it. And we're going to go ahead and take a look at this in a minute.

So Optional is a protective container that guard against a stream returning a null value, the object you want not existing. And, of course, but there were drawbacks when a method returns an optional. If a stream returns null, you lose access to terminal stream operations, unfortunately. Some APIs require stream arguments and not Optional. So what we have done-- we've fixed this problem by doing what? By now, when we apply, in this case, a short circuit matter like findAny, now we can apply the dot stream method on it. This will go from converting that Optional into a stream. That's again, the biggest advantage, which means it allows us to invoke more of the stream methods on it. So after you do this, of course, you may continue calling methods from the stream interface, and that's a huge plus.

All right, so the Optional method in the SavingsAccount. So we'll demonstrate, again, more Optionals in this case. Here's an example where you can see here-- we can go ahead and use the findFirst in the example that we already have seen in this case to look at-- if you take a look here, here's the example. And we can go ahead in this case and see example of a findFirst. For each balance is present, and so on and so forth. So we can always create one in here that basically allows you to, in this case-- you can change that, then you can put down findFirst, as an example in this case.

And then a computing-- findAny, for example. I can go out and take this one here. OK. And then, of course, convert that into a stream, and then get the balance done and run it. So if I run this, then in this case, I can go ahead and get the value. So we just basically use in this case the findFirst or any of the methods on the screen.

So also, the or method. So what if the object you're looking for does not exist in the stream? Now, you can specify alternatives. You can go ahead and append the or method to the Optional class to specify alternative criteria. This method requires a supplier, a type lambda expression, and return an Optional. So you can chain the or method, in this case, together. The first or statement allows you to find the object. So here, for example, find the account with balance 60. Or go ahead, in this case, and find the account with the balance 500. Or if it's not there, go ahead and find the account with balance of 400 instead of 500, and so forth.

So here, we can go ahead and chain the or statements together, and this way, we can go ahead and try to find out-- call the fine balance, and try to find if the account in this case has a balance 600. If not, we go ahead and try to find the account with balance 500. If not, we can go ahead and find the account with balance 400. And then, of course, after that, we go ahead and convert that to a stream. So the resulting would be an option of which we convert into a stream because in Java SE 9 and 10, we can take an option and convert it into, in this case, a stream.

Another set of methods that we can use in Java SE 8 is basically the ifPresent and orElse. You explicitly state what should happen if the object you're looking for is found. So this is done again using the ifPresent. So here's an example where fine, in this case called the fine balance, and past the account list and 600, try to find, in this case, the account in this case with balance $600. And we can use the ifPresent. If present, go ahead and get this balance.

We can also use the orElse. Here, explicitly state what should happen if the object you're looking for is not found. So this is done with the orElse method of the Optional class. Well here, for example, go ahead and find the account with balance 600, or else go ahead and create an account with balance 600. So you see that ifPresent allows you to present. If it's not there, go ahead and create it and add it to the list.

Now what we have done in Java SE 9-- again, all of this are part of the API. You can take all of this-- the API is your friend, in this case. So here, looking at a ifPresent in this case orElse that we added in this case in Java SE 9 and 10.

So here's an example where now, you can actually do both in a single line of code. So you use ifPresentOrElse. So here, for example, we can go ahead and call to find a balance to try to find the account with $600 as a balance. ifPresentOrElse-- look what it does. This, actually, in the API-- you take a look here-- it takes a consumer and a runnable. So if a value is present, perform the given action with a value. Otherwise, perform the given empty-based action. Let's going ahead and take a look at that.

So here we say, ifPresent, go ahead and get the balance and print it. That's a consumer. Else, look what we do. , Else we use are runnable. We just add a new instance of savings, a account with a balance 600. This is a terminal method. It can't be changed like the or method, and it can't be converted into a stream. So remember that. But this is something that you can also use.

And of course, one quiz here. What does the or method of an Optional class return? If we take a look at all this, It says that it turns what? An Optional. We know about that. We've seen that before. That was in the or method that we have here, which we said the resulting Optional can be converted to a stream.

So in summary, the new stream interface methods were added, which is to takeWhile, the dropWhile, and the iterate. The iterate was overloaded. In this case, in the SE 9, that takes a seed predicate and the unary operator We also now added the stream method to convert an Optional into a stream. We also, again, in this case, have the or that basically takes, in this case, a supplier that extends an Optional. So if a value is present, the returns an Optional describing the value. Otherwise, return an Optional produced by the supply function.

And then we have the ifPresentOrElse. If a value is present, performs a given action with the value. Otherwise, perform the given empty-based action. And we've seen this. So this pretty much takes a consumer and a runnable. And we've seen the example about that right here. You also may find it helpful to consult this list when you do, again, in this case, this lesson's practices. These are basically function interfaces that we know, and they're part of SE 8 also. A consumer and a function and a predicate, a runnable, a supplier, a unary operator, and so forth. And by the way, we can find all of these in the function interfaces, and they're the API.

And that's basically what we have done in this particular lesson. We looked at the dropWhile, takeWhile, iterate, converting an Optional into a stream, and then using the methods or and ifPresentOrElse, methods that now can be used for the Optional. We do have a few a practices. One covers the takeWhile and one the dropWhile, iterate, and converting an Optional into a stream, and the or and ifPresentOrElse. So try these practices before you look at the solutions. Thank you.

## 2. Practice 10-1: takeWhile() - 8m

Now that we're done with lesson 10, let's go ahead and take a look at these practices. We're going to start with practice 10-1. Here, we're going to use the takeWhile.

In this practice, you will create a SpecialBond class and explore how the takeWhile method can be applied to a stream of a SpecialBond object. As you explore, you will gain insight into best practices for applying the takeWhile method to a sequential parallel ordered and unordered Streams. So you will, again, model the software for a financial institution.

This institution has a brilliant idea. They believe it's important to build a special bond with customers, and to that end, have decided to create a new financial product called a SpecialBond. It will function just like a regular savings bond, but will be treated in a special way, which you'll program in a later part of the practice. For now, the SpecialBond class simply provide you with an object type to explore the Stream API.

So, in this case, we go ahead and open, in this case, create a new project, and have the main module, and create a package Stream API, create a Main, in this case, class named TestClass, create a new Java class called SpecialBond. And this is pretty much what we have here. And then we have a TestClass, In this case, it has a balance, interest, and so forth, getBalance, getInterestRate, and earnInterest, and so forth. That's pretty much what they want us to if you follow step-by-step what they want us to do.

And then inside the special-- inside the Main class, we'll go ahead and create a list, a bond list, and then of course, add instances of the SpecialBond. And then we use the takeWhile. That's basically what we're doing in this case.

And that's, in this case, what we have. And by the way, you can also, in this case, cut this for now. And that's what we have here, of course.

And then after that, we run it. And that, of course, in this case, it says return anything that is greater than 500. And that, of course, in this case, would return 500, 600, in this case, 800, and 900.

Basically, it does not return, in this case, the ones that are-- in this case, once it reaches the 400, which is basically, in this case, less than 500, it will cut those. And that's what you get in this case. And of course, that's what they want us to do.

And then, after that, again, we should say that these are two important observations to make, that the first observation provides insight into how this method works. The takeWhile returns a Stream known as a "prefix." But this contains all the elements from the stream until one is spotted that does not pass the Predicate criteria. When this occurs, the method short circuits. And secondly, you'll notice that the printed order of the element is consistent each time you run the program.

So you can run it again, pretty much the same exact one. Run it again. And you get the same thing. That's consistent.

And now what we could do is, how about if now explore this a little bit. So how about if now we run this in parallel. One way, again, to do this by adding the parallel, running the main method a few times, and observe if the output is consistent. Let's go ahead and do that. So we can do .parallel.

And then, of course, in this case, we can go ahead and run this. And you see that when we run this, you see that sometimes the outcome changes. And why? Because it's a short circuit method, and it's non-deterministic. It all depends which thread picks up the first value.

Now it's 900 first, and then 80s, 900, again, 900 again, and so forth. So I can go ahead run this from there, and run it again, 900 again, 900 again, 600 this time, and so forth. So as you see, it's non-deterministic.

Now what I could do in this case, is I can also add unorder it, the method unorder. So just in addition to running it in parallel, now one way to do this is by adding the unorder to the beginning of the stream so that you will create, in this case, unordered stream. So let's go ahead and do that.

See? And now, we can run this again now. And it all depends, in this case, what's going to happen because it's unordered.

So again run the main method a few times and observe that if the output is what happens if an element with a balance less than 500 is earlier or late in the stream, again we know not only in the order of elements and-- not only the order of elements isn't consistent, but the actually number of elements varies each time you run the program. Remember that this method, it short circuits as soon as it detects a value, which again, does not pass the Predicate. So if values are unordered, it's possible that the first element encountered will not pass the Predicate. In this practice, again, this will result in an empty stream. And that's exactly what happened.

So if you run this, sometimes you have an empty stream. So you have to keep-- see, now it's [INAUDIBLE]. And now it's 600. Now it's all empty, empty, empty, empty, empty, empty. We've seen once only 600.

So sometimes it shows you an empty stream, which means it picked up [INAUDIBLE] pass by 400 and 300, which are not less than 500, and never say anything, see anything again. That's basically why-- and sometimes you get-- we get only one output of 600 once. And that's what we got here. And that's pretty much what they want us to do in this practice.

## 3. Practice 10-2: dropWhile() - 3m

Let's go ahead now and take a look at the dropWhile. In here, we'll explore how the dropWhile method can be applied to a stream of a special bond object. And as you explore, you will gain insight into how this method differs from the takeWhile, and best practice for applying this method to a sequential pattern ordered or unordered. OK?

So in this case, we are going to, in this case, continue with your, in this case, solution that you have, except that instead of using the takeWhile, we're going to use the dropWhile. That's basically, we're going to replace that. OK?

And then we're going to run it. And then we'll see, basically, it pretty much will be the same thing. Where in this case, we can go ahead, in this case, and just as an example, let me go ahead and get these and see what happens.

So if I run this, then, again, as you see here, it cuts at the cutoff. And then gets to me only what's in the cutoff, in this case, greater than, in this case. The minute we hit where we have 100 is not less than 500. That's what we get. We got the rest of the information.

Now, what we could do is we can go ahead and add to it here. Just let me go ahead and cut this. And then end up with only, in this case, a parallel. And go ahead and run it, in this case.

And then, of course, as you see here, because it's running in parallel, the output might be different. See, now 300, 700, 400. Then it changes sometimes. OK? It all depends. OK?

And then in addition, if I want to add now, the unordered, then we might end up having the same problem like the take off. So see, now I have 400, 300. Run it again, 300, 400, 400, 300, 300, 400, and [INAUDIBLE]. OK? That's basically what happened here. So it changes. OK?

And so again, as you see here, except that the take off takes at the cut off and then what comes after, not before. And that's what they want us to do in this practice.

## 4. Practice 10-3: iterate() - 5m

Let's take a look now at practice 10-3. In this practice, we are going to generate a Stream of random SpecialBond object. This simulates their real life simulation financial institutions face. They must deal with an indeterminately large collection of accounts where balance is widely varied. So as you work, you will examine the helpful refinement made to the iterate method of the Stream API.

So here, we go ahead and create, in this case, a project. Except that this time, we'll use the iterate method created, in this case, in SE 8. And that's what we are going to do in this case.

So here's my-- basically, here's the SpecialBond. And this is the TestClass. And as you see here, basically we have, in this case-- by the way, we can go ahead and use, in this case, the iterate that we we're using here. And we wanted to use the iterate of the SE 8, but then we enhance it. And that's basically what we want to do.

So here is SpecialBond. And then B, and use SpecialBond, in this case, were created using a random number. For each one, we'll go ahead and print that balance. That's what we did here in this case.

And of course, let's say, again, you need all the special bonds to have a balance less than, in this case, $500. So run, in this case, the program to observe that. That's what they want us, in this case, to do in this particular, in this case, lesson. So we'll go ahead and try that.

And this time, we'll change a little bit the code when, in this case, we wanted the balance to be, in this case, less than $500. So that's what we have here. And then, of course, we run it. And that's what we get here as an example And, of course, that's pretty much following what-- and then, of course, the code that you see here pretty much looks like this.

So if we run the stream containing negative numbers, so in this case, we can go ahead and add also and get the balance greater than zero if we want. And then we can also add the limit to be 5. And this will lead us to this, in this case, code that we see here.

It's read, and then limit 5, and then filter that, pretty much similar to what they asked us to do here. And then, of course, we'll go ahead and run that. And if we run it, that's what we get, [INAUDIBLE]. This is the output of the first, in this case.

And then, of course, as you see here, pretty much looking on the rest of the code, iterate, that actually allows us, in this case, to pretty much a use the iterate in SE 9, which is this one here. And let me just show you that. And that's basically what they want us to use.

So in this case, add a Predicate as the second argument to be iterate. This predicate checks to see whether the balance is less than $500. Remove the limit, and remove any filter. And that's exactly what we have here.

And this is pretty much what they want us to do here. So you see, that's what it is. Which means we can go ahead, in this case and comment this.

And then, of course, work with this. That's exactly what they want us to do. And then, of course, we know when to run it, that's the output that we get. And that's pretty much what they want us to do in this practice.

## 5. Practice 10-4: Converting an Optional to a Stream - 2m

Let's go ahead now and take a look at practice 10-4. Here, we're going to convert an Optional to a Stream. So in this practice, you will see how an Optional can be converted to a Stream. OK?

And this is pretty much a very, very interesting type of a practice. And let's take a look at how we work with this. So in this case, we basically create a Bond List. And then so once we get that Bond List in this case we go ahead and filter of the data. And then FIND FIRST. FIND FIRST always returns an Optional.

And then we can use the Stream so we can go ahead and apply the FOR EACH method, because it's always applied on the Stream. So that's basically the advantage that we have here. Because we know that the FIND FIRST always returns an optional. You know?

And we had to add this Stream method in DSC 9 and 10 so that that option is converted to a Stream so we can apply, in this case, for FOR EACH method. Otherwise, we wouldn't able to do that. OK?

And we can go ahead and run this. And that's basically what we get as an output, in this case. OK? And that's just showing you how pretty much, in this case, the Stream method can be used to convert an Optional into a Stream. That's pretty much what this practice basically, in this case, goes through. This is pretty much.

First of all, they want us to code this so we can go ahead and get the balance list [INAUDIBLE]. Get that balance. And then P, print all that information. And of course, put that into a list, one list. That's pretty much the code that we have here.

Once we get that Bond List, convert it to a Stream. Filter the data. And find the first. And then a get an optional convert into a Stream, and then apply the FOR EACH. That's pretty much what they want us to do in this practice, as you see.

## 6. Practice 10-5: or() - 4m

Let's take a look now at practice 10.5. In this practice, we'll chain an optional statement together using the or method. In the event that a particular object does not exist in a stream, the or method from the optional class allows you to chain optional statements together and provide alternate criteria to find an alternative object. When you're done chaining, you can convert the result into a stream. So the financial institution you've been modeling software for does not like the idea of not having a lucky winner. They insist that if no special bond balance ends in a 0, you should try 5 or 2 instead. To do this, you will need to copy the filtering logic from the previous practice into an optional method in the SpecialBond class. Then, you can chain the optional statements together using the or method.

So here, what we've done is basically, in this case, we now went into the SpecialBond, and we created a method called findLuckySpecialBond that takes a list and an integer. And then, we take that list and [? convert it ?] to stream and then filter in this case. So get the balance in this case and, of course, then get the balance if it's different then 0 and then find the first one. So this is a code that basically tell you to write utility method to contain a logic you just copied. So the goal of this method is to locate the first bond from the list whose balance ends in a particular digit.

And basically, this method that we've seen here is the remainder here, equal to i, and then get balance should be different then 0. And then, this returns an optional, in this case. That's what it does. And that's what they want us to do. So basically here, we convert the list into a stream, filter the lists to find accounts with a balance ending in i but not equal to 0. That's basically what it is, and that's what you see. And then after that, we'll go back to-- so this is again what we get. And then after that, we go back to our main class, which is really the main method class. This is the test class.

And so now, first of all, we'll go ahead and call, in this case, the iterate method to get the list in this case. Pretty much similar to what [INAUDIBLE], convert that into a list bond. And then here, we call the find lucky. And then, pass the bond, less than 0. And then, of course, if we don't find, then we say or go ahead and find the one exactly what they told us here, if you remember.

They told us to find the lucky bond, if there is a special bond with the balance and then with 0, 5, or 2. And that's exactly what we have-- 0, 5, or 2. And then once we get that, we know that this returns an optional. We convert that into a stream and then would print, in this case, the winner. We can go ahead and run this, and that's basically what we have here. So the winner is 185, in this case, as an example. And that's pretty much what they want us to do in this practice.

## 7. Practice 10-6: ifPresentOrElse() - 2m

Let's take a look now at practice 10-6. In this practice, you will get experience with using the Optional and the IF PRESENT OR ELSE. This method allows you to choose a course of action, depending on whether an object is found or not.

However, statements can be changed. Like all statements, this IF PRESENT OR ELSE cannot be changed like the OR statements. And the result can be converted into a stream, just so that you know.

So pretty much here, we comment out the block of code where you change the optional, in this case, all of that. We'll go ahead and do that. That's basically we commented all of this. OK?

And then, of course, we use the FIND LUCKY SPECIAL BOND method. And then we look for with a balance ending with seven. OK? And then we call that. We parse in the argument Bond Zero. And of course, call the IF PRESENT, in this case, on the resulting optional.

For the first argument of this message, print the balance of the winning special bond, this code will execute if the special bond is found. For the second, the message no winner found. OK? That's basically what we want to do in this case. OK?

And so this will end up having some code similar to this. OK? Call it 07. And then if present, we'll go ahead and print that. Otherwise, we'll print this. And that's exactly what we have here. That's exactly what we have.

And that's what they want it to do. And of course, we go ahead and run it. And you see here, no winner found. Let's run it again. Now we have a winner, which is 137. OK? Just an example.

And this is pretty much what they want us to do in this practice.

## 8. Skill Check: Enhancements to the Stream API - Score 80% or higher to pass

Skill Check: Enhancements to the Stream API

View Skill Check

