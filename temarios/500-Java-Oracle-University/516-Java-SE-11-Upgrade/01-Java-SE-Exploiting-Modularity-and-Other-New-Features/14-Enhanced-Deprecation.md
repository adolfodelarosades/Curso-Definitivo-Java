# 14: Enhanced Deprecation

1. Enhanced Deprecation - 14m
2. Practice 14-1: Performing Static Analysis Using jdeprscan - 4m
3. Skill Check: Enhanced Deprecation - Score 80% or higher to pass

## 1. Enhanced Deprecation - 14m

Let's go ahead now and take a look at enhanced deprecation in Lesson 14. Here we're going to describe the concept of deprecation, explain depracation enhancement in JDK 9, describe deprecation notification and warnings, and, of course, perform static code analysis using the jdeprscan command.

So talking about the concept of deprecation. Deprecation is a way to provide information about the life cycle of the API, of course, a notification to developers that they should somehow migrate their code away from the deprecated API. Possible reasons for deprecation would be there's something wrong with the deprecated API, there is a newer, better API that can be used instead, and the deprecated APIs is going to be removed.

So JDK 9 clarifies the semantics of what deprecation means, including whether an API may be removed in the near future. Again, in the prior releases, API were deprecated but virtually never removed. Starting JDK 9, APIs may be marked as deprecated for removal. This basically means what? It indicates that API is eligible to be removed in the next release of the JDK platform. If your application or library consumes any of these APIs, then you should make a plan to migrate from them soon.

So, Java offers a couple of mechanisms to depracate the API. One is @deprecated in the Javadoc that's introduced JDK 1.1. And the other one is @Depracated with a capital D, which was introduced in Java SE 5, JDK 5.

So of course, using the @depracated tag in the Javadoc comment of any depracated program elements to indicate that it should no longer be used. Of course, this tag is valid in all class method or field documentation comments. You specify depracation of the-- rather description, rather, of the deprecation. And here's an example where it says since 1.4, since used in the deprecated tag indicating that a File Handler class has existed since version 1.4 of this history.

Of course, we enhanced this in JDK 9. In JDK now, we can go ahead and use the @Depracated, which is used to indicate depracation. It can proceed the module class method or a member declaration. Again, the following elements are now added to the @Depracated. One is the since that specified the version, and then forRemoval, which is set to a Boolean. Is it true or false?

So here, the @Depracated annotation contains, again, these elements, the forRemoval, which set to Boolean. If it's set to true, which means it's a warning that the API is subject to removal in a future release. And it's called the terminal deprecation. And warning issues are called removal warnings.

On the other hand, the removal set to force, this recommends that code should no longer use this API. However, there is no current intent to remove it. And it is called an ordinary deprecation. And warnings issued are called ordinary warnings. And it's basically the default.

Now, we also have the since, which returns a string. This contains the release or version number when the API was deprecated. Again, the default value is an empty string.

So here's an example. When in this case, we have the @Depracated since 1.4, this with for the thread, since in the @Depracated annotation indicates the version at which the API was depracated. And we also can have @Depracated since since. And then forRemoval here is set to true, which we already know that for, in this case, set to true means that it is a warning that the API is subject to removal in a future release. And it's called a terminal depracation.

So, examples of deprecated APIs is in JDK 9 would be the ee module, the corba, the applet, Thread.destroy, and .stop, as you see here. And of course, you always have notifications and warnings. Here for example, it says @Depracated for the ee since 9, forRemoval set to true, the same thing with the corba, and the applet, and, of course, the destroy and stop, which were the destroy since 1.5 and the stop since 1.2.

Now in terms of notifications and warnings, when an API is deprecated, developers must be notified. The depracated API may cause problems in your code. Of course, or if it is eventually removed, your code basically will stop running. The Java compiler generates warnings about the create APIs. And you can also suppress deprecation warnings.

Of course, talking about the compiler deprecation warnings. If the deprecation is ordinary deprecation when removal is set to false, the Java compiler generates an ordinary deprecation warning. If the deprecation is terminal depiction when the forRemoval is set to true, then the compiler generates a removal warning.

So of course, the two kinds of warnings are controlled by separate dash Xlint flag. And we can go ahead and say the Xlint:depracation the dash Xlint:removal, and then forRemoval. The javac as dash Xlint:removal, option is enabled by default. So removal warnings are shown. Of course, here's an example of, in this case, the compiler depracation warnings, as you see here. If you go ahead and put down the dash Xlint OrdinaryDepracation.java, basically here it shows you an ordinary depracation warning, and the second one, a removal warning.

If you use an API that is terminally deprecated, your code, in this case, will stop compiling in the future. Consider, again, the scenario where, in this case, you use the Myapp compiles for each release, use the SomeOldJdkClass introduced, then you have the Myapp compiles fine without warnings. Or the Next Java release, you have SomeOldJdkClass deprecated, then Myapp compiles with warnings. And then the next release, the SomeOldJdkClass deprecated for removal, then it compiles with warnings. And then the Next Java release SomeOldJdkClass is removed, then, of course, Myapp compilation fails with errors because it's not there anymore.

Now, sometimes what we can do is we can suppress deprecation warnings. Prior to JDK 9, you could suppress all deprecation warning by annotating the @SuppressWarnings. Starting JDK 9, the @SuppressWarnings deprecation now works only for ordinary deprecation. It shows compiler warnings for depracated API intended for removal in a future release.

So in JDK 9, @SuppressWarnings deprecation, this suppresses only ordinary deprecation warnings, not removal warnings. @SuppressWarnings with the pass removal to it, this suppresses only ordinary depracation warning, not terminal deprecation warnings. And @SuppressWarnings deprecates a removal. This would suppress both ordinary and removal deprecation warnings. Here's an example of suppressed ordinary removal warnings for, in this case, stop and destroy. No deprecation warnings are issued for both these code snippets because the @SuppressWarnings annotation was added.

Now, looking at some static code analysis. Before JDK 9, you had to recompile your source code to find out about the deprecated JDK API from the compiler modification. Starting JDK 9 and 10, now introduce the new static analysis tool called jdeprscan. This tool performs a static analysis of class files and JAR and reports the use of deprecated APIs.

You can go ahead and run it. If you run it, you don't recompile your code for every JDK release. So suppress warnings depend on the third-party libraries that are distributed as [INAUDIBLE] artifact. Remember that.

So the benefits of the jdeprscan, it's important to discover dependencies on a deprecated API before the API are removed from the JDK. So looks for and reports the usage of only deprecated Java SE APIs. If the code uses depracated API from other libraries, like a Sprint, or Hibernate, or your own libraries, this tool will not, of course, report those issues. Remember that. Of course, useful when you don't have a source code to recompile. That's basically the advantage that you have with this.

And you can go ahead and run it. Basically, this is pretty much the syntax with options, and your directory, or JAR, or class, and so forth. You specify a list of space-separated directory, JARs, or a fully-qualified class names as arguments to the scan. Here's an example.

Let's go ahead and try this example here. This is for the example of the current lesson in the lab machine. So I just cannot-- first of all, I went into the File Explorer, and then got into the examples under the lesson 14, and has depracation package, or rather a folder under the labs. And then I opened, in this case, a terminal from there just by clicking File, Open Terminal. From there, it will open it right exactly there.

And then all what I did now is I just run this. Run the jdeprscan dash dash class path, classes on the com.example. If I hit Return here, and it will go ahead and give me now the warning.

So here it says, class com/example/foo users deprecated method, stop. And then foo also uses the destroy. And as you see here, it pretty much gives me here the forRemoval set to true for both as you see here. And that's what I see as a warning here. So we chose that the class foo, in this case, makes use of the stop and destroy. And obviously here, we see that there are some warnings related to that in terms of the stop and destroy here.

So jdepr now can be used for different versions. So you can use the jdeprscan relative to the previous three JDKs too. So you can go ahead and use them for prior to JDK-- you can use them for JDK 9, JDK 7, JDK 8, and so forth. So here's an example on how two of them just specify the release, in this case, dash dash release 7 or dash dash release 8, and so forth. And if you want to run them on JDK 9 and 10, you don't need to specify that.

And here, we do have a small quiz. In Java SE 9 @Depracated forRemoval set to true indicates which type of deprecation? And it would be ordinary, in this case, deprecation. And in the second one, which notation would suppress only ordinary deprecation warning but not terminal deprecation warning? This, of course, would be, in this case, b @SuppressWarnings removal.

And that's pretty much what I wanted to say in this practice. We do have some practices for this, which is performing some static analysis using jdeprscan. So try these before looking at the solution. Thank you.

## 2. Practice 14-1: Performing Static Analysis Using jdeprscan - 4m

Now that we're done with lecturing lesson 14, let's go ahead and take a look at its practices. It has one practice 14-1. We're going to perform a static analysis using jdeprscan. So in this practice we'll go ahead and use this on the StaticAnalysis.jar file and the commons-math3-3.6.1.jar file. That's the third-party library, which is Apache Commons Math project.

So the assumption is that we are going to be in the home Oracle labs say 14 Enhanced Deprecation practices, practice 14_01. And that's exactly what I have done. So if I do a pwd, that's exactly where I am. And they'll ask me, in this case, to do an ls. And I found the two JAR files, and then I run the jdeprscan on the static analysis JAR file. And that's basically what I get.

So I go ahead and run it here in this command, and I get, in this case, a output, which is this one here. That's what I get. So as you see, pretty much what they showed us here. So observe the report generated, which listed all the deprecated APIs in this case and including the Removal set to true for destroy. And that's exactly what we see here. All right. That's exactly what they want us to see.

And after that, they want us to run the jdeprscan on the Commons Math, in this case, JAR file. And that's what I did. And this is where it is, and then I get, of course, in this case, the output. So we observe the report generated by this. This, again, a command produces several lines of output. And one of them is this, in this case, class org/apache/commons/math3/util/MathUtils is basically deprecated. And for uses, again, the deprecated in this case, which is the method double, which is the init D V that we see here.

And the other one is the set scale that we see here. So in this, again, a line of output, the deprecated method, is on the class Java dot math dot big decimal. And the method is set scale, in this case. Of course, what you see here, the two that you see here means that it takes two int arguments. That's what it means.

And that's pretty much what they want us to do in this practice.

## 3. Skill Check: Enhanced Deprecation - Score 80% or higher to pass

Skill Check: Enhanced Deprecation

View Skill Check
