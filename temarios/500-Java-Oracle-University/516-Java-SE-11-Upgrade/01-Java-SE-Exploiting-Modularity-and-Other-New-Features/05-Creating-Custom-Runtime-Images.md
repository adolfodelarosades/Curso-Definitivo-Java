# 5: Creating Custom Runtime Images

1. Creating Custom Runtime Images - 21m
2. Practice 5-1: Creating and Optimizing a Custom Runtime Image by Using jlink - 7m
3. Practice 5-2: Using NetBeans to Create and Optimize a Runtime Image - 8m
4. Skill Check: Creating Custom Runtime Images - Score 80% or higher to pass

## 1. Creating Custom Runtime Images - 21m

Let's go ahead now and take a look at creating custom runtime images in lesson 5. In this lesson, we're going to define a custom runtime image, we're going to look at the jlink tool, which is really quite good-- it's a new one. That's the one that helps us create a custom image. Create a custom runtime image, and of course, optimize that image.

So let's start by understanding first this custom runtime image. Well, the idea here is that we can create a special distribution of your Java runtime containing only the required modules that you need for your application and that's it. So in a sense, your application modules and only those platform modules used by your application are included in this image. You can do that again using the Java SE 9 and 10 with the custom runtime image. And of course, that custom runtime image will be a totally self-contained image, basically that bundles your application modules and the platform modules with the JVM and everything else it needs to execute your application.

This is quite interesting and quite powerful because now, I can create my own runtime JVM. That's the advantage that you have. So, of course, the way we do it in the SE 9 and 10, we now have a link time which basically was introduced between the compilation and the runtime phase. And then of course, that is called the link time, and what it does, it acquires a linking tool that will assemble and optimize a set of modules and their transitive dependencies to create a runtime image.

And let's go ahead and use this a tool to create a custom image. This is called the jlink. So to create your custom image, you are going to use this command called the jlink, which was introduced in SE 9 and 10. And it's pretty much used to create a custom platform-specific runtime image. Remember, it's platform specific. So then assemble a set of modules and their dependencies right in that image. And it uses the set of dependencies that from the module that's in for class to be able to again assemble all the modules that basically your application depends on. And it also helps us perform some optimization.

And the way we run this command-- pretty much straight forward. We use the jlink with a bunch of options. We do now have a --module-path. This basically represented the module path, which is the module path where the platform and application modules to be added to the image are located. And then modules can be modular JAR files and JMODs, of course, or exploded directories. It's basically up to you.

And then you have the --add-modules mods. The mods would be the list of the modules to be added to the runtime image. These are the modules that are needed by your application. The jlink to them will add all these modules and their transitive dependencies into your image. Of course, the path, in this case when you use that --output path, the path would be the output directory where the generated runtime image will be stored.

And here's an example. If you want to, basically, here, what we're doing is we are creating a runtime image. So in this case, we specify the --module-path. This constructs a module path where the Hello word application is present. And you have the JMOD's directory, contains the platform modules. The --add-modules indicates the com.greeting, which is the module that needs to be added to the runtime. And then the --output would specify the directory where the runtime image will be generated. In this case, would be myimage, which is stored inside that directory.

And of course, let's just see an example of how to do that. I already did run this command that I created in this case. If I do an unless, I have my image over there, as you see. And so this basically allows me now to-- I created my image, and I can go ahead and, of course, run it.

Or if you want, I can go in the deployment and use it. So for now, continue, and I get into that image, in this case. I can do an ls, and I can find it has the bin, the config, the include, the legal, lib, release-- pretty much your own image. And I can get into, in this case, the bin, and then I could run a Java-version, just so that I can, in this case-- look, and as you see here is version 9. Could be version 10 too.

You can go one level up, or I can do even inside a .bin. I can run the Java, and then list the modules that basically were created. As you see here, my image now contains these modules, which is the con.greeting. And that's basically where my application is in my class. And then it also makes use of the java.base and the java.logging, in this case.

And I can also-- just take a look. If I wanted to, for example, go one level up in this case into my image, and then I can do du minus sh to find the size of it. It's 45 megabytes. If I want to do the same thing, then look at my JDK. If I want to go all the way up to a route, and I can do cd/usr/java. That basically gets me to that, and I can go and get into JDK, in this case, dash nine. And then I can do a du.sh, and then you see that in this case, it also gives me the size. So as you see, the whole JDK is 991 megabytes here, but what I have here in my image is only 45 megabytes. That's a very, very small a footprint. That's definitely something that we need to look at, and as you see, it has lots of advantages here.

So again examining, in this case, your image, pretty much here you have your image and underneath you have your bin. Underneath the bin you have your Java, as you see here. And then of course, you have your conf, which basically contains the editable configuration files like the .properties files.

You have the include that contains the C++ headers, and also some of the Java files. You have the legal, which contains the legal notices, and you have the lib, which contains, among others, the modules added to the runtime image. And we can a look at that.

So he's my image, and I can go inside my include, and I can do in a lesson I find in this case some header files over there. I'm going to go up and then go into the lib, and I can find also the different type of files that I need [INAUDIBLE] and so forth. That's basically the idea behind this. And you can look into it and see. And I can also look at the bin, and I can find my Java and key tool over there too, and so forth.

So of course, in this case, as you see, the modules resolved in the custom runtime would be only the ones that are needed for your application and that's it. So contains all the modules necessary for your application, and that's a huge thing. Can you believe it? I have my own runtime image and this is mine and I'm going to go ahead and deploy this and that's all I need. This is why we said you can deploy it to small devices.

Of course, the advantages of creating your custom runtime image is that it is beneficial from many, many different reasons. First the ease of use, where it can be shipped to your application users who don't have to download and install your JRE separately to run the application. You don't need that. You don't need to install the whole JRE. It has a reduced footprint. We just saw that. It's only 45 megabytes. Consists of only those modules that your application uses, and therefore it's much, much smaller than full JDK and can be used on resource-constrained type of devices or to run on application in the cloud. And that's the advantage you have.

Of course, in addition, it has an excellent performance. It runs faster because of the link time optimization that are of course otherwise too costly. So this is definitely a win-win situation in our case here. Of course, the image format in this case, the runtime image is stored in a special format called JIMAGE, which is again optimized for space and speed. A much faster way to search and load classes than the JAR and the JMOD files. And of course, JDK ships with a JIMAGE tool to let you, again, explore the contents of a JIMAGE file.

So we checked earlier the sizes, and if you remember, I showed you this already. So it's 991 megabytes, and then of course the size here, we found that it's only four megabytes different. 45 megabytes, if you remember, for our image. So we just added some modules. That's why it's slightly higher on the current-- this case with the labs or other than. Know when we run this earlier, and the snapshot we took is from an older type of a version. And now we have JDK 10.

Now, examining this custom runtime image. Well, you can check the runtime of a custom runtime image created. Again, to do that, you just use the Java-version. We already did that, and I showed you this earlier. It was in one of the-- I think it was just a little bit earlier. Yeah, here it is, when I just specified, in this case, the version. And here it is-- the version. OK. And that's what we have here. Again, in this case, if you're on it on 10, it will be JDK 10.

You can also execute the Java--list-module, and this command will tell you about all the modules that are inside the application. We already have seen this-- com.greeting and Java.base and Java.logging-- and I've already run this earlier before for you. And of course, you can use the Java command line, which again, in this case, is to run your image. So in this case, it would be Java minus m and then a com.greeting. Let's go ahead and do that. So I can be now in a-- so let me do an unless. So I have now Java minus m and then a com.greeting. I need to use the Java minus m and then com.greeting.

See? And now it pretty much gave me the output. It turns out that I do have, in this case-- let me just minimize this guy here and just show you-- and on oracle and then labs, and then when you go to your practice, that's where you are going to see hello. And then under the source you have com, and this is pretty much the class that you have. And if you take a look at this class, it prints hello. App says hello. Hello, world. App says hello. And that's what we are running here. That's basically what we see, in this case, when we run that. So that's what we have here.

So you don't have to set the module path. Again, the custom runtime image is in its own module path. And you can go ahead and use it, and the profile just run that in front of you. Now you can also use the dash launcher when you create your image. And what happens is that this dash launcher option will help you create a platform-specific executable in the binary. So for example here, if I add the --launcher com.greeting and set it to hello, then I can run my application-- just bin and then hello. Hello will be the executable, in this case. You get to try this in the practice anyway.

So jlink also resolves transitive dependencies. So the j tool will resolve all dependencies transitively for the module specified using the --add-modules option and includes all the resolve-dependent modules into runtime image. Which means when you have, in this case, any type of transitive dependencies, that also will be resolved automatically by the jlink.

Here, for example, consider the welcome module that is dependent on the contact people module. Now we said that the jlink resolves the transitive dependencies. So in this case, you create a custom runtime image of the welcome module, and here it is. And of course, run again the command that you see here to see the module that included, in this case, in my image. So you see java--list-module. Then automatically, you observe that the com.people module is included because the jlink has resolved the transitive dependencies of the welcome module and included it inside the runtime image. And you guys can try these later on in the practice.

Now you could also, by the way, optimize your custom runtime image. And so using plugins with the jlink tool, you can do that. For example, to use a plugin, you need to use the command line option for it. So here, you can run your jlink tool using the --list-plugins. This option is basically to print a list of all available plug-ins with their description and command line options. So just go out and try that.

And of course, in addition to, in this case, running your jlink, you can also optimize your custom runtime image by using the compress. The compress plugin is very useful. It optimized the custom runtime image using the compress to create a reduced SE 9 or SE 10 runtime image. Here's how pretty much what-- so the compress can be 01 or 2. Two would be the highest level. Compresses all resources in the output image. Zips it. And also, you can use the strip debug plugin. This basically allows you to remove all the debugging information from the Java code, and which means it will further reduce the size of your image. So it's really good for a smaller footprint.

And here's a command how you are going to do a compress and strip the debug plugins, if you want to use them. So you just write your jlink and then, of course, at the end, you pretty much use the -strip-debug and then the --compress and set it two. Set it to two will be the maximum compression that you're going to do. So in this case, if you take a look at the size, it will be even smaller. And you can go ahead and try this. In fact, they will ask you to try this in the practices.

And we do have a small quiz here that says, in Java SE 9, which phase provides an opportunity to perform optimization? And that would be the link. You know about that. And then identify set of tasks jlink can perform on a set of modules to create a custom runtime. Of course, some of the modules unoptimize the modules. So it will be, in this case, both A and B. These are just some additional resources, if you want to take a look. Read a little bit about the Java link here.

And so in this lesson, we learn about something really, really quite new and quite good also, which is this tool called jlink tool that allows you to create your custom runtime image. This is a huge breakthrough simply because it allows you to build your own image, and you don't have to download the whole JDK every you run the application. You just use the jlink, and the jlink will go either bundle the modules that you created, plus any dependencies and so forth, and then of course, adds only the modules that are needed from the JDK, not the whole thing. That's definitely a breakthrough. No question about that.

We are going to have a couple of practices that we ask you to try, and one is to create and optimize-- remember when I said optimize, which means you're going to use the compress here-- a custom runtime image using jlink. And then in 5-2, you're going to use the IDE to create and optimize also a custom runtime image, because you can do it through net-based IDE too. And that's what we are going to do in this practice, which is 5-2. So try these practices before you look at their solutions. Thank you.


## 2. Practice 5-1: Creating and Optimizing a Custom Runtime Image by Using jlink - 7m

 
Now that we're done with lecturing lesson 5, let's go ahead and do its practices. We're going to start with practice 5-1. Here, we're going to create and optimize a custom runtime image by using jlink. So pretty much in these practice, we are going to create an optimized custom runtime image in Java SE 9 by using the jlink. By the way, it works exactly the same with JDK 10.

So first to create a custom runtime, first we'll open a terminal, and we go to cd/Oracle/home/labs/05_jlink/practices/Prac_05_01/Hello and then run this command. And that's basically what I have here. So I'm already there. And I have the command. And I run it.

So it says the image already exists because I did run this. I already did try this earlier when I was teaching. So that's why it says it's already there.

And then, of course, after that, I'll go ahead and get into cd image. So now if they do an ls, it says it's already there. If I do a cd myimage, I get into it. And that's basically what they want us to do in this case.

And then after that, I go ahead and if I do an ls, you will see that this is my image. It has all the different folders of a JVM image. And that's basically what we have.

And then, of course, after that, I do a cd bin and run the version. Let's go ahead and do that. So there's a bin over there, so cd bin.

And then run the java, in this case, [INAUDIBLE] version. And then I'm going to see that-- typo-- dash version here. And I'm going to see that it's all there. JDK 9, that's exactly what they want us to do.

And then, of course, after that, they want us to run and list the modules that exist in this image. So if I now I do, in this case, a dot forward slash java and dash dash list dash modules, and then hit Return, it tells me these are basically the modules that belong. So the com.greeting where my class is there.

And then it turns out that this needs the java.base, which, by the way, is used, and then the java.logging. And that's what I have in this particular case. So that's what I, you know.

And then, of course, after that, they want us to check the size of the JDK versus the size of myimage. That's basically what we have. So if I do a cd dot dot that will lead me to-- and then I can look at the size in this case. And it turns out that this is of size 45 megabyte. That's all.

But then if I go to my, in this case, JDK 9 and do the same thing, and I see that it's 991 megabytes. So that's basically big compared to myimage, which was only 45 megabytes. So that's definitely something that is really, really quite useful.

Now of course, after that, I go ahead and get into bin. That's basically what they want us to do. So I'll get into the bin. And then I run my application. And that's what we have here.

So we'll go ahead and cd bin, and then dot slash java, space, and then, of course, in this case, dash dash module, and then com.greeting. That's what we have. If we run this, and that's the output basically. That's basically what they want us to do.

Then after that, they want us to optimize the custom runtime image using the jlink. And in this time-- jlink plug-in, of course-- and we're going to compress to create a reduced JDK 9 runtime image. We can also enable compression and remove some debugging features on a production system if we want to.

So here, we're going to apply this command here. That's what we have. And in this, I put it in this tab. That's pretty much what I have here, pretty much the same as you see here. That's what I have. And as you see here, it's all here. And this is the command that I am trying to use, in this case.

And then you can see it. Here it is, jlink dash dash module dash path space dist forward slash Hello.jar file, colon usr, and java, jdk 9, jmods, and then dash dash modules, and dash modules, com.greeting, dash dash output, compressmyimage-- that's the name-- and then dash dash strip, dash debug-- stripping, in this case, the debugging information-- dash dash compress, and set it 2. And I hit Return. So this will go ahead and, in this case, will create my image.

And then all what I need to do now is run this command-- du dash sh, and then compress, in this case, myimage, and then dot slash myimage. And if I run this, then, of course, in this case, I see that the compressed myimage is now only 31 megabyte compared to myimage, which I did not compress, which is, of course, in this case, 45 megabyte. So as you see, when you use the compress, it definitely helps. And that's pretty much what they want us to do in this practice.

## 3. Practice 5-2: Using NetBeans to Create and Optimize a Runtime Image - 8m

Let's take a look now at practice 5-2. Here, we're going to use NetBeans to create an optimized runtime image. So we are going to open the TeamGame project from the practice 5 02 in NetBeans, and then right-click and select Properties. And that's what we're going to do.

So we already opened, and right-click, select Properties. And then, of course, after that, they want us to, in this case-- so once we selected Properties, we'll go into the next, in this case, slide, and then, of course, in this case, the bill Packaging, and then, in this case, the bill Packaging.

What we are going to do is select, in this case, the compressed JAR file, and then select to Create JLINK, and then, of course, strip the debug information. So that's basically what they want us to do. And then click OK.

And that's just following the steps that they told us. And then, of course, click OK. The options Compress JAR File, Strip Information are used to compress and optimize the custom runtime image that we created.

After that, all what we're going to do, in this case, is clean and build the project. Let's go ahead and do that, clean and build the project. So we just clean and build the project in this case. So that's what's going to happen now. Done.

Then after that, if we click on the File tab, that's basically what they want us to do. And then get into the distribution, you will see the JLINK, and open that JLINK. That's what we have here. Let's go ahead and do that.

Now, we have the JLINK that pretty much contains, in this case, the application. And that's what we see here. And that's what they want us to do. So of course under that, we can go out and open. And we see all the folders that were created of our image.

Now next, what they want us to do pretty much is to open a terminal right at the bin and then list, in this case, the modules that exists in this. So let's go ahead and do that.

So for that, I'll go ahead and browse into the distribution following the JLINK. And then after that, the Team app, and then the bin, and open my terminal right here. And that's what I have.

And then all what I do is then run java space dash dash list dash modules. And that will give me the modules that pretty much. And that's exactly what we have here. So that's what they want us to see.

And then after that, they want to run, in this case, the application. And that's the next one, which pretty much allows us, in this case-- we can run it from here, dash java, and then, in this case, dash dash module, which is already in the bin anyway, and dash dash module space, and then main, in this case, slash tournament and dot main. So we could have run it the other way also, dot forward slash dist jlink, and teamGameApp bin java, and then-- so we just did it from there since we are already there-- so dot forward slash java dash dash module, main forward slash tournament.Main. And then hit Return.

And obviously this is a typo here. Let's go ahead and basically try it, in this case, from the command line. And I can always copy and paste this one here.

And I may just go ahead and get to this one here. I can copy and paste it. It's pretty much the same. Or I can do it this way also by just, in this case, getting into cd dot dot-- let me just clear this-- cd dot dot, and then I have now-- I am in the Team. If I do it pwd, that's exactly what I have.

And then right now, I'll go ahead and, in this case, write dot forward slash dist in this case, and then forward slash jlink, and then after that, forward slash, in this case-- let me actually, in this case, get more into a higher level. And where if I do a pwd, that's exactly what I am.

And then I do a dot forward slash dist, then after that jlink, and then after that, teamGameApp, and after that, bin, and after that, java, and then dash dash module, and then main forward slash tournament, and dot Main with a capital M, of course. That's the Main class. And that's exactly where they want us to run it from. So it's nice to actually run it from there. And that's exactly what we have.

And if we execute this, in this case, and then we get the output. And that's exactly the output that they want us to find in this case. And that's the next page. And that's pretty much what they want us to do. And that's all what they want us to do for practice.

## 4. Skill Check: Creating Custom Runtime Images - Score 80% or higher to pass

Skill Check: Creating Custom Runtime Images

View Skill Check
