# 5: Creating Custom Runtime Images

1. Creating Custom Runtime Images - 21m
2. Practice 5-1: Creating and Optimizing a Custom Runtime Image by Using jlink - 7m
3. Practice 5-2: Using NetBeans to Create and Optimize a Runtime Image - 8m
4. Skill Check: Creating Custom Runtime Images - Score 80% or higher to pass

## 1. Creating Custom Runtime Images - 21m

Let's go ahead now and take a look at creating custom runtime images in lesson 5. In this lesson, we're going to define a custom runtime image, we're going to look at the jlink tool, which is really quite good-- it's a new one. That's the one that helps us create a custom image. Create a custom runtime image, and of course, optimize that image.

So let's start by understanding first this custom runtime image. Well, the idea here is that we can create a special distribution of your Java runtime containing only the required modules that you need for your application and that's it. So in a sense, your application modules and only those platform modules used by your application are included in this image. You can do that again using the Java SE 9 and 10 with the custom runtime image. And of course, that custom runtime image will be a totally self-contained image, basically that bundles your application modules and the platform modules with the JVM and everything else it needs to execute your application.

This is quite interesting and quite powerful because now, I can create my own runtime JVM. That's the advantage that you have. So, of course, the way we do it in the SE 9 and 10, we now have a link time which basically was introduced between the compilation and the runtime phase. And then of course, that is called the link time, and what it does, it acquires a linking tool that will assemble and optimize a set of modules and their transitive dependencies to create a runtime image.

And let's go ahead and use this a tool to create a custom image. This is called the jlink. So to create your custom image, you are going to use this command called the jlink, which was introduced in SE 9 and 10. And it's pretty much used to create a custom platform-specific runtime image. Remember, it's platform specific. So then assemble a set of modules and their dependencies right in that image. And it uses the set of dependencies that from the module that's in for class to be able to again assemble all the modules that basically your application depends on. And it also helps us perform some optimization.

And the way we run this command-- pretty much straight forward. We use the jlink with a bunch of options. We do now have a --module-path. This basically represented the module path, which is the module path where the platform and application modules to be added to the image are located. And then modules can be modular JAR files and JMODs, of course, or exploded directories. It's basically up to you.

And then you have the --add-modules mods. The mods would be the list of the modules to be added to the runtime image. These are the modules that are needed by your application. The jlink to them will add all these modules and their transitive dependencies into your image. Of course, the path, in this case when you use that --output path, the path would be the output directory where the generated runtime image will be stored.

And here's an example. If you want to, basically, here, what we're doing is we are creating a runtime image. So in this case, we specify the --module-path. This constructs a module path where the Hello word application is present. And you have the JMOD's directory, contains the platform modules. The --add-modules indicates the com.greeting, which is the module that needs to be added to the runtime. And then the --output would specify the directory where the runtime image will be generated. In this case, would be myimage, which is stored inside that directory.

And of course, let's just see an example of how to do that. I already did run this command that I created in this case. If I do an unless, I have my image over there, as you see. And so this basically allows me now to-- I created my image, and I can go ahead and, of course, run it.

Or if you want, I can go in the deployment and use it. So for now, continue, and I get into that image, in this case. I can do an ls, and I can find it has the bin, the config, the include, the legal, lib, release-- pretty much your own image. And I can get into, in this case, the bin, and then I could run a Java-version, just so that I can, in this case-- look, and as you see here is version 9. Could be version 10 too.

You can go one level up, or I can do even inside a .bin. I can run the Java, and then list the modules that basically were created. As you see here, my image now contains these modules, which is the con.greeting. And that's basically where my application is in my class. And then it also makes use of the java.base and the java.logging, in this case.

And I can also-- just take a look. If I wanted to, for example, go one level up in this case into my image, and then I can do du minus sh to find the size of it. It's 45 megabytes. If I want to do the same thing, then look at my JDK. If I want to go all the way up to a route, and I can do cd/usr/java. That basically gets me to that, and I can go and get into JDK, in this case, dash nine. And then I can do a du.sh, and then you see that in this case, it also gives me the size. So as you see, the whole JDK is 991 megabytes here, but what I have here in my image is only 45 megabytes. That's a very, very small a footprint. That's definitely something that we need to look at, and as you see, it has lots of advantages here.

So again examining, in this case, your image, pretty much here you have your image and underneath you have your bin. Underneath the bin you have your Java, as you see here. And then of course, you have your conf, which basically contains the editable configuration files like the .properties files.

You have the include that contains the C++ headers, and also some of the Java files. You have the legal, which contains the legal notices, and you have the lib, which contains, among others, the modules added to the runtime image. And we can a look at that.

So he's my image, and I can go inside my include, and I can do in a lesson I find in this case some header files over there. I'm going to go up and then go into the lib, and I can find also the different type of files that I need [INAUDIBLE] and so forth. That's basically the idea behind this. And you can look into it and see. And I can also look at the bin, and I can find my Java and key tool over there too, and so forth.

So of course, in this case, as you see, the modules resolved in the custom runtime would be only the ones that are needed for your application and that's it. So contains all the modules necessary for your application, and that's a huge thing. Can you believe it? I have my own runtime image and this is mine and I'm going to go ahead and deploy this and that's all I need. This is why we said you can deploy it to small devices.

Of course, the advantages of creating your custom runtime image is that it is beneficial from many, many different reasons. First the ease of use, where it can be shipped to your application users who don't have to download and install your JRE separately to run the application. You don't need that. You don't need to install the whole JRE. It has a reduced footprint. We just saw that. It's only 45 megabytes. Consists of only those modules that your application uses, and therefore it's much, much smaller than full JDK and can be used on resource-constrained type of devices or to run on application in the cloud. And that's the advantage you have.

Of course, in addition, it has an excellent performance. It runs faster because of the link time optimization that are of course otherwise too costly. So this is definitely a win-win situation in our case here. Of course, the image format in this case, the runtime image is stored in a special format called JIMAGE, which is again optimized for space and speed. A much faster way to search and load classes than the JAR and the JMOD files. And of course, JDK ships with a JIMAGE tool to let you, again, explore the contents of a JIMAGE file.

So we checked earlier the sizes, and if you remember, I showed you this already. So it's 991 megabytes, and then of course the size here, we found that it's only four megabytes different. 45 megabytes, if you remember, for our image. So we just added some modules. That's why it's slightly higher on the current-- this case with the labs or other than. Know when we run this earlier, and the snapshot we took is from an older type of a version. And now we have JDK 10.

Now, examining this custom runtime image. Well, you can check the runtime of a custom runtime image created. Again, to do that, you just use the Java-version. We already did that, and I showed you this earlier. It was in one of the-- I think it was just a little bit earlier. Yeah, here it is, when I just specified, in this case, the version. And here it is-- the version. OK. And that's what we have here. Again, in this case, if you're on it on 10, it will be JDK 10.

You can also execute the Java--list-module, and this command will tell you about all the modules that are inside the application. We already have seen this-- com.greeting and Java.base and Java.logging-- and I've already run this earlier before for you. And of course, you can use the Java command line, which again, in this case, is to run your image. So in this case, it would be Java minus m and then a com.greeting. Let's go ahead and do that. So I can be now in a-- so let me do an unless. So I have now Java minus m and then a com.greeting. I need to use the Java minus m and then com.greeting.

See? And now it pretty much gave me the output. It turns out that I do have, in this case-- let me just minimize this guy here and just show you-- and on oracle and then labs, and then when you go to your practice, that's where you are going to see hello. And then under the source you have com, and this is pretty much the class that you have. And if you take a look at this class, it prints hello. App says hello. Hello, world. App says hello. And that's what we are running here. That's basically what we see, in this case, when we run that. So that's what we have here.

So you don't have to set the module path. Again, the custom runtime image is in its own module path. And you can go ahead and use it, and the profile just run that in front of you. Now you can also use the dash launcher when you create your image. And what happens is that this dash launcher option will help you create a platform-specific executable in the binary. So for example here, if I add the --launcher com.greeting and set it to hello, then I can run my application-- just bin and then hello. Hello will be the executable, in this case. You get to try this in the practice anyway.

So jlink also resolves transitive dependencies. So the j tool will resolve all dependencies transitively for the module specified using the --add-modules option and includes all the resolve-dependent modules into runtime image. Which means when you have, in this case, any type of transitive dependencies, that also will be resolved automatically by the jlink.

Here, for example, consider the welcome module that is dependent on the contact people module. Now we said that the jlink resolves the transitive dependencies. So in this case, you create a custom runtime image of the welcome module, and here it is. And of course, run again the command that you see here to see the module that included, in this case, in my image. So you see java--list-module. Then automatically, you observe that the com.people module is included because the jlink has resolved the transitive dependencies of the welcome module and included it inside the runtime image. And you guys can try these later on in the practice.

Now you could also, by the way, optimize your custom runtime image. And so using plugins with the jlink tool, you can do that. For example, to use a plugin, you need to use the command line option for it. So here, you can run your jlink tool using the --list-plugins. This option is basically to print a list of all available plug-ins with their description and command line options. So just go out and try that.

And of course, in addition to, in this case, running your jlink, you can also optimize your custom runtime image by using the compress. The compress plugin is very useful. It optimized the custom runtime image using the compress to create a reduced SE 9 or SE 10 runtime image. Here's how pretty much what-- so the compress can be 01 or 2. Two would be the highest level. Compresses all resources in the output image. Zips it. And also, you can use the strip debug plugin. This basically allows you to remove all the debugging information from the Java code, and which means it will further reduce the size of your image. So it's really good for a smaller footprint.

And here's a command how you are going to do a compress and strip the debug plugins, if you want to use them. So you just write your jlink and then, of course, at the end, you pretty much use the -strip-debug and then the --compress and set it two. Set it to two will be the maximum compression that you're going to do. So in this case, if you take a look at the size, it will be even smaller. And you can go ahead and try this. In fact, they will ask you to try this in the practices.

And we do have a small quiz here that says, in Java SE 9, which phase provides an opportunity to perform optimization? And that would be the link. You know about that. And then identify set of tasks jlink can perform on a set of modules to create a custom runtime. Of course, some of the modules unoptimize the modules. So it will be, in this case, both A and B. These are just some additional resources, if you want to take a look. Read a little bit about the Java link here.

And so in this lesson, we learn about something really, really quite new and quite good also, which is this tool called jlink tool that allows you to create your custom runtime image. This is a huge breakthrough simply because it allows you to build your own image, and you don't have to download the whole JDK every you run the application. You just use the jlink, and the jlink will go either bundle the modules that you created, plus any dependencies and so forth, and then of course, adds only the modules that are needed from the JDK, not the whole thing. That's definitely a breakthrough. No question about that.

We are going to have a couple of practices that we ask you to try, and one is to create and optimize-- remember when I said optimize, which means you're going to use the compress here-- a custom runtime image using jlink. And then in 5-2, you're going to use the IDE to create and optimize also a custom runtime image, because you can do it through net-based IDE too. And that's what we are going to do in this practice, which is 5-2. So try these practices before you look at their solutions. Thank you.


## 2. Practice 5-1: Creating and Optimizing a Custom Runtime Image by Using jlink - 7m
## 3. Practice 5-2: Using NetBeans to Create and Optimize a Runtime Image - 8m
## 4. Skill Check: Creating Custom Runtime Images - Score 80% or higher to pass
