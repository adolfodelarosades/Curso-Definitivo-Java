# What's New in Java EE 8

1. What's New in Java EE 8 17m

## 1. What's New in Java EE 8 17m

Hi there. My name is Elder Moraes. I work at Oracle as Cloud Evangelist, and I am here today to talk to you about what's new in Java EE 8. I don't know if you are familiar with Java EE, but it is one of the most popular and one of the most major and one of the most robust frameworks and environments and ecosystem in the software industry. So it is made by many APIs that I'll show you in this slide.

So we have some-- many of them that are very popular. Some of them are not so popular, but in Java EE 8, you have many of them that were updated or even some of their new APIs. So that's what I'm going to show you today. So let's start with about community, because Java is made as an open source project, and community has a lot of voice inside the Java EE world.

So once they started the project for Java EE 8, they made a proposal. And this proposal was made for a survey, and a committee participated on the survey so that what I'm going to show you in this first column-- that is all the APIs that we're planning for update on Java EE 8. And then you have, in the third column, the results from the community survey rank. And then the last one, the changes-- for example, we have the MVC 1.0 that was dropped from the Java EE 8. So just for instance, in that link, you can go and get more information about it.

So this is all the APIs that were updated or created for Java EE 8. That's what we are going to discuss and see a little today. So let's start about JAX RS 2.1. They were updated, and the highlights that I give to you for this update is reactively client API and the server sent events.

So talking about the reactive client API, the new is that line that is blue. That's RX. That you can find in the real reactive client API. So we have two ways of doing it. First one is by, as you said, the request, where we are telling the API, which kind of media type that you want. So in that way, we got a response type of return from the API. And the second one is without informing media type is specifically informing to the get method that we want, for example, a string. So we got the very, very, very specific kind of object that we want from the API.

So the completion stage will allow you to use thenApply, thenAccept, and thenCombine, and those Java EE 8 stuff. So we have also in JAX RS 2.1 the server sent events. That was one of the most wanted features for our JAX RS. So it is a one-way communication between server and client. It can sense multiple message to one single client. It is supported in most browsers-- not every browser, but most of them. Most of the new browsers, modern bloaters already support the server sent events.

So we have here some code. This code is from the server side. So we got some injection with using CDI from the context, and we associate with seeBroadcaster. And also, we got instance from this SeeEventSync. So we can produce the events that we want to send to the client. And one of the news that's being produced, we have the new media type. That is server sent events. That is a media specifically for server sent events.

So we, here, can just register our broadcaster and send the event that we just made on the first line, when we created a message that we sent to the clients. Here, we have a client site code, where we are just creating a target, web target, as it were on any point. And just we connect to it and consume the message, as you can see on the register, and then consuming, accepting the return that's coming from the server. And then we can close the client.

So that was JAX RS. Now moving to JSON-P 1.1. So we have some news in the JSON API. Specifically, we can highlight the pointer, JSON pointer, JSON patch, JSON collectors, and operations with JSON object and JSON array. So talking a little about JSON Pointer, you can use it to go specifically in one point to your JSON and get information from there. So here in this example, we are looking through a JSON for players, where I have email, I have name, I have friends, and I can point my JSON pointer to specifically "friends," and get the values from that part of JSON.

And we have also JSON Patch. That is a very easy way to make manipulation inside my JSON. So here, we're just creating a Builder, JSON Patch Builder. And we can use it both for adding, removing formation in the very same line. And moving ahead to JSON-B 1.0 is a new API. It was released together with Java EE 8. So basically, it is an API to parse and unparse like martial and unmartial Java objects to and from JSON. And you can use it also to mapping between classes and JSON objects.

So here, we have an example. We created a simple Java class customer, where I am creating a name and email. So using JSON Builder, we can get this object in transforming to JSON, and going back to two objects from JSON, and both using JSON Builder.

So in talking about now a little more web application development, we have a Servlet 4.0 that was also one of the most awarded APIs that was released under the Java EE 8 umbrella. And specifically about HTTP 2.0, that was waited for a long time in the Java EE 8 ecosystem. And it brought with that the server push, possibility to server push feature. And we have also upgraded from HTTP 1.0. And the coolest part is that we didn't [INAUDIBLE] compatibility with HTTP 1.0. And we have also in Servlet 4 support for JSF 2.3 with no code changing, what I'm going to show you in the JSF topic.

So talking a little about the server push is a new feature, where we have fraud requests, an instance from PushBuilder, and before you use the PushBuilder, you should be sure that you have the reinstance for the PushBuilder, because of two reasons. One, not every browser today is ready for push server events, and two, because even if your browser is ready, maybe you are not using-- your client is not using HTTPS for it. It will only work under HTTPS protocol. So you have to make sure that you have the reinstance. Otherwise, you get a null pointer exception.

So once you have the instance, you can just inform the path of the resource that you are using, and then push it through the browser. Just to be more specifically, what server push is doing is sending to your browser all the resources that it needs like images, like Java scripture files, CSS files, and so on, before the server-- before the browser needs to ask for the server. Hey, send to me. Because for it, it needs to do a lot of requests.

So in this case, you need just one request. When the page is loading, the server sends all the resources to the browser beforehand. So it's very good. It's very nice for performance. And that's why JSF is taking a lot of advantage about it [INAUDIBLE] talking a little about in a second.

And here we are with JSF 2.3. So while there is not too much things that we can show before many, many of the modifications was done under the hood, but the highlights here is it got all the improvements that it was bringing for HTTP 2.0. So if you have any JSF application above the version 2, and you just change it to Java EE 8 compatible server, you already get all the improvements for performance that was brought by the HTTP 2.0. So it's very cool, and you have all the compatibility, the code. You don't have to write any code again. So it's very nice.

And you also have better CDI integration, what we will show you in a second. So now talking about CDI 2.0, we have now the support for Java SE. Actually, CDI is today maybe one of the most important, if not the most important API for the whole Java EE ecosystem and the framework, because CDI has changed the way that many other specifications and other APIs has working. If you talk to many spec leaders for Java EE, they would say that they would have done the things different, if they had CDI in the beginning.

CDI is very powerful. So now you have this all those powerful [INAUDIBLE] CDI to use with Java SE, so you don't need anymore Java e-server to have the CDI's features. You can have it inside the Java SE. So now the specification has three parts-- the CDI core, CDI for Java SE, and CDI for Java EE. So we have now three specifications for CDI.

Two highlights that we have also, besides the Java SE part, is that we have observers ordering, that we'll show you in a minute, and asynchronous events. So talking about the observers on the beginning of the first version, the less version, previous version of CDI, we had this kind of observer. Maybe if you had a customer class, and you wanted to put an observer over it, you had Observer 1 and Observer 2, and both with annotation for observers.

But you can assure which one would run in the first, because it was up to the server to manage the order. So now you have the observers, and you have also another annotation. There is priority. So once you inform the priority, the server will respect those priorities. So in this case, the 1 will run before the 2. And we have been talking about asynchronous events, so we can create an event for a customer, for example. It got an inject from the CDI for the context. It created event for a customer, and then we created a producer method for it to be fire event, asynchronous event against a customer. And once it is done, we can also launch an observer. It is a synchronous observer, for we have all those asynchronous behavior here.

So going ahead, we have also Bean Validation 2.0, and the best way to show the news about Bean Validation is actually showing code. So we have here some examples of the news about Bean Validation 2.0. We have first @NotBlank, because since this last version, we had only the NotNull. And NotNull is great to get a NotNull string, but it will just let you have a string with spaces, for example. So it's not new, but it has no information at all.

So now we have the NotBlank, so it's not enough to only have a NotNull, but you also need to have some information if you are using the notation, NotBlank. We still have the @NotNull, as you can see on email string. But it has also the annotation, @Email. Now you don't need to write your own validation for email. It is done in writing, framework writing the Bean Validation. So just get a notation, and the [INAUDIBLE] for we take care for you.

We have also the NotEmpty, usually for lists. So you can have a list, and you need to assure that the list is not empty. And you can also, inside the generics, put in a @Valid annotation. So to make sure that the members of those lists are also valid, so the list is valid, and the members need to be also valid in this case. And we have also annotations in Bean Validation for dates. In this case, we are saying that this date should have been a date in the future. We have also the present or future and past or present and past, all those annotations for date fields.

And moving forward, we have also the security API. It's also a new API for Java EE 8. They're both released with Java EE 8. And it is based on the Soteria that is its reference implementation that we had before Java EE 8. So now it's part of the specification. It became a standard, and the coolest highlight that we have here is the authentication mechanism. It is very simple to have those kind of education.

So basically, we have an interface that we need to implement. So to get the credentials, and then you can identify the caller, and once the caller is right, you verify that it's correct, and you can give the sender notification to the server, and let the user have the access that it needs. And this is a code who can show you how to choose to fire that events of calling the authentication mechanism.

So it's basically, ask for a server to authenticate a user, and informing the name or the credential that you need to use. So that's a lot. So Java EE has brought a lot of new stuff in version 8. And it still mature, still stable, still robust, so I hope you enjoy, and good coding. See you next time. Bye bye.
