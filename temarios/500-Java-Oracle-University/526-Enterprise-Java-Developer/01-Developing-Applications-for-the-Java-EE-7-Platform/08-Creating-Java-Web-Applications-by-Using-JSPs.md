# 8: Creating Java Web Applications by Using JSPs

1. Creating Java Web Applications by Using JSPs - 24m
2. Practice 8-1: Creating a JSP to Display the Product List - 23m
3. Practice 8-2: Creating a JSP for Editing a Product - 33m
4. Skill Check: Creating Java Web Applications by using JSPs - Score 80% or higher to pass

## 1. Creating Java Web Applications by Using JSPs - 24m

Now let's take a look at the ways of producing Java server pages based applications. Well, we need to understand how Java server pages work. What's the syntax. And actually, some options there. The use of expression language, the use of CDI beans, tag libraries, and ways of handling errors with JSPs.

First of all, I need to tell you that really a Java server page is actually a servlet. When you deploy the JSP application, each page is actually turned into a servlet first. So in terms of capabilities of Java server pages and what they can do, how they run, they're absolutely identical to servlets. So in terms of the runtime options, it's the same. Got same life cycle, same events. It's exactly the same behaviors.

However, it's obviously a different style of writing the page. A servlet is just a Java class. You code Java. A page is a page. So you visually could edit that. You're working with HTML mark-ups rather than just typing Java code. Of course, the page can contain bits of Java code-- such as this one for example. That is clearly a chunk of Java code. It's sort of cropped into the page structure, and overall it is looking much more friendly to the web designer than the servlet.

So I guess it's an attempt to make the process of designing a page geared more to the tastes of the UI developer rather than just a coder. Now, all the servlet code and techniques are still applicable. So CDI beans and web filters and container lifecycle operations, that's all the same. It's just really all about a different style of coding.

This is the Java server page syntax. So what you can put in a page. You can put in comments. There you go. You can put bits of code that we call directives. Now, there are several types of directives there, page, include, and taglib. We're actually going to take a look at other directives a little later.

But page, for example, that describes global things about the page. So it's, for example, content type, encoding. Well, guess what. That instruction-- page, content type, and coding-- it will translate to a future code of a servlet that will be based on that page, will be created from that page, and that servlet will send the relevant HTTP headers to the client. So setting the content type.

Or, for example, that bit where you would put an import. We're just importing another Java class here. And again, that translates to the code of a servlet. That will just have that piece of Java logic in there.

The overall page could contain just any HTML, really. As you see, it's an HTML document. But apart from containing just plain text HTML things, it can also contain declaration, scriptlets, and expressions. A declaration-- the one with this exclamation mark-- if you put the declaration into the page, that will create a piece of code that goes into the future servlet outside of a method service. So if you want to add an instance variable or create another method, you put an exclamation mark. That code will go outside of the future servlet method service.

If you put a scriptlet-- that's the one with the just percent signs. These are the scriptlets. This is just a bit of any Java code that goes inside the method service. So whatever you want to code, like handling request parameters and any logic.

An expression is basically exactly the same as if you do out print LAN. It's exactly the same idea. So you're printing something back to the client. You could have written a scriptlet, I suppose, which outputs that value. But it could be just an expression. So it's exactly the same as a print.

Also notice if you're writing a servlet and you're writing your service method, you are in full control over what would you like your parameters to be called. HTTP servlet request and HTTP servlet response objects. You can, when you code a servlet, call it whatever you like. You don't have to call parameters request and response.

But in a Java server page, a servlet is formed for you. So the names of the standard servlet objects are pre-coded. And it says here "request." This will be the name of an HTTP servlet request in a future generated servlet. That's what it will be called. So you cannot really change that, because it will be auto-generated for you.

So the standard objects, see here. It's a list of these objects. Request, response, the print writer is called out. Session. The HTTP session is called session. Servlet. Context object is called a page context.

For example, the keyword page is a synonym to the Java keyword this. You could have just typed "this" dot something, I suppose. But then whoever designed Java server pages thought that page will be more intuitive to a web designer who might wish to write some scriptlet code and refer to the current page. So it's basically a synonym page and this. So these are aliases for standard servlet objects.

Now, here's an interesting one. It's an alternative Java server pages syntax, XML syntax. This example is doing exactly same stuff as example on a previous page. There's no difference at all. That's a complete repetition.

But instead of writing directives and declarations and scriptlets with these exclamation marks or equal sign or percent signs, you are using XML mark-ups. They surround the entire document with an element called JSP:root. So that encloses the whole document. And then you put all of the other components like directives.

So remember on the previous page, directive had-- what was it-- it was with an at sign. And then we had the declaration, and that was with exclamation mark. And then we had an expression, for example, and that was with an equal sign. Well, there you go.

So instead of all these signs and exclamation marks and equal signs, you're just spelling it out as an actual XML mark-up. And then in a scriptlet, for example, or in a declaration or inside a particular element, you just put your Java code as usual.

There you go. So you can construct the page as an XML document. That would be a little tricky when it comes to some HTML content in a page because in HTML content, that bit which produces HTML will also have to conform to the XML standard. So you might wish not to create an HTML element, but to create an XML element that describes an HTML element. Might be a bit long-winded, so there you go. But functionality-wise, both syntaxes are achieving the same thing. It's just a different style of writing the page, whichever style you prefer.

Within a page, you can write expressions to access Java code, which could be accessing CDI beans, objects outside of the page. There are two styles of expressions that you could use with a dollar sign, which is known as immediate, and with the hash symbol, pound, whatever you call it, which is the deferred. The deferred expressions are mostly used by Java server faces, and they are covered later. It's down to the way in which the JSF lifecycle works.

Java server faces have their own lifecycle considerations, so they use slightly different expression notation. And immediate expressions are used by Java server pages, which is what we're doing in this chapter. So with a dollar sign for this chapter.

The expressions allow you to access CDI beans, their properties. There are slightly different styles. You can use the dot notation to access a property, or you can use a square brackets and name of the property notation. Well, works whichever way. It's not really different.

You could pass parameters and invoke operations. You could handle arrays, using array indexes. Or even you can write lambda expressions directly into your page with expression language. So there you go. There's more to the expression language. It's this page that shows us what are the main expression language operators.

So for example, dot to access a property, comma as a statement separator, square brackets to access, let's say, array element. Method parameters with round brackets, arithmetic operators, assignment, relational operators, logical operators, and lambda token. So quite a few different operators. So that means that you can put these expressions into your page, and through them access logic in your CDI beans and your objects outside of that page.

Well, what are these objects? You can access things that are in different memory scopes. So that's request, page, session, and application scopes. Access that from your page. You can obviously access all these implicit JSP objects. Remember, we've mentioned them before.

We're saying you don't give a name to your request object. It's given for you. And it is request. So there you go. That's out as JSPWriter, request is HTTPServletRequest, response is HTTPServerResponse, et cetera. So these are the standard servlet runtime objects.

You also have implicit interesting set of objects here that deal with the handling of HTTP content. So parameters, parameter values, header, header values, cookies. So probably one object that I'd like to quickly comment on, and that's initParam. You can put initialization parameters to servlets in a web XML file. So it's not a parameter user that's passing in a URL. That's param. initParam is the bit that you put in a web XML file to pass initialization parameters to a servlet.

And then finally in this corner right to the bottom, we can see the examples of expressions, accessing parameters, accessing CDI beans, accessing some exception messages. So you could put that code directly in the JSP page to manipulate with these memory objects.

Talking of CDI beans. Here's an example. You created a bean. Well, it's request scoped in this particular case. Just for your own convenience, you can use a named annotation. If you don't put the named annotation, you can still access the bean, but you have to use a class name, which might not be that convenient. So the named alias might be more convenient way of accessing the bean. And there you go.

You just can access the bean properties or call bean methods directly from the page. Very convenient. And I suppose, again, this is the way of approaching the proper segregation of model view controller, because then you have your page that focuses on the production of the UI or the layout, and then your beans that are carrying out the logic. And this quite straightforward way of tying up together a page and beans through expressions.

Now, the Java server pages come with a set of standard libraries. They're known as JSTL. And that's Java Server Pages Standard Tag Library. The libraries that come with the Java server pages runtime provide us with elements that allow us to control the logic of the page. Each tag library needs to be declared in a page as a taglib reference. The tag library will be associated with a prefix. So whichever is the prefix, it's up to you. And then you are accessing elements within a library.

Quite a few different libraries, and a lot of elements in them. So I'll just try to give you some kind of example of what you expect libraries to do. And in this particular example, we have a for each element which allows us to create an iterator and step through a collection of products.

Suppose you've got CDI bean called order. Suppose that CDI bean order has a collection of products, some kind of product list. You want to step through that product list, and then you want to get each product out of that list, assign it to the variable called product, var product. After that, you want to get the product's name and product discount.

But you see, the interesting thing is that with discount you want to do some test first. So there's this if condition. You test any discount is greater than zero, and then you display the word sale if that's the case. And as for the product name and price, well, you just output them as is. So c out allows you to just output the value.

This is just an example. Quite a few other elements in these libraries. Quite a few other libraries. They deal with formatting of objects. They deal with logic of the page handling of these objects. So it allows us to code in a Java server page, but without really writing direct scriptlet code. So you're expressing the logic of what the page is supposed to be doing, and yet you're not directly coding in Java.

The more you put scriptlet stuff, scriptlet code, into the JSP page, the more you make it look like a servlet, which will eventually defeat the point of actually creating JSP page in the first place. Why you're not writing a servlet, then? So you're trying to keep the page as declarative as possible where it's more suitable, it's more geared to the visual way of editing that.

Hence you're trying to tuck away all the code, all the complex business logic handling, into the CDI beans and access them via these elements from tag libraries and via expressions that help you to construct that logic in a much more declarative fashion.

Well, we also need to mention that we need to be able to handle errors for Java server pages. Now, this bit at the bottom of the page, do you recognize these lines? Request URI of an error. What is an exception? What is its type?

These are attributes of the request object. Exactly same as we've seen in earlier chapter about servlets, when we're creating a servlet error handler. Well, you see, the Java server page has access to exactly same requestScope attributes, just as the servlet did. So it means that you can create an error page and access all of that information.

The difference, I suppose, is this. In addition to the capability of the server to register error pages in a WebXML deployment descriptor, the Java server pages can also designate a specific error page for a given page. So you're saying there is this page called Some. If something goes wrong in a page Some, you want to call Some error handler JSP. So that's that other page.

And the other page, please note, is marked here with "is error handler true." Ooh, it is. So one page says that the other is an error handler for it, and the other page says, yes, I am the error handler. And I suppose that's when you start accessing the information about the error, and presenting it to your user in whichever nice way you want to do it.

Well, I guess that's it. You see, the rest of the things about Java server pages are exactly same as about servlets. So for example, lifecycle events and filters, web filters, it's all the same. Request dispatchers, it's all the same. So it's just a really different style of creating that layout which we're trying to make as declarative as possible without actually having to directly code within a page in Java as such.

In terms of the exercise, what are you going to do is you're going to change your current web servlet application which shows you the list of products. And you're going to display the list of products in a Java server page, not in a servlet. However, you will still use the servlet for controller reasons.

So the idea is that a search, which products you're searching for, that search will still be executed by a servlet. But then the display of the results will be executed by the Java server page. The servlet can forward requests to it. So we're going to use request dispatchers here.

The other example that you're doing in this chapter is you're creating a ProductEdit page to update products, display the product and give it a user, a capability to update it. Just really for the hell of it to try out a different technique. the ProductEdit JSP page is going to use a web filter as a controller.

So you've got two pages here. You've got a page showing the list of products, and you've got another page that shows the edit capabilities for the product. And the list one is controlled by a servlet, and the edit is controlled by the filter.

In a real world application, you probably will choose one way or the other to implement the model view controller arrangement. You would not use this mix of technologies in the same application. It would probably be an overkill. So you probably will go with either a servlet as controller or filter as controller.

Well, in the exercise you are told to do both just to try out and to be able to compare how one technique differs from another. So you would be able then to make choices in your own development situations as to which technique will be more appropriate for you.

## 2. Practice 8-1: Creating a JSP to Display the Product List - 23m

 
Let's take a look at practices for Lesson 8. During these set of practices, we'll create two Java server pages to display a list of products, but also to date a product. We'll use Product Manager CDI bean to maintain application state. We already have the bean, but we'll modify it a little bit to make it more suitable to be used from Java server pages expression language expressions. We'll use two different mechanisms to control JSP pages. We'll use a servlet as a controller for product list page and a web filter as a controller for the product update page.

Normally, the real world sort of application development scenario wouldn't create that many different types of controllers. You'd probably stick to one type. But just for training purposes, so you'll be able to compare different controlling servlet or web filter behaviors and what are the advantages and disadvantages of each approach, this practice allows you to try out both of these approaches.

So basically, we'll have to restructure the code in the product, at least servlet, a little bit. So it will now not produce output itself, but will do it together with the Java server page. So that's the modification that we need to make.

So just a quick note of how the whole thing looks together. So we have the product list page JSP page. We'll create this one. And this will be displayed in the list products. But the functionality that queries that list of products and handles the parameters, that would be done by product list servlet, which, at the moment, is itself generated in the list of products. But that's not going to be the case anymore. It will just handle parameters and prepare the list together with CDI bean for the product manager and then forward request to the product list, Java server page, and actually display it.

When it comes to updating the product, we'll create a filter that will intercept the added product JSP, attempt to update the product. And again, that filter will talk to the CDI bean or the product manager to actually implement date functionality. It's an attempt to structure the application better, not to mix the layout presentation and business logic code inside a same program unit. So we kind of trust the CDI bean to give us access to the back end part of the system, to the model. And we're using filters and servlets as controllers. And we're using Java server pages as view tier of the application of the MVC.

OK, well, let's start with practice Par 1, in which we create Java server page to display the product list. So what we need to do is modify the product manager CDI bean and also modify the product servlet to change the way in which they're handling the list products at the moment. The CDI bean is already in place. It's already request scope that we could just go ahead and use it. But just to make it more convenient to use that product manager bean from our page, let's add a named annotation to it. So we'll use an alias PM for the product manager CDI bean.

Go to NetBeans, in the ProductWeb project. Find product manager bean under demos model. And just add named annotation. Make sure you've imported Java X. Inject named annotation. So now this product manager has a nice alias we can use from our pages, rather than just using the last name.

What else do we need to do? Well, we also would like to add to the product manager some instance variables that will represent the data that we could receive or send towards the product for [INAUDIBLE]. But also information about errors, if any. If our servlet or filter encounters any problems, so we'll be able to signal to the Java server page presence of errors.

We could have, I suppose, done that coding regarding the querying of products or handling of errors in pages themselves. But what we're trying to do is make pages not actually contain Java code, but just refer to the CDI beans through expressions and handle the rest of the logic outside of the page. So hence, we'll place this instance variables into the product manager page. Whoops, something wrong with my copy, paste. Oh, well, never mind. That'll teach me to copy paste from the PDF rather than properly type things. OK, so that's what that list of declarations should look like.

Now, we also need to provision access methods for these variables. OK, so let's try that in NetBeans. You can just right click on the code and say, Insert getters and setters. I would like to insert getters and setters for errors product, products, and status variables. So anywhere where you want to do it, insert that code. I would like to insert getters and setters for error, product, products, and status variables. Generate. That's it. So we now have this get set methods for all of our instance variables.

OK, now let's modify the product list servlet to prepare that to interact with our Java server pages. At the moment, the product list service contains a block code that gets the parameter and then finds the product and then checks if the product is empty or not and handling the output. Also at the moment, the product list server is actually attempting to print all the output. Well, this is not going to be the case any more. So we'll change that.

First, let's start by opening that servlet. So that's product list. Go into process request method. This is our if else block. So clean these lines out of if and out of else. That's where we start. We still want to get the parameter. We still want to query and find products. But we don't want to actually attempt to produce a user visible output inside the servlet.

Instead, what we're going to do is use the product manager's ability to set, memorize the list of products we just found as part of our request object. If list of products is not empty, then let's memorize it within the product manager CDI bean. That's the getter setter code we just added a moment ago.

In else case, well, presumably, we have a problem. Indicate we have any errors. So product list not found. Do something about it. Don't just produce an error message. Unable to find any products match in a given name. That's as good an error messages as any. Why not?

OK, so that's what happens when we can't find a product. Either way, the status of the find product operation will eventually be recorded into the product management bean either as a list of products or as an information that we had an error. After the else block, place the code inside a process request method and forward the request to the product list JSP, the user request dispatcher. So that's that bit of code.

We don't really need any of these printouts anymore in the product release page. So we may as well get rid of them. Format the code nicely. Of course, we haven't created the product to [INAUDIBLE] JSP yet. But we'll create it. It will just be in a moment.

So our next part of the exercise, we're going to create new Java server page. And indeed, that will be that product list page. Precisely what we're now creating. So in the product web project, we're going to create a new Java server page and call it product list. That's it. Use JSP standard syntax. That's good.

Now what is going to happen within this page? We replaced the code in that from the template HTML just as we did with any other pages. And then we'll replace bullet placeholders with our own values. OK, so let's just go to template file. It's under the homework and labs resources-- template HTML. We can grab that template code. That's fine. Put it into the Java server page, just retaining the annotation above it, to the page part here. And replace the rest of the content.

Replace in the bullet plate text. Page titles should be product list. Page header should be products. Navigation components should go back to the Search page. From list back to search, that kind of makes sense, I guess. What about the footer? Just this code. How we were invoked. We were invoked via method get or post or put or delete or whatever HTML math that was used to call this page. So which method invoker used. Just place that here into the footer.

We still need to sort out the page content. Well, that's still to come obviously. But at least we now have a correct structure of the page here. So you probably noticed that I was using page context object. That is kind of a universal Java server pages object that allows us access to all sorts of different other things, like in this case, requests, for example. So it's a macro object that helps us to get access to environment and, in this particular case, find out which HTTP method the page has been invoked through.

Now we'd like that product list JSP to get information out of the product management CDI bean. A servlet, before forwarding the request to the product list JSP, has placed that information into the product manager bean for us So now we can pick up that information. What we need to do is create here a choose when otherwise condition. Just start typing c colon. Let's do that. So it's in the content section here. If we start typing c colon, press Control space, that will pop up that list, and use selection of choose and observe that a tag library was added automatically.

So we have this choose element. And then we'd like to have inside of choose a when element. And then we'd also like to have an otherwise element. So it's like an [INAUDIBLE] really. Choose when otherwise-- a conditional construct. One should have a test condition. And what are we going to test? Well, some expression that will allow us to tell if we have any products, if we have something to display.

Remember, the servlet it up, a Boolean variable errors if there was a problem querying products. So what we can do is simply test if we encountered any errors. PM is an alias for the product manager bean. Errors is a property there which was set in a product list if there is an issue. So if there are no errors-- exclamation mark means not-- if there are no errors, I suppose instead is one clause we can go ahead and display information about products. In the otherwise, what was the handle the case when there was a problem.

OK, so we constructed that code. Now how to display our products? We need a for each iterator. You can keep constructing it the way I just showed you by typing the prefix and then filling in the properties. But basically, we need a for each iterator to step through the collection of products stored in the product management bean. Call each one of these products from this collection p.

So that will be iterated through products, and every product will be called p. And then while putting that information as product ID, named products best before date, we put it inside the when statement. Let's try that right here inside the when statement-- formatted nicely. Step through the collection of products.

Now finally, what else do we need to do? If there's a problem in the otherwise section, display status property, which is the property inside a product management bean as well. Let me just remind you where the status comes from. It's product list. And a product list sets the errors true and sets the status if there's any you should find in products. So these are the properties it sets to the CDI bean. And therefore, the page can easily fetch these properties.

So what do we achieve in this products list page? We achieve arrangement of a display of a list of products or any errors that may arise if we didn't manage to find these products. But we didn't have to code inside the page anything related to the actual search or to the management of parameters. That was done by a servlet. And a state of the application has been stored in a request scope in a CDI bean.

Because the servlet forwards the request to the product list, it means that whatever we in the servlet placed into the request scope, like we place things injected into the product bean-- that was request scope, wasn't it? Product manager remind ourselves is indeed request scope. That means we forward the same request to product list. Product list automatically is looking at the same instance of product manager. So we see the same information as prepared by our servlet. There you go.

So that snippet of explanation is right here in a practical exercise. We are ready to test, I suppose. What we need to do is just clean build the project, navigate around it, and try to access the product list queried. So clean and build. It's coming right up. And then we need to deploy that code-- product web, deploy. Again, that will come up momentarily.

And we're ready to proceed with the test once the application completes the deployment. So just go back to the URL PM. That's our route of our application. Go to Product search. That's the HTML page, remember. Now it still submits. We haven't changed that page, didn't we? No, it still submits to the list servlet.

But the output that we'll receive will be not from the list servlet. The URL says list, doesn't it? That's what we call list servlet. But list for a servlet has performed the relevant search and then forwarded a request to the product list JAVA server page. So if we try to search for a product that's nonexistent, well, that product will not be found. Can't find products matching that name. Fair enough.

Oh, and what will happen if we try to access product list JSP directly? It will not show us anything. Because the product manager bean will have null property for the product list. And by default, the value of the product [INAUDIBLE] Boolean is false. So it says, there's no products, there's no errors, nothing is happening. It's not displaying anything. Why would it, because the servlet that is supposed to intercept requests towards it has never been invoked. It's when we submit the form-- that product search form-- then we invoke in the product list servlet. And then it forwards the request to the JSP page. And then it displays all the relevant information.

OK, so that's precisely what that commentary here says. Yeah, if you just directly call that page, you would not get any relevant content. You can always test for a non-existent product and see that it will display you're in error. OK, that's that.

## 3. Practice 8-2: Creating a JSP for Editing a Product - 33m

 
Let's proceed part two of the chapter 8 exercise. In this part, we're creating a web filter and a Java Server Page to manage product updates. We'll start by creating a web filter. So in the product web project, create a new Java class, which will be our web filter. I'll call it EditProductFilter. Place it in demos web package. New Java class. EditProductFilter, demos, web package, that's it.

Of course, this is just a regular class at the moment. We need to turn it into the web filter. And to achieve that, we need to do a couple of things. First of all, we need to make sure we implement filter interface and provide code for init.destroy doFilter methods. We'll do that. So implements Filter. OK. And import Javax_server.filter. And implement all abstract methods. Right, well at the moment they have some dummy method bodies, but we'll replace them with a [INAUDIBLE] code a little later.

We also need to map that particular filter to the URL of the product EditJSP, which we're about to create again a little later. So web filter mapping needs to be added. Make sure you've got an import of Javax servlet annotation web filter. And you're good to go. We intercept in the URL part of the product EditJSP. Now we need to inject a product manager bean, because that contains whatever logic of our model. It gives us access to our business logic. So we need that here as well. That's Fix Import statements, reformat the code, there you go. So we injected the product manage to bean into that filter as well.

OK, also add another instance variable, which is the FilterConfig. And inside the init method, initialize that variable. FilterConfig, inside the init method. We don't want to remove that-- well, we want to remove that exception, and we want to initialize that config. We have it as a parameter right here in the init operation. So just initialize it as an instance variable.

OK, inside to destroy method, simply remove the line that throws an exception. We don't need any particular cleanup. But it won't-- we don't want destroy method to actually just throw us exceptions. So remove that line. There's nothing particularly that you want destroy method to do. So I can just leave it with an empty body for now. The doFilter method, while that requires further attention, again, we need to remove the line of code that throws an exception.

And then we need to cast HTTP request to-- sorry, we need to cast servlet request to HTTP servlet request and servlet-- because the filter accepts servlet request and servlet response subjects, rather than HTTP servlet requests and servlet response objects. So if you want to operate on anything that's, you know, HTTP servlet specific, you need to take that servlet request and cast it down to the HTTP subtype. So make sure you've added that import. You may wish to do something like that with response as well, but I suppose if we would like to produce some output, then you would operate on response. But really we don't need to manage any output from that filter. We just need access to request object, that's it. Yeah. But we don't really need access to response object at that stage.

OK, now, on the next line of code, let's extract product ID parameter from that filter, from that filter from the request object. So we cast it. Request object type, and we're getting the product ID out of it, out of that request. So presumably, whoever calls the future product added page will be-- that call will be intercepted by the filter, and the filter is looking for these parameters. Because everything in HTTP protocol is transmitted as text, you may wish to parse that string parameter value and convert it to an integer. OK, so we did that, yeah? Getting now our ID.

Next, use that ID, and a product manager [INAUDIBLE] bean to query a product object. Make sure you add appropriate import. So we found our product. Lovely. Next, let's do some checks. Did we really find the product? It may be we didn't, or maybe we did. I don't know. It's just we need to verify, yeah, with a simple product is null or not. Check. If we manage to find it. If we did not manage to find a product, and it's null, set up in the product management bean, the error status is true. And then the error message, the product not found, else memorize the product management against the product management being this product that we've found. So very similar to what we're doing with the product list, but we're doing it now for an individual product. Queried just one product here.

Right, well, further code will have to be added there to this else block, right? And that's done on the next step of the exercise. This next step, we need to extract product update barometer submitted by HTTP post. We need to figure out if we need to do the query of the product or do we need to update the product? What is the current action? See, when a filter intercepts the GET operation, I don't think we really need to do anything else. We just proceed to the product added page and display that product. That's it.

But when the product added page submits the product update, it will do it using a POST method rather than GET method. So that's the idea. If you call the product added page with GET, display the product. If you use the POST, then the process, the product update, that's what the filter will do. And in order to achieve that, the filter will need to check if the call was GET or POST. And this bit of code, yeah, checking what HTTP method was, goes into the else block here.

So we're trying to figure out if it's method GET or if it's method POST. If it's method GET, which it might be, then the product is already memorized against the product management bean, so we're ready to display it. Or there were some errors, were added display errors. There's nothing else we need to do. But if it's POST, then we need to process some date. So let's do that.

Extract product name, product price, product date, would presume that if it's method POST, then the request will contain these bits, yeah? So we need to get information about the product now. And then we can use these values to update the actual product. Just make sure you convert them from base extreme types to appropriate other Java types. So you need to perform a conversion. For that, I'm afraid you'll have to write a try block in which the conversion would occur, and you might need to catch some exceptions, you know, if conversion goes wrong, right? If you got a number, or if you got a date format problems, OK. So that would be right after the extraction of these parameters. You had a try block. You add these catches. Lets me just format the code nicely and make sure we've got all appropriate Java time format daytime parse exception, yeah, imported into our code.

So these are the possible outcomes. We may parse. We haven't added that code yet, but we will add it here. We may parse parameters successfully, or we may encounter errors, in which case we use the existing product management bean mechanism to [INAUDIBLE] the error, OK? Now, parse in itself, it's pretty straightforward. Yeah, oh, and one more catch block. How can I forget? That's important. So that's any other errors, yeah, potentially that we may encounter. Because we're going to do the date there as well. And obviously we may have other problems that are related to constraint violations or related to optimistic lock exceptions, or whatever other issues we may potentially encounter in that try block, because that's where the processing will happen.

So further logic of handling that other exceptions would be placed in here. And that further logic really is what you've observed in early exercises before, which is the constraint violation exception and optimistic lock exceptions. OK, so you know that part already, because you probably encountered it in earlier exercises. Again, keep format in the code nicely and ensure that you have correct imports, yeah, of the relevant exception classes. If you've got a constraint violation exception, this is what we'll do. We'll construct a new string builder, saying that we have an error updating the product. OK.

So constraint violation exception, string builder, error updating the product. This will prepare a string builder object to construct further error code, if necessary. Because remember, constraint violation exceptions, they may be thrown in batches, if you like. You know, there might be more than one constraint violated for the same entity. So you may have several of them. And that's why we need to process potentially a stream of different constraint violations. So we cast the constraint violation exception, the cause object to the constraint violation exception type. And then we iterate through the stream of possible constraint violation reasons, yeah, and append each one of them to that string builder. Yeah, so keep appending these error messages, because potentially may have pleural constraint violations.

OK, and then that constructs that string builder, constructs the text. You convert it to string. And then you set it to a product management bean as a status, yeah? So if you had any constraint violations, you construct the text and you set as a status. If you had an optimistic lock exception, it's a little bit easier. You just set a status that product has been changed by another user. That's it, yeah? So you don't need to iterate in that case through the whole collection of possible issues. That's it, I guess, in terms of air handling. So what could go wrong? Number, date, format, parsings. Constraint violations, optimistic locks, or anything else will just throw the exception.

Now let's proceed to handling of the logic and the try block. We need to construct product properties, setting their product name, price, et cetera. So name does not require any further conversion. You can just set the name. OK, what about the price? That requires the conversion. Our taxed value of price that we've extracted a moment ago from the URL, import big decimal of course, needs to be converted to big decimal before we set it to price. That was pprice, which is right here. Yeah, that's that parameter that we handled. And similar to that, we need a conversion of date, yeah? Best before date. But there is a little trick to it.

You probably remember that the date column in a table is actually optional. So there might be a perfectly valid circumstance when date is not present. It's now. So if you perform the conversion unconditionally, you're going to end up with an error in that case, and you shouldn't. You should just check if the date is null or not. And based on that, use the date-time formatter to perform the conversion of text to date. So that's our next [? beat ?] in this try block. Before we convert date, we check if it's null or not. Fix imports, of course. OK, pdate, length for example might be 0, and we'll add an empty field, yeah? And it's perfectly fine. We should allow that empty fields to be submitted, yeah? We just don't set the date in that case. There's no best before date.

Otherwise, if the values present attempt to use the date formatter with this particular date part, then set it as the best before date as local date for the product that we are updating. Make sure you've added correct imports. Now, if everything is fine, just go ahead, update the product, and set the status within the product management bean to indicate that everything is fine. OK, so we've set all the product values. We didn't yet encounter any exceptions, and yeah. Just say no errors. Product updated successfully. Good. At the end of that filter code, don't forget to call chain DoFilter. Because without it, you would not pass the request onwards to the next page to that product EditJSP. So you really, really need to make sure you're doing that DoFilter right after you finished processing the rest of the page, yeah?

OK, so it could be done just at the end of the DoFilter method, which should be some place here. Yeah, chain.doFilter. Yeah, I think so. Just let me check where the curly brackets are. Now, that's the end of the else. No good? I didn't count the curly brackets correctly. Let's try again. This line down here. Oh yes, of course this line. It is aligned, yeah, I could see it now. Right, so I'll pass the request on to the next filter in the chain. Well in this case, that's the only filter in the chain. So the request will go to the page that this filter is mapped to.

Clean and build. I suppose we're ready to proceed to the testing phase. Just after we create the page itself, right? So clean build, create the page, and then we'll be doing some testing. Well, we added quite a lot of code. That's why we do an intermediate compilation. Because yes, of course, we created a filter, but we didn't yet create the page to which it is mapped. So for the product web project, our next task is to create a new Java Server Page, call that page ProductEdit. OK, let's do that. New Java Server Page JSP, yeah, call it ProductEdit. That's it. Finish.

As usual, the contents of this page should be replaced from the template, yeah? So make sure you grab that content from the template first. And then we'll replace the title and a header with edit product, Yeah? So template, if you haven't opened it yet, open it. It's in resources folder. Take the code of a template, replace that chunk, leave the page part there. And then it will be added product. Repeat that again in this header section. So nicely done.

Navigation, back to the search page as usual, yeah. So put that navigation in to go back to the search page. And the footer. The future should just-- I suppose let's do the same thing as the previous page was doing. Just tell which HTTP method we've been invoked with. I suppose it makes it more informative for us as developers for a moment. Of course, this still leaves us with unhandled content. So what should we do with the content? Well, a bit of a conditional processing will be [? due. ?] We want to add an if statement here. So remember how it could be done. You go to the content section, and you start here typing C column, if, yeah? You can press control space to complete the code, and that inserts the taglib reference for you.

So what that if condition should be doing, it should be testing the status of product code, yeah? [INAUDIBLE] just probably copy that, yeah? So testing of status of product code for product management bean, the status of current interaction. If we have any errors, yeah, you know, we will know if the status is not now. We don't need to display any additional messages. Your status is-- say it again, if status is now, we don't need to display any additional messages. If status is not now, then there is a message for us to display. Then that filter has set at some message to the product management bean. So we're just trying to figure it out if that was the case or not.

Depending on whatever, it was an error message or not, we may display differently. So inside this if element, let's add a divider that decides on the nature of the message. And this is really interesting. Look at this code. We interrogate the product management bean. We'll look at the errors attribute of product manager. Remember, it's Boolean attribute. So, and based on that value of a Boolean element, we either, if it's true, set the visual CSS class for this divider to be error. And if it's false, set a visual CSS class for this divider as info. And then display the status message. So status not now, see if this status indicates that it's an error or not. And then based on that. Choose the style, and display the status information.

OK, now let's design an HTML form. And this form is going to submit the request back to the same JSP page. So after this if statement, create a form which submits itself back to the same page. Remember, this URL of this page is actually intercepted by a filter. So filter will react to the method POST, wouldn't it? And will say, oh, well, somebody is posting changes. Let's process the update. That's the idea.

OK, so method POST, and then you add some fields. You need a field for product ID. That will be read only field. You're not going to change the primary key of the product. That stays read only. OK, so add to the form product ID. And that's just a divider, style class field with label. And [INAUDIBLE] referencing product manager, product ID, as the value of that field. OK, and then you need fields for all other product components. So you need a product name, and that will be required field, by the way, yeah? It's mandatory. So keep adding them. I'll format them in a moment. And then you need a label and field for price. So again, another required field. So we'll put that in. And finally, best before, and the best before is optional. So that is not a required field.

Reformat that code, yeah. Once again, let's just try to check what we're doing. So we have prompt and field representing every property or the product. ID read only, name and price required, date is optional. And a submit button. We want to submit the [? form. ?] Get in there, right? So it's just a simple update button. Now, one more small modification. In a product list page, we want to create a reference to the product edit page. What we want to do is replace the product ID that's currently displayed in product list with a clickable product ID. So product ID stays on the page, but it will be surrounded with a link towards product edit page, [INAUDIBLE] that product ID as an argument.

Obviously, such href is going to be submitted with method GET. And remember what's happening when the product edit page is accessed by a method GET? A filter simply queries the product. And it's not trying to process update. It's just looking at product ID, and it's just executing the query. Ah, so if we put this into a product list page, product list JSP, open that. See whereabouts you're displaying the product ID, and replace that with this reference to the product edit. That would make the product list items clickable, and we'll be able to navigate from the product list to the product edit page, query that product, display it in a form, and when a form is submitted, it will be submitted also to the product edit JSP, but with method POST, which, either way, will cause the request to be intercepted by the edit product filter. But it will only process update if the request is POST. Otherwise it will process the query. It will just find the product with a given ID.

If it's method POST, it still finds a product with a given ID and to be able to apply name, price, and date, yeah? OK, well, there you go. All you need to do is do the deployment, and you're ready to start testing. So compile, do clean and build, yeah. Once that compilation process is over, then we will deploy the product web application. Again, wait for deployment to complete. Make sure you've got no deployment errors at that stage. And once that's done, we proceed to testing that application. So testing procedure looks like this. Start with the root page, right, which is the index. From there go to product search. Try to search for products with the particular names, yeah? And then actually let's try to update something.

OK, so into the browser. You could start from home page if you like, yeah? Go to product search. Try to find products with particular names. That displays me the product list. Notice that they are now clickable URLs, yeah? OK, so let's click on, say, cookie for example. And there you go. You can now process the update. Let's now make that cookie survive for a day longer. So I change that date, for example, and I can, I don't know, change the price or whatever I want, yeah? Update. Product updated successfully.

Let's make an error. It's trying to make this cookie. Yeah, violate constraints. Taa-daa, yeah? You've got all of your constraints coming through. Remember they are in the JPA behind the enterprise Java bean where they're propagated through the product management bean, and then the filter makes sure that it puts that information into the current request object into the product management bean for us to display. So the page has that simple if condition that says, if there are any messages, success or fail or whatever, display them. And CSS style renders a different border, green or red border around it, yeah? So we can ensure that we are correctly processing our components.

If you want to do any other tests, it's just like you've been doing it so far with the other labs in this application. You can open SQL console. You can simulate optimistic lock exception. You could see what happens if you change fields. And yeah, so just play around with that if you like. But that basically concludes Practice 4, Lesson 8.

## 4. Skill Check: Creating Java Web Applications by using JSPs - Score 80% or higher to pass

Skill Check: Creating Java Web Applications by using JSPs

View Skill Check
