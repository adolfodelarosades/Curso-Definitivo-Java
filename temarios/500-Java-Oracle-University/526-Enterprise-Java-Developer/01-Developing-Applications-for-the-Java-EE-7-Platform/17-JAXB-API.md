# 17: JAXB API

1. JAXB API - 11m

## 1. JAXB API - 11m

Now, let's take a look at the JAXB API. JAXB API is something that we could use in various areas of the Java EE code and Java SE as well, I suppose. We could use it to convert XML objects to Java and Java objects to XML. A good example of that could be web services, where we are actively doing this Java XML conversions.

So in this chapter, we're looking at exactly how do we map XML objects and Java objects and how to marshal and unmarshal-- convert the Java object to XML forward and backwards. Well, first, how do you create JAXB mappings? What are the JAXB mappings?

Imagine you've got an XML schema. So this schema describes some kind of elements called product. It has some type, whatever, yeah? So this is your schema.

And then you want to map that to a Java class. So what you know, it could be as symbol as this. You're just saying that product will be your XmlRootElement. In a very basic way, that is really sufficient.

It's a very simple mapping. In this case, we just have a product that has product ID. That's it. But it is the way that this class is formed. And it's the way that simple schema is formed. Later on in this chapter, we're going to take a look at more advanced mappings. But that's a first sort of snippet as to how it's done.

Then documents type of that schema, such as that product document, can be unmarshalled and marshalled in and out of Java code. So basically, they could be converted into Java objects. Or vice versa, you can take the Java object and convert it, marshal it to the XML document format. So the class and the schema are mapped. The objects and XML documents are marshalled and unmarshalled according to the class schema relationship mapping.

Now, you don't have to code JAXB mappings by hand. I mean, you can, but really, you can automate this process. There are a couple of utilities you could use. There's a utility called schemagen. And that allows you to take a Java class, such as that class product, and generate a schema out of it. So based on whatever product class has and its structure or its components produce a scheme for you. So you don't have to write the schema by hand.

The opposite-- the other way around process is once you start with an XML schema. So you construct that first. And then you ask the utility called XJC to generate you a Java class that will correspond to that schema. These utilities produce the actual class, in this case, but also there will be some extra helper classes, like the ObjectFactory and package-info, that are used by the JAXB API to facilitate the marshalling and unmarshalling process. So they are basically autogenerated for you.

Still, even though you may use utilities to automate the process of mapping Java to XML and XML to Java types, you may wish to exert more control over exactly how the elements and bits there are mapped. And we're going to take a look at these more advanced mappings a little bit later.

But first, how to do the actual marshalling and unmarshalling-- so you have it mapped-- yeah, OK. You've got an XML schema. You've got your class. Fine.

Now, let's just create an instance of product-- there it is-- set some attributes to it and then use JAXBContext object, create a new instance of that, use in a Product.class, and createMarshaller point to whatever OutputStream you fancy-- in this particular case, just a simple file and marshal an object.

Now, creating an XML file that is of that structure, I suppose instead of file, it could have been some kind of a stream, where-- I don't know-- you write that into a network maybe, if you want to sound that to some service. So there you go. And the opposite process, you createUnmarshaller.

You connect it to an InputStream-- could be a file, could be a network stream, maybe, you're reading information from somewhere. And you convert that XML content you're getting from the stream to a product, which is that mapped object of yours. So marshalling and unmarshalling is pretty straightforward.

Now, let's take a look at how you can control exactly what it is that you're mapping in Java and XML worlds-- two pages, JAXB Annotations, Part I; JAXB Annotations, Part II. You probably would like to use annotations for that. So first of all, naming-- you may decide that your class name and you element name should be different. It might be just a case. It might be just a different word. It's up to you.

So when you're mapping the RootElement, you may say, well, I'd like the name to be this or that. And just generally, if you map whatever element, you may wish to override the name. So in this particular case, name is still the same. It's id in both occasions.

But it could have been different. That's the point I'm trying to make. You control what name of an attribute you're actually using. So that's that name. There you go. Or in a product case, that's that name.

You can also give a name to a type, which describes the product structure. So this type is called XmlType productType-- so create a named type. And then describe the order of elements within that type.

So you're saying, I've got a sequence of elements where the id comes first and then comes the name. So you're specifically saying, the XML file has to contain elements in that particular order. They must not be swapped around.

You can also say that certain values on your Java class are to be represented not as elements but as attributes. So that will cause the schema to contain an attribute price rather than the element price. There you go. That's what will happen in results in XML file. That particular value is going to be represented not as an element but as an attribute.

Oh, and yeah, and XmlTransient switches off that marshalling and unmarshalling for a certain attributes. So you're saying that you'd rather not save the discount into that XML file, because you think it should not be there. So you're not mapping that to anything in a schema. So that's annotations part I.

JAXB Annotations, Part II-- our XMLValue annotation and XMLEnum, let's start with value, because it's rather simple. In this particular case, the name here is annotated with XmlValue annotation, which causes that name to be written as a simple text. So it's not really an element called name. It's just the text inside a product element.

Another interesting example here is the use of enum. We create in an XML schema this ProductState, which corresponds to the enum. This is the annotation-- XmlEnum.

And basically, we're saying that we'll have XML values of HOT, WARM, and COLD. Well whatever they are, it doesn't matter. That's how they will be expressed in XML. So restriction really, it's a list of values that is available for that particular element.

And then we have an attribute-- attribute state-- that will use that product state as the type. So ProductState is that type. And this is the result. We have this state attribute.

Oh, it could be element, it could be attribute. But in this case, it's an attribute. Yeah, having values of H, W, and C that correspond to the [INAUDIBLE] Java enum values.

I think it pretty much it. So we've looked at the way in which we can represent Java objects as XML or XML files as Java objects, control the mappings. You could just start by annotating Java classes, I guess, and then generate the schema or vice versa, depending on which direction you want to go. You may start with a schema and ask the XJC utility to generate your classes.

But this is what you expect to find in the code, how you control exactly which way the Java value is translated to XML and vice versa. Use it in a variety of different application areas, predominately, I guess, in web services world, with SOAP services, maybe with REST services-- I don't know-- anywhere where you need to perform Java to XML conversions. That's it.
