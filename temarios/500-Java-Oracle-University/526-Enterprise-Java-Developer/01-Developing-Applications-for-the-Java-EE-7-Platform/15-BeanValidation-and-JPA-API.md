# 15: BeanValidation and JPA API

1. BeanValidation and JPA API 33m

## 1. BeanValidation and JPA API 33m

Let's take a look at the next appendix, which covers two topics. It's a short bit about bean validation API. Basically, how to construct custom validator. And then, it goes into more advanced areas of JPA, Java Persistence API. Well, let's take a look. First, how to create a custom bean validation constraint. So that's one thing we cover. And then, we go to the area of JPA and we talk about entity relationship mappings. So how to basically map things like foreign keys in a database to relationships between entities.

How to map a composite primary key, which is comprised of more than one column. Maybe that's important. I don't know. How to map embeddable classes. We'll see how they are used, as well. And how to map entity to more than one table. There are several cases, several reasons, as to why you want to do it. And therefore, several different ways in which you can do it.

Well, step at a time. Well, let's talk about creation of a custom bean validation constraint. In this example, I'm creating a constraint that essentially groups several other constraints together. So I want to have this product code annotation so I wouldn't have to repeat these group of annotations-- ID, not null, pattern-- every time that I want to apply this particular set of constraints to my code. So, therefore, I created a custom constraint. Call it ProductCode. Associate it with some kind of a message that is what you'll put into the resource bundle properties file to customize the error message you'd like to use for that particular constraint. And basically, could be just a group of other constraints that you produce and attach to your items.

In addition to that, should you wish to do so, in a constraint annotation here validated by property, you may put here a class that contains programmatic way of validating that particular constraint. So if you're not satisfied with what you can achieve with existing constrained mechanisms, then you could just create your own method, basically, and run your custom validation in addition to that. So there you go. That's how you create a custom bean validation constraint.

Now, we'll change subject a bit, and we'll move on to Java Persistence API. And we'll talk about the ways in which we can map relationships between our JPA entities. Typically, relationships between JPA entities would correspond to database foreign keys. So they represent relationships between tables, basically. Now, unlike foreign key in a database, an entity relationship has to consider the fact that it's in the object-oriented world. It manipulates with pointers. So it has, apparently, two sides.

One side is mandatory. You have to have it. It's called owning side. The other side, inverse side, is apparently optional. You may or may not have to map it. So it's your choice. With a foreign key in a database, the mechanics of it are very simple. It's a primary key matched to the foreign key just by saying, the value is the same. Therefore, this record refers to that record. But in an object world, the value match is not how objects reference each other. They need to use a pointer.

So, for example, if you want a customer to point to order or you want order to point to a customer, how would you do that? Order pointing to a customer, that way, you can to use inside order a simple variable type of customer, right? The other way around, if customer wants to point to orders, how many orders the customer can order? Oh, many, huh? Well, there you go. So maybe customer needs some kind of collection of orders.

So the side where the order points to a customer is the owning side. That's the owning side here. And the customer that points to a collection of orders is the inverse side. So that direction, from one to many, you map it if you wish. But the direction from many to one, the direction from order towards customer, you have to map if you want to have that relationship between entities. That owning side is apparently mandatory. So it's at least uni-directional, but it may be bidirectional should you wish to have a capability of go in from the customers to the orders.

With regard to how they work, if you want to update the relationship or create a value, you have to update the owning side. So you have to go to the order and set the customer. The inverse side, the collection of orders within the customer, is automatically refreshed by the entity manager. So the inverse side is mirroring what it is that you're doing on the owning side. You cannot update the inverse side. You cannot go to the customer and change that collection of orders there. You have to go to the order and do whatever you like with a customer reference there, and that will be reflected in the inverse side, as well.

Now, apart from this many-to-one and one-to-many relationship, we could also build one-to-one relationships. And this is an example of one-to-one, product and image. Imagine that for every product, you store a picture. OK, so product is associated with single picture. Each picture is associated with a single product. Its essentially a one-to-one relationship. How it's physically implemented in the database? All you need to physically do is decide whereabouts your primary key going to be, and then make the foreign key a primary key in the other table, as well.

So, for example, if order-- sorry, if product has a primary key of ID, then you can create this product ID in the image, which is your foreign key, and make that primary key of an image, as well. That's it. That's one-to-one. You wouldn't be able to have more than one value of that product ID in the image. So they are equally unique. And funny thing, the order in which you do it is completely up to you. So you can change your mind about where that foreign key is. It could be in the product, or it could be an image, whatever you want. It doesn't really physically make much of a difference. It's whatever you prefer.

So that means that the owning side could be inside a product or could be inside the image. I suppose it's whichever way you find it more convenient to update. If you want to update the product to set the image for it, you make the owning side there. Or you could do it the other way around and maybe set the product for an image. Then, you make they owning side on the image side. So owning inside is basically where the foreign key is. It's quite simple.

Lastly, many-to-many relationship. Imagine you've got product and order intersecting in the Item table. And what we're saying is that if the Item table has some kind of order ID and some kind of product ID and no other attributes-- so these are two foreign keys, and there are no other attributes. And they're probably two parts of the primary key of the item, as well. So Item has a primary key composed of these two components. Then, actually, why would you want to map an item entity? There's no point. It doesn't have any meaningful attributes of its own, so what are you going to do with it?

Instead of mapping the item entity, you create a many-to-many relationship between the order and a product. So you have one entity less, simply because you figure out there are no attributes there that you're really interested in and its primary key is purely comprised of these two foreign keys. So that's it, then, yeah? It can easily be mapped as a many-to-many relationship.

In a one-to-one and many-to-many relationship cases, the owning side is up to you. You may put the owning side there, or you may put the owning side there. Owning side, remember, is from which side would you like to update that relationship. Do you want to go to the order and set the product, or do you want to go to the product and associate it with the order? Whichever way you want to do the data manipulation. So that will determine where the owning side is.

Now, that was a piece of theory. How do practically do it? Next page. This is how. So these are your tables, and this is your Java code. Let's start with the first relationship. Let's take a look at the Customer and the Order. So from Customer towards the Order. We go into the Customer entity, and we're observing that this, apparently, is an inverse side of the relationship that is mapped by the Order. Order maps its relationship to the Customer right here, I say, and it's many-to-one. It's using a foreign key called cus_id, join column, and then it declares a variable called customer. And on the inverse side, all you need to do is say one-to-many mapped by and match this variable name. That's all.

So Order points to Customer. That's the owning side. Customer points to Order. That's an inverse side. There you go. Owning and inverse sides. So that's done.

Now, let's take a look at, say, Product and Image, yeah? OK, where is the owning side here? Well, apparently, it's in the Product, isn't it? Join column. Yeah, that's pretty straightforward. Remember, we can reverse it whichever way we want, because it's entirely up to us what do we think is the primary key, where do we think is the foreign key. It doesn't matter, because they're kind of equal here.

So one-to-one relationship. The owning side says join column, which column that is. Essentially, it kind of creates that idea as a foreign key, funny enough. Because it doesn't matter. It's a one-to-one relationship. Then, the other side is treated as a primary, so mapped by, and then you match that attribute name image. You're saying the owning side is out there.

Lastly, let's take a look at many-to-many mapping. We don't map the Item entity at all. We don't. Instead, we map the relationship between Order and Product. Where is the owning side? Here, join table. Describe that we are joining Orders and Products through the table Item and describe these two columns, join column an inverse join column. So these are these two columns, right? And on the other side, on the inverse side, all we need to do is match this name right here. Many-to-many mapped by the owning side called Items.

Oh, and please note it's a set. Set of products, set of orders. Set, remember, is a Java collection of unique elements. You don't want them to repeat, right, because both these parts, order ID and product ID, are parts of the primary key here. There you go. These are the entity relationship mappings.

Next, there are some interesting properties you may wish to consider when mapping entity relationships. First of all, a very simple one-- ordering. You know, if you want that list of Orders to be ordered by whatever property. Why not? So Customer will give us a list of orders ordered by date created. You can actually list multiple attributes, if you like.

Now, there's a bit more to it. Next property I'd like us to look at is the property called orphan removal. The meaning of orphan removal is this-- when removing a child from the collection and you're saving the parent. So you're disassociating customer and order. You're not deleting the customer. You're not deleting the order. You're just saying, the order was pointing to this customer. Now, it's not. I know it's strange, but suppose that's plausible business case-wise. That's probably not the best example of such a relationship.

But if your foreign key is optional, can you set it to null? That's basically the question. So if the order can exist without being pointed to the customer, if that's plausible, should you leave this order in a database without being referenced in a customer, or should you actually delete it? So orphan removal true means delete it. Don't leave the orphaned order if you just remove the customer towards which this order was pointing.

The other one, cascade remove, is kind of the opposite of orphan removal. Cascade remove says, if I delete a customer, should I delete all of the orders? So see, orphan removal didn't delete the customer. It's just de-referenced it. Cascade removal actually deletes the customer. And then you're saying, yeah, I want to get rid of all the orders, as well. It's quite destructive, so be careful with these properties. But if you wish to set them, you can.

Finally, fetch, eager or lazy. When you are selecting your entity from the database, querying the record, do you populate all of the entity attributes? When I select the customer, do I query all of the orders of the customer? Well, actually, by default, I don't. The JPA framework will not, by default, query the list of orders for the customer. Only when you access it, but not when you just selected the customer.

That is called lazy fetch. Because otherwise, if that won't be a lazy fetch by default, then you will be in a situation when you query a parent record and, with it, you'll query the entire database. Everything that's a child of that record will be automatically eagerly fetched. That's probably too much.

So the child records are queried only if you access that collection, if you're actually trying to do something with it. Otherwise, they're not automatically queried. That's a lazy fetch. But you may change your mind about it and make it eager fetch, if you like.

Now, normal entity attributes are eagerly fetched, just regular entity attributes. Also, the many-to-one relationships. For example, if you query the order, a customer to which this order points is automatically queried together with the order, but not the other way around. The other way around is lazy fetch by default. So for collections, for one-to-one, one-to-many, and many-to-many relationships, the default fetch attribute is lazy. And as you can see in this example, you may certainly override it if you wish to do so, considering the performance implications that may arise from that.

OK, that's it for relationships. We're changing the subject, and we're looking at the mapping of embeddable classes. Imagine that several different entities would like to use a collection of attributes as rather similar. So you don't have to map these attributes over and over and over again. You can just create one embeddable type, encapsulate the attributes you want into that type-- say address-- and map that address as embedded type together with whatever entities you want. It's pretty straightforward, isn't it? So helps you to recycle the code. You're reusing that address type whereabouts you need in your program.

By the way, to treat the embeddable object as a normal attribute, you may also provide, in addition to that-- that's optional. It's up to you, but if you want to, you may provide converter for embeddable objects. So that would allow you to treat it as if it's a single field and then convert it to multiple fields for the converter. Or vice versa, take multiple fields and sort of scramble them into one single field, which is address. So there you go. That's recycling of the mappings throughout a number of entities, creating an embeddable type.

What if you want to map a entity to more than one table? Product and image is a good example. Physically, in a database, I decided I'd like to store the image in another table, for whatever performance reasons, maybe. Doesn't matter. But when I map it as an entity, I'd like product to have image as an attribute, not as a relationship to another entity. All right, well, we can do that. And this is done with an annotation called SecondaryTable. You decide how you want to join them, and there you go. Your image became an attribute in a product. However, once it became an attribute in a product, it's now eagerly fetched, is it? Oh, yes.

So this is an interesting example, overriding the fetch annotation for an attribute, making it lazy fetch. Why would you want to do that? Because maybe the picture is just big. So you don't want to download a bulky image from the database every time you fetch the product. You only want to load that image if you actually access that picture attribute. So that that's why you may turn it into the lazy fetch. Oh, and another thing that was demonstrated in this example, which is unrelated, is the mapping of the blob column. Yes, so it's a binary column value.

Now, what if you need to map a primary key that's comprised of more than one column? In this particular example, let's imagine that every item is identified by the order ID and also the line number. For example, order 101, line number 1. Order 101, line number 2. So the combination of order ID and line number form unique identity of the item. Usually, database designers try to avoid using composite keys, but sometimes they do. And it's not entirely without its merits. So it's rarely used, but it's used.

So what do you do about it? How do you map a primary key that's comprised of more than one column? You've got a choice. You could map it as embeddable type, the example on the left. You create an embeddable type which contains relevant parts of the key-- order ID, line item. And then, you just create a single attribute matching that type. It's called item ID, yea? And you mark it as embedded ID.

Alternatively, you can create an ID class. There it is, item ID class. You need to provide here, of course, all these methods to ensure the uniqueness of each ID, so you need hashcode and equals methods. Yeah, override them, to compare the order ID and line items to make sure they're actually unique. Anyway, so you create an ID class, just a regular class, really. And then, on the entity, say which ID class would you like to use. Match the class name. In this case, you've got separate attributes. These are matching parts of the key in the ID class.

It's entirely up to you which way you want to do it. Do you want to have a single attribute in your entity, or do you want to have as many attributes as parts of the key? If you want to have a single one, do the embedded ID. If you want to have separate attributes in your entity, do the ID class. Whatever you find more convenient.

Now, we're looking at another interesting part of this appendix, which describes the rationale behind why would you want to create inheritance, class extended in another class, with JPA entities. What are the reasons behind this sort of coding style, and what are the possible options as to how you may implement it? So there are three use cases here. You may wish to create inheritance purely from object-oriented point of view. A class extends another clause because you want to inherit some methods or maybe some transient attributes. In other words, your parent is not itself a mapped entity. You just want to inherit from it not mapped columns but just methods and maybe some transient stuff. So that's one case.

Another case when you want to map parent as an actual entity and children, as well, that's done with a MappedSuperclass annotation. We're about to look in the example in just a moment. And finally, what if you want to map both parent and child entities to the database to represent different record subtypes? Well, let's take a look.

So, first, transient example. I create here a class-- it's not an entity, just a class-- called TradeItem. Maybe it contains some transient attributes. I assume I don't have a discount column in the table. And maybe it contains some behaviors, such as calculating the discount. And all I do in my entities, I say I'll want to extend the TradeItem, nice and easy. Product or service are mapped to some tables, whatever they are, doesn't matter. And they may have different or same attributes. Again, doesn't matter. What's important is that they both inherit the ability to have a discount. That's it. So you don't repeat that code. It's a simple code reusability trick.

Now, this class doesn't have to be abstract. It doesn't. The reason why you mark it as abstract, why you wish to do that, it's optional, so you would not accidentally pass the TradeItem instance to the entity team manager. Because the entity manager wouldn't have a clue what to do with it. It's not mapped as an entity. You can ask entity manager to work on a product or to work on a service, but you can't ask the entity manager or query components to work on TradeItems. Because you only inherit transient attributes and behaviors from it. So that's a UnmappedSuperclass, very straightforward.

Next, MappedSuperclass. Annotation is called MappedSuperclass and allows you to create a class which actually contains attributes that are really mapped to the table. And then, you can extend these, and you can have extra attributes in your subtypes. Again, be careful with that. MappedSuperclass cannot itself be passed to the entity manager or query interfaces. You're supposed to operate on subtypes, on product or on service. They're kind of your real database objects. You just sort of share a set of mapped attributes, not dissimilar from what you were doing with embeddable type, which is basically a way to create a mapping that you would like to insert into other classes.

Embeddable type is more flexible, because the inheritance, really, you can only extend one class, right? So that's it. Whereas, embeddable type, a given entity could have as many embeddable attributes as you like. So generally, it's considered to be more flexible approach than inheritance. But if you wish, yeah, so there's another alternative for you.

Lastly, imagine you've got a table, TradeItem table, where you store information about products and services in the same table, for example. You've got a discriminator column here, item type. So that allows you to tell if that is a product or a service. For every record, you store an indicator which tells you what it is. You can then create an entity called TradeItem, and you describe that entity as having the, in this particular case, single table inheritance style type strategy and then a discriminator column, which is that item type column. We use a discriminate as just text-- pro as in product or sir as in service.

And then, you create subtypes that extend the TradeItem. There you go. Associate every subtype with a discriminator value and introduce extra columns in the subtypes. So they share that set of columns and then they introduce these two extras. Each subtype, one of them. Let's say product has bestBefore and service doesn't. Instead, service has channel, whatever the channel is. I have no idea, but it's just an example. The discriminator type, this column, by default, if you don't set up differently, will be using class names. So the default is product and service. But in here, I've reset it to use custom strings instead.

So if you don't provide discriminator values, if you don't say what discriminator values are, then the default assumption would be that it's just basically class name. Apart from single table strategy, you've got two more strategies called joined and table per class. They're extremely rare, especially table per class. Actually, they're rare to such an extent that a lot of JPA providers don't even implement table per class strategy. So it remains kind of a theoretical notion.

The rationale as to why these are more rarely used cases is very simple. It's performance. Join of two tables is an expensive query. A single table, in terms of querying all the trade items, will work quicker. If you never need to query products and services inside the same query, then joined strategy will not expose you to such a dramatic performance degradation. If you always query with products separately and services separately, then it makes sense to keep them in different tables.

But I guess there is a reason why they're all TradeItems. You know, there is a reason why there is this common set of attributes and common identity. So maybe we want to query them together, and in which case, single table, performance-wise, works better. There is also a consideration of the amount of this additional optional attributes that you have. So if you have lots of them in one subtype and few of them in the other subtype, or an equal amount of these attributes that, again, may guide you towards choosing a different strategy.

And general amount of records. How many products you've got, how many services you've got. It may be 50/50. Or it may be like, for example, you've got nine products for one service, something like that, uneven distribution. Again, that may sway your decision about whenever you use a single table or a joined strategy, depending on the distribution of records there. But I'd say most commonly, it would be a single table. There you go. So that is yet another interesting coding technique that you may apply to Java Persistence API, and that probably concludes this appendix.
