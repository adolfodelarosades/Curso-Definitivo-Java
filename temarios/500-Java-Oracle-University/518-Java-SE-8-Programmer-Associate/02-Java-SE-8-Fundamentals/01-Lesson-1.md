# 1: Lesson 1: Introduction to Modern Software Development
   
1. Lesson 1: Introduction to Modern Software Development, Part 1 - 18m
2. Lesson 1: Introduction to Modern Software Development, Part 2 - 16m
3. Skill Check: Introduction to Modern Software Development - Content Link

## 1. Lesson 1: Introduction to Modern Software Development, Part 1 - 18m

Lesson 1. Lesson 1 is an introduction to modern software development. So what we're going to talk about in this lesson is we're going to give you an overview of the Scrum methodology for development. We're going to talk about how to coordinate development between different people, how all the tasks can come together, and in the end you create a working piece of software. And then, we're also going to talk about Oracle Developer Cloud Services, just a brief introduction to that.

So let's get started and look at Agile development in Scrum. So when you develop software, it's a collaboration between many different types of people in many different types of roles. You'll have developers. You'll have architects. You'll have analysts. You'll have testers. You'll have a whole bunch of different people. And you also have to think about what your client is asking for, what requirements does the software need. You also have to consider, how do we go about deploying?

And what about testing? What is that? What do all of these terms mean? There are so in terms here. So that's what we're going to talk about in this lesson. So there's a few different ways you can look at development. One is bottom up development, right here. That way you can do that is you analyze all the requirements, everything that your system needs to have. And then, once you do that, then you're set loose to go build your entire system, to build your entire program.

A second way to do that is top down, which is you start by building your system. And then, you have someone else, whether that be the client who [? produce for ?] saying, as you go along, implement this, implement that. We need this, we need that. So literally top down, coming from the big wigs, coming from management. And then, you have Agile development, which seeks to take the benefits from both. Because there's pluses and minuses with top down and bottom up.

So what Agile tries to do is you start with your requirements, and you build your system incrementally. And you have just enough information to get going. It's about pacing yourself. It's about iteration, and just to analyze what you need in order to make progress for the next time-frame that's coming up. So let's start with an example.

Here we have a scenario, and online shopping catalog, where your client says, I want to have a website where I can sell my products online. So you have your overall goal, but there's a lot of other questions you have to ask while you're doing this. Such as, what's the layout of the website going to be like? How are you going to have people log on? Should they create their own account for our website, or could they log on using LinkedIn or Facebook?

Or you have to also think, what are our products going to be? How are we going to cycle in new products? How do we tell people that we're out of a specific item? So these are all things that you have to consider during making your software. And we do this by listing what are called user stories. A user story is defined as a quick requirement, and it follows the template of, as a USER TYPE, I want a REQUIREMENT for a particular business value.

So in this particular scenario, an example would be, as a customer I want to see the home page with the company logo so that I know where I am. And after you do this for all the tasks that you want, for all the tasks that are associated with this software, then you have to go about estimating how long it's going to take you to complete all of these tasks. And there's a couple ways to do this. One is through points, and one is through hours.

But in either case, what you want to do is, say for instance you're doing points-- you assign the task that you think is going to the easiest the base value of 1. And then, you compare that to all the other tasks and think, OK, is this going to be harder or the same? And then, you just add point values or add your hours accordingly.

And you take all these requirements, and you put them into what's called a sprint. And a sprint is a time box, or a fixed period of time, that you give to complete a certain set of user stories. And the sprint is going to contain multiple user stories, which each represent a requirement that adds value to your system. By the end, you should have some sort of working piece of software.

Maybe you do have placeholder stuff in there, but your software shouldn't be broken. You shouldn't have things that are half implemented and look bad, because if you show that to the client, they're not going to be happy. And it's also bad practice for development. But anyways, the last thing I'll add about a sprint is that you want it to be as short as possible. And they usually last from one week to one month.

And the reason why is because it's a sprint, not a marathon. You want to pace yourself and also want to be able to iterate and look back at what you've done, see what you can do better in the future. So just to recap what's involved in a sprint, the first thing you want to do is you want to perform a little analysis. You want to see what tasks you need to complete, and then create estimates for how long you think those tasks are going to take you. And then you start planning.

You plan what tasks you want to belong in a particular sprint, when you want to work on them, when is the best opportunity to implement certain features. And then, you have development. Development is when you're actually coding, when you're actually implementing those features. Once you have those features implemented, you test. The purpose of testing is to make sure everything is implemented properly, that there aren't any bugs, any scenarios that you hadn't anticipated.

You may also want to see, if it's something that a user needs to work with, you may want to see how intuitive the design is. Is there anything that could be changed to make things more clear for the user? And then, once all that has worked out, you have deployment, which is when you take your bit of software, and then you ship it. You send it off for the rest of the world to enjoy. And this process is done over and over again.

You have one sprint, and that's just one of many throughout the entire development process. And what we call the entire development process, the entire methodology, is Scrum. So Scrum is an Agile development methodology that allows for incremental product development by dividing it into smaller chunks of functionality. Throughout this process, you have different kinds of people with different roles, one of them being the product owner, or the client.

And the job of the product owner is to make decisions about requirements, prioritizing stories, and setting acceptance criteria, saying when a feature can be good enough. When it has everything that they believe offers enough value, it can be complete and can be shipped off to people. And most importantly, they work with the team to answer any questions that may arise, if there's and situations where you need to get more information about how to complete a task.

You have the Scrum Master, who is not really a manager, is more a facilitator. They make sure that the tasks that people are working on are being done in a cohesive way, in a way that ensures that everyone is working towards a common goal, to at the end have something that can be shipped. And finally, you have development team. And these are the actual programmers. These are the people who are doing the coding.

And as you guys are working together, communication is key. Your have to coordinate in your developments. You have to communicate with each other are doing. So one of the things that is associated with Scrum is, at the beginning of the day, you have a quick meeting, usually about 15 minutes, to ask the following questions. What did you do yesterday? What are you working on today? Is there anything that's blocking you?

And the reason why you ask if there something that blocking, if one person can't do their work, it would be up to someone else to do a little bit of work to remove that blocker so that they can focus on what they need to do. It allows people to help each other, to know what's going on. Also, a reason why you want to do this is, say you want to implement a menu system, and the menu system takes five hours to do. If you have one person who's working on the menu system, that takes him five hours. If you have another person working on the menu system, that's another five hours.

And the problem with that is you're duplicating doing work. You have two people that are working on the exact same task. And one of them is wasting their five hours getting something done. So one way to solve this problem is to have these two people communicate with each other. If one person knows that the first person is working on the menu system, then the second person doesn't have to waste their five hours implementing a task that has already been implemented. It saves your project five hours.

As everyone is working towards creating the software and implementing features, you have what's called the sprint backlog, or the scrum board. And what this is used for is tracking the progress of user stories. They start here with their backlog. The backlog is all the tasks that you hope to get done within a particular sprint. You remove the tasks one by one from the backlog and put them into the in-progress category. And this is the stuff that you're currently working on.

And then, once that's been done, once it passes the criteria for being done, you move it into the done column. It's also important for you to plan realistically when you're deciding what tasks you want to have in a sprint. Because sometimes there's expectation, especially from the client, to say, I want more. I want more. I want more. Make it beautiful. Do it. Do it, or I'll cancel the project. And this is a big no. This will drive people crazy and make awful software.

It's very unlikely that you'll be able to accomplish everything you wanted in a particular sprint. That's why I say it's the sprint, not a marathon. So you need to pace yourself. And instead of trying to foresee the entire system, try and keep the sprint as small as possible, in much more measured sized chunks. When it comes to planning your spring properly, what you need to think of is how much time you have available, and how much time it's going to take you to complete all the tasks that you want.

When you fill up your spring with the tasks that you want, you want to make sure you don't have any additional time left over at the end. So that would be the perfect outcome. Sometimes you may find that by the end you have some tasks that are left undone. And that's OK. But sometimes what that means is you may have underestimated how long things will take you to get done. Maybe you were a little bit too ambitious, and in the next sprint you want to cut back on the number of things that you want to try and do.

And likewise, if you have free time at the end, you may also have estimated your tasks wrong. And what you should do for next time is you could consider adding more tasks to the backlog. You'll also find that as you go on you'll become better at estimating how much time it'll you to complete a task. And you'll also get better at completing tasks just because you have that experience under your belt, and you're in the groove, and you're able to work faster, work more efficiently.

What do I mean by the definition of done? So when you write your user stories, you want to write them with enough information so that you're able to tell what exactly needs to be done, and what the done criteria can be. Your can expand your stories, your user stories, during development between sprints, but never after their completed. You never want to go back and say, oh, I wasn't really done. I have to go enhance this. Because that's not the meaning of done.

A user story is considered done when the acceptance criteria is met and is part of the active deployment cycle. In other words, when it's out there and done, and people are using it, then it's done because it's alive and people are using it. A user story is not done it if the code isn't final. What I mean by a code not being final is maybe-- something that happens when you're developing software is you try to get something working. And it may not be the best code, it may not be the most elegant code.

It may just be maybe more verbose than it needs to be, maybe it's done sloppily. And you probably don't want to have that be your final code. It just has a feature implemented, so you can go back and revisit and make your code more efficient, more elegant. Your user story is also not done if it hasn't been integrated into the final system. Maybe you're just doing it on your own, and it works on your machine. But until it works with the version that you're going to roll out, that you're going to deploy and have the world use, it's not considered done.

Because sometimes, even if it works on your machine, it may not work in the final version. So it's not considered done unless it's working in the final version, or the version that you're going to ship at the end of the sprint. It's also not considered done if it wasn't tested. Because who knows what could go wrong if you don't test it. And finally, it's also not done if it doesn't meet all the acceptance criteria that you or the client decide beforehand.

You want to try and track your progress as you're moving forward with a sprint. So what you're seeing now on screen is called a burn down chart. And there are two separate lines. The first line, the light gray one, this one shows what your ideal schedule is going to be, how many points or how many hours you're going to ideally have left over time. And then, you also want to map out your actual results.

And sometimes you'll find that your actual results may be a little bit ahead, or may be a little bit behind where you want to be ideally. That's OK, as long as in the long-term you're following the ideal trend. Sprint Results. At the end of the sprint you should be able to showcase the product to the product owner and make any adjustments you need for future sprints in terms of how much work you believe you're able to get done. Identify any new stories, so there's any new features that you or the client feel would be advantageous to have.

Providing re-estimates that may be necessary. You may also find that some of the features from the user story that you wanted to do are no longer necessary. So you can just get rid of those, remove them from the product backlog. And you select the stories you want for the next sprint, and you get started.

When is a project finally done? There's a few ways a project can actually be done. One is when you end a sprint and there are no more stories left to be done. That means everything that you had planned to be done is done. And there's, by definition, no more work to do. You can also say your project is done when a product owner is satisfied. You may have things that you had wanted to do before, but if the product owner is happy, if they think it's good enough, then that's fine. You can move on. You can be done.

You could also be done, again, when there's no time left. And often, this is the case where you have things that you wanted to do, but you never got around to doing them. But the way Scrum is set up is that it optimizes development based on the business value of stories where the most valuable features, the most valuable user stories, are done early on. And the things that are at the end are lower priority. These are like nice to have kind of things. And so, if they don't make it into the final version, it's OK.

There are other tools or techniques you may find helpful during your development process, one of them being test-driven development. And this is something we're going to cover a bit more in the next part of this lesson. But the overall goal is that it helps write efficient safe code writing tests first, thinking about what you want your software to do, and then revising your software in order to have your software pass those tests. You have continuous integration, which leverages the build process from the developers by running constant builds, and running tests with every code change.

You have continuous deployment, which helps system administrators with the deployment of a test version of the system in a controlled environment where it can be tested for acceptance by the product owner. So in other words, you're giving them their own little version to play around with. Meanwhile, you can just focus on the production version.

And finally there's pair programming, which helps developers find better solutions by pairing programs together while developing user stories. It's often used with test-driven development. And what you wind up doing is one person writes the test, and the other person fixes the code. And then you switch roles. And it's pretty helpful when you try to get a new team member on board, and try and get them familiar with the process.

So that's the end of this part of this lesson. We'll continue with the next part by talking more about test-driven development.

## 2. Lesson 1: Introduction to Modern Software Development, Part 2 - 16m

Welcome back. I'm going to continue lesson 1 by talking about test-driven development. What is a test? A test is a set of assertions that check to see if some functionality works the way it should.

A test is usually a simple comparison. And a test should be deterministic. In other words, here's our example.

In our example, we want to try and add 2 plus 3. And 2 plus 3 should be 5. It's deterministic in the sense that it should be 5 today, it should be 5 tomorrow. It should be 5 on your machine, it should be 5 on your friend's machine.

The advantages of doing test-driven development are that you get to write the least amount of code to make the functionality possible that you want. Tests provide a safety net when you're modifying code. Because if your code breaks-- oh, no, it's broken-- if your code breaks, you can just completely wipe what you've written and start over.

Even better, if you can automate your tests, that saves you time. And test-driven development also aligns with Scrum. In other words, you can do both at the same time.

And here's how test-driven development is from a line. You can write a user story and represent that by a test. And the acceptance criteria can be described as the assertion. And the Scrum short cycles work well with test-driven development short processes.

So how do you go about doing test-driven development? Well, first, you want to think about what your code must do. That's step 1. Second, you write your tests based on what you want your code to do. Third, you run the tests.

And your code will fail. Why will it fail? Because you haven't written any code that would allow it to implement the new features or the new behaviors that you want.

The next thing you want to do is step 4, fix the tests by writing code. And you run the tests and keep fixing until it works. Because it's an iterative process.

You can also think of it as red, green, refactor. If you take a look at the diagram on this slide, you'll notice the pathway. So you start by writing your tests here.

You run them, and they will fail. And you make whatever tweaks are necessary to have your code pass the test. You keep doing that until it passes.

And then you want to try and modify your code or refactor. That's what refactor means. It's modifying your code. And so why do you want to do this?

You want to do it because in order to just get your code to work, you may end up running things that aren't efficient, that look messy, that would make it harder to expand on later. So you refactor to make your code prettier, to make it elegant, to make it shorter, to make it so that it doesn't become a nightmare in the future to work with the code that you've written.

And sometimes, while you're doing this, you may end up having your code fail the tests again. And that's OK. It's so part of the process. So you make whatever adjustments are necessary until you finally have your code pass. And once it does pass, and your code is pretty, then you are done.

So going into a little more detail, you want to develop your tests first. Step 1, think about what you want your code to do. So in this example here, we want our code to add two numbers. That's easy enough to understand the requirement there.

And the next thing you want to do is think of scenarios, specific scenarios where you can test these features. So one way to test your ability to do addition is saying, I want to add 2 and 3. And as you do that, you realize it should be 5. And you keep testing to make sure that your answer is 5 until your code is able to produce 5.

And you fix the test. Once you know your assertions, begin fixing your tests using those assertions. Write code and run the tests until your code then passes. If at some point you get stuck, again, you could just wipe everything you've done and start over.

And your goal isn't to make the most optimal code. It's just to have your test pass. Having optimal code comes later. And when you're optimizing, this is when you have a chance to remove any of your code that may have been duplicated or anything that's taking up many more lines than it should. You can add some more flexibility to help you in the future if you need to build off of your code.

You could also add more tests. Maybe you come up with additional scenarios that you hadn't thought of before that you would think would be interesting or advantageous to test for. And these would be any other things that may occur to you that could go wrong or any sort of combination of the data that you're working with, where you think, ooh, I could make this thing-- I can have my code-- I can have my system messed up if I just do X, Y, or Z. This will be fun.

And this is actually what testers do a lot. They try and think of how they can mess with the program in order to produce bugs or make the program just completely goof up. So don't be afraid to try and do things like that.

But one thing you can't do and one thing that's definitely not recommended is to remove the tests. The tests that you design were designed for a reason, to anticipate particular scenarios. And so if later I decide, eh, we don't need to test for X, Y, or Z, that's never going to happen. So often, when you think that and you remove it, that's never comes back to what you were testing for. So it's not recommended that you remove the tests.

When you're writing your tests, you want to make sure that they're descriptive. And the reason why you do this is because it provides you useful information while you're working with your code. If your code doesn't pass the test, you want to know why. You want to know what's produced.

So that's why it's helpful. Here, you'll see you have a little message that's going to be produced. And this gives you information on how you can enhance your code.

Often, if you have complicated tests, it may be a problem with your requirements. And there's two possible problems. One is that a requirement is not small enough, and you'll need to redefine the requirements to make your test smaller. Two, the tested functionality does too much, in which case you need to divide your functionality or these stories into smaller chunks, make your user stories smaller, in other words.

So here's a scenario. I want a program that greets the user with their name and displays their horoscope. The two tests that you would have are assert that the user is greeted by name-- oops-- assert that the user is greeted by name and assert the horoscope from the birthday of the user is displayed. The problem in this slide is that the second one may be too big. And we'll talk about how to go about addressing that.

So here's a story 1, here's test number 1. You want to get the user's name. That may be easy enough.

Two, this might be harder, is getting the horoscope by a birthday. It may be better to try and break this down into two separate pieces of functionality, two separate user stories, two separate things that you can implement. Or two separate little stickies that you have in your product backlog. So one recommendation is that first, you capture the user's date. And then two, based on that date, then you write the horoscope, then you provide the horoscope.

One more thing to discuss-- what do you do if your program relies on external factors or external code, if you're using third-party services? So how do you go about testing your code when you may not have these things available to you? You may not have the libraries from the third party. You may not have the resources.

Maybe, for instance, you don't have the database of all these horoscopes. Maybe that's something you have to plug into later. How do you go about writing your code when you may not have what you need?

And the answer is something called mocking-- ha-ha-ha-- mocking. The mocking is a way of simulating an object and replacing that with the actual one later on. So you assert the values, and you don't necessarily need to know what you're going to get in the end. You mock any sort of dependencies, any sort of resources. You can write your own little dummy code.

And then later on what you do is, you try to have your code work with the third-party code. But that's something that you can do as part of the future sprint or just later on your sprint. What you want to do in the meantime for right now in the short term is just to get cases or scenarios where you can test what you have and don't worry about the other stuff for now. If you do need additional resources on this, we've provided that in this slide.

So now let's talk about Oracle Developer Cloud Service. What is Oracle Developer Cloud Service? Well, everything that we've talked about so far in this lesson in terms of creating user stories, tracking your progress, version control-- that can all be done through Oracle Developer Cloud Service.

Oracle Developer Cloud Service is a set of tools in Oracle Cloud that enables you to manage your software projects. These tools allow you to create a project to hold your application; to manage your product's source code; perform Agile development using issue tracking for sprints; ask team members to review your code and then merge your code after that's reviewed; build, test, and deploy your application; document your project using a wiki; and administer the project.

So when you log on, this is what you'll see, products and the Welcome page. You're going to organize your code into projects. When you first start Oracle Developer Cloud Service, you'll land on the Welcome page, which is going to contain the list of all the projects that you have, which are these right here. And you click the New Project button to create any new projects.

But for right now, let's say we don't want to create a new project. Let's go into an existing project. Let's take a look at My First Project. And here we go.

We go into My First Project, and this is what we'll see. A project is going to contain tabs, tab pages that organize your application. If you look at Home, this will show you all the project activity, all the recent things that have been going on.

So, for instance, today, Alex Admin has updated task 1. He's also provided some comments. Thank you, Alex.

If you go to the next tab, you can check out the repositories, branches, tags, and commits. Use the Code page to see your source code, repositories, and branches. And navigate down through your directory hierarchy to open files and view their contents.

You have Issues, Agile boards and sprints. This is through the Issues tab. And you can use this to manage any issues.

And issues could also be, say, bugs or tests. If your program doesn't work, you create a bug that gets assigned to you, could be assigned to someone else. And this is just a way of tracking those bugs and tracking all the work that has to be done.

You could also use Agile page to organize these issues onto the Agile board. If you could think back to earlier in this lesson, where I showed you the three columns, you have the Back Log, the In Progress, the Done. That can be facilitated for you through this service from Oracle.

Use the Merge Requests page to create and manage code reviews. So there are a couple of things I have to define here. I should explain what code review is and what a merge is.

What a code review is, you ask someone to look at your code, see if there is anything that's done improperly and anything that's messy, anything that could be changed in order to make your code better or to have your code work more efficiently with someone else's code. You also have what's called merging. And merging is, say, you work on the same bit of code, your friend works on a bit of code. And you have to combine your work together.

That's what merging is-- when you combine your code into one. You combine two separate files into one file, one single document of code. Builds and deploy artifacts-- use the Build page to manage builds for your application. And then use the Deploy page to deploy artifacts that were built using Oracle Java Cloud Service.

So just to review and to recap, how do I use Oracle Developer Cloud Service? Well, first, create a project. Creating the project will also create a repository for you, which is used for version control. And version control is something we'll talk about in the next lesson. All that stuff that you need, that's all created for you.

Create issues that define the work that you will need to do in this project. You set up an Agile board and sprints, and assign the issues in the sprints. You clone the repository locally-- this is going to be the Git repository-- and work on the source code for a particular issue. You build and run the project in an IDE-- IDE being Interactive Development Environment, we're going to talk about that too in the next lesson-- just to see if it works.

You create a merge request and check the code in a branch. And when the code is approved, you merge it into the master branch. This being the final version, the version of what you're going to ship. And then you close the issue when you're done with it. So in summary, in this lesson, you should have learned how to describe the concepts of the Scrum methodology; create user stories to describe requirements; estimate stories and team capacity; describe the fundamentals of test-driven development; create assertions in your code; design and create code based on tests; describe what Oracle Developer Cloud Service is; list the main components of Oracle Developer Cloud Service; and finally, explain the typical workflow for using Oracle Developer Cloud Service.

## 3. Skill Check: Introduction to Modern Software Development 

Skill Check: Introduction to Modern Software Development

Quiz for Lesson 1

[View Content](https://learn.oracle.com/education/html/pages/UPK/JavaFundamentals_quiz1/index.html?p_cloud_id=989)

