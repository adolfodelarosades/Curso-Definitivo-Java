# 1: Introduction to Web Services

   * Introduction to Web Services: Part 1 40m
   * Introduction to Web Services: Part 2 12m
   * Introduction to Web Services: Part 3 4m
   * Practice 1-1: Configuring NetBeans to Control WebLogic Server 5m
   * Practice 1-2: Creating and Deploying Web Service Sample Applications 14m
   * Practice 1-3: Web Service Testing 6m
   * Skill Check: Introduction to Web Services - Score 80% or higher to pass

## Introduction to Web Services: Part 1 40m

Good morning, again. Welcome, everybody to the Java EE6 Developing Web Services with the JAX-WS and JAX-RS technologies. JAX-WS is for SOAP, and JAX-RS is for REST web services. I'm going to start by introducing the course, and then, of course, after that, I will get into the concept of web services.

So let me go ahead and start with the course itself, which is just the first chapter for an introduction to web services. In fact, what we are going to do today, we're going to do a little bit of review. Most probably you guys are a little bit familiar with the concept of a XML. So we do have a chapter just to do a little bit of review about XML. And then we're going to get into, of course, the concept of a one API for web services. I do not know if you folks heard of JAXB. JAXB is an API that allows you to [INAUDIBLE] XML objects, so we'll just show you that. And then, of course, after that, we'll introduce the SOAP web services. That's what we're going to do today.

And we'll start by getting into the SOAP web services, and then when we finish with the SOAP web services client, then we get into REST, and then the REST client, and then after that we get into building SOAP web services, top, down, bottom, up, and then building a RESTful web services in the JAX-RS API, and then get into more chapters later, and I'll discuss all of those.

So let me start by the introduction to this course, which is explaining the need for a web services, looking at defining these web services, looking at the characteristics of these web services, explaining the concept of a message, a format, which is either, in this case, XML or JSON, and we're going to explain both, and why XML and why JSON, identify the two major approaches to developing web services, which are, by the way, SOAP and REST. These are the two major ones. And explaining the advantages of developing web services within a Java EE container.

Now when we talk about a container, in this case, it would be either a web container, or you could be, by the way, a web and an EJB container. We'll talk about that.

So the objectives of this course, which is, by the way, quite an attractive course. It is a course that covers the latest and the greatest of the web services technology. And we'll start by creating XML documents using the namespace declarations and XML schema. This is pretty much a review to the concept of XML, talking about XML, format of XML, the syntax in XML, resolving name conflicts using the namespaces, talking about validating XML through XML schema and so forth.

Then, of course, we're going to talk about producing and consuming XML and JSON, getting into creating RESTful web service clients, getting into creating SOAP service clients by using the JAX-WS API. Of course, when I say here, creating REST web service clients, if you take a look here, we did not say, using JAX-RS. And I will talk about it when I get there. We do have a couple of APIs that allow you to create this RESTful web service clients. One is Java using the pure HTTP UI connections, and the other one is the Jersey API.

Then we're going to get-- once we've built, of course, a REST and SOAP web service clients, we're going to build also the REST web service using the JAX-RS, and then, of course, we're going to build a SOAP web service using the JAX-WS. In the SOAP web service, we are going to discuss a couple of ways to build these web services-- bottom up and top down. We'll explain what's the usage of every one of them, the advantage and disadvantage of every one of them, and so forth.

Then after that, of course, because we're dealing with web services building within the context of enterprise applications and Java, and as you know, we need to deal with errors. It's not always rosy. Once in awhile, you get issues, and we need to find out how to handle errors in SOAP web services and errors in REST web services.

After that, we start by introducing the concept of web services security, where we talk about web service security in general. And then we get into the WS security, which is an API used to secure SOAP web services. But we also talk about a very nice technology. I don't know if you folks, anybody heard of OAuth technology. So we will take a look at that. And it's an open source, and we'll see the implementation, the Jersey implementation part of it. That will be, by the way, towards the end of the course.

So you guys pretty much, we got introduced, and so that's the next thing. Of course, the typical audience of this course judgment is, ladies and gentlemen, is, of course, a Java Standard Edition and the Java Enterprise Edition. And, of course, I will talk about that a little bit later on. The prereqs for this course, it would be nice to know about Java SE 7. Are you folks are familiar a little bit with the Standard Edition Server? So we will talk a little bit again at some point in time and mention what's new in the SE 7.

And some of the new concepts of the SE 7 are really quite good in terms to help performance, to have a development of the code, and so forth. And so this is more or less what we're going to cover pretty much every day. Of course, now the next is the environment. This environment is on the machines, the lab machines that are available to you. So we provide you with the JDK 7 already installed, NetBeans already installed, and, of course, the Java EE6 WebLogic. That would be an application server that we use.

And, of course, the Firefox and a browser. Why? Because we are going to install the REST client extension on the Firefox to test our web services. We also use a tool in cURL to just do some testing, a little bit of jQuery, if somebody's interested, we have it as an option, just in case somebody to use it. We provide a student guide and an activity guide.

I assume that everybody downloaded their student guide, and their activity guide. Of course, the API. Chance is that when I talk about many, many of these, the plumbing of web services, if you want, the coding, I will be also sharing some of the APIs to explain what is it that we added in the API at the Standard Edition and not the Enterprise Edition, of course, to have been web services. So that's why, of course, the Enterprise Edition specifications.

We focus more on the current one, which is the EE6 in this case. So this is just the curriculum that we have, and the courses in blue are pretty much-- the background is blue. Those are the Standard Edition courses that we have available, and then what's in red is those are the Enterprise Edition. Of course, here in our particular case, we're focusing more on the Java EE6 developing web services using the JAX-RS and the JAX-WS web APIs.

And, of course, the question that we always have in this case is that, why do we need these web services? And for that, let me just go to the whiteboard, and tell you a little bit of a story of what happened throughout the years, and why is it that suddenly web services came into the picture. So awhile ago when, of course, TCP/IP was created, everybody was quite happy. Why? Because through TCP/IP, we can allow two systems to talk to each other.

So anybody has done that awhile ago and trying to implement that in the C language and other languages and so forth, but at some point in time, well, people said it would be nice to actually have a standard interface that you implement at that standard interface, API will actually be an adapter so that two systems can talk to each other.

And you've most probably heard of CORBA. CORBA had a protocol called IIOP, and then, of course, we used that awhile ago. And then in 1995, when Java got created, when the Java Standard Edition-- let me just-- when the Java Standard Edition got into the picture, we actually created them in an API that allowed two objects or two Java objects to talk to each other through the network. And that was-- anybody remembers that API? RMI, thank you, sir. RMI, Remote Method Invocation.

Of course, we used to actually implement that by hand, but then in 1997, a group of engineers from Oracle, at Sun, they just said, you know what? Every time we build an enterprise application, we have to code everything. We have to code security. We have to code persistence. We have to code transactions. We have to code the naming services concept. We have to code the multi-threading. We have to code the concurrency and so forth.

They said, why not build a piece of software that handles all these common services through configuration, and let the developer focus only on the business logic? That's how actually the Java EE technology came into the picture. So when we created a Java EE, we started with now the concept of software servers, a web server like the Apache Tomcat, and then an application server.

So what is this application server here? This application server is a piece of software or a middleware made of one or two containers. One, let's put in the full Java EE application server that has a web container, and it has an EJB container. And then, of course, we do have the resource deal, which would be, for example, a database in this case.

We could also, by the way, have an EIS system, an enterprise information system that can also talk to our ser-- it could be a mainframe. It could be another server. Could be a .NET server for that matter, and so forth. So these are what is called the web container, and what is called the EJB container.

And of course, we do have now-- we would love to have as a client what we call a thin client. So we then have the client, and our client's typically a browser. So what we have done, what we also have done in this case, we also have said, OK, let's go ahead and divide all of this into tiers. So here, we have the client tier, the client tier. Let me just write it nicely. Client tier. Then here we call this a presentation tier, and we call this a business tier.

That's where your business logic is, and then what we have done in this container, we also created one more tier here, and that is called the integration tier. The integration tier. Of course, this is the application server that we are discussing here, and at that time, we actually had an API that allowed a Java EE server to talk to a CORBA system. And if you remember that JAR file is called RMI-IIOP, which allows Java to talk to CORBA and back and forth and back and forth.

So which means here, we can actually talk to an EIS system through that. And that's where in our slide here, we say if you take a look here, we say that a computer program calling a subroutine located in a different type of a machine on the network, we did have many different type of technologies. One is our PC from Sun Microsystems, which is Oracle now, was an early example of that cross system. And then, of course, other ones like the CORBA/IIOP, the .Net Remoting, the RMI, and so forth. That's pretty much what we had.

Of course, in these times, for many of you, most probably you are familiar with the concept of having here what we call a connector, having the concept of a connector that allow an app server, in this case, or app server components to talk to an EIS system, or even to a database.

And, of course, in this enterprise application, we do have now, for example, we can go ahead and make a browser called, for example, a servlet through a bunch of filters that handle authentication and authorization and so forth. Let me just go ahead and represent this as an SF or Servlet Filter. Could be more than one. And then from a servlet, we can go ahead and call a component here, for example, could be here, a business delegate that will delegate the call to a business component here.

My business component here, it could be, for example, a stateless session bean EJB, which calls this one here. And then that stateless session bean can now call the database if he wants to get some data from a database. But I can go ahead and use, for example, in this case, a DAO, Data Access Object, or I can go ahead and use a domain store. A domain store. A DAO uses JDBC, uses a JDBC, and the domain store can use JPA. You guys know a little bit of JPA ORM software like Hibernate. Have you heard of Hibernate, TopLink, EclipseLink? That's the idea. So it's a choice.

So for example, if you're using JPA, then chances that you are going to use an entity class representing the data, which, by the way, this will talk to the database, of course, either one of them. JPA is an API that was built above the JDBC, which allows, of course, a faster production, and it allows you to make use of an ORM software, object relational mapping software, which actually activates the implementation of the code that talks to a database.

So this is just as an example. But if you take a look here, that was, in this case, a call, an HTTP call from the client, which is, in this case, a browser, a thin client on a browser, which is, in this case, we can call it a B to C. So then the introduction of XML, which is an interoperable language, came into the picture, especially if you're moving XML through HTTP, because HTTP is a lot cheaper as a transport protocol. That's where the idea of once XML was introduced over HTTP, the idea of now having two systems talking to each other through XML became very, very attractive, because XML is interoperable. That's how the idea of web services came into the picture.

It's the interoperability and, of course, the easiness, and the implementation is quite simplified and so forth. That's how we came up with the idea of web service, which means now we can have an outside system. That could be, for example, an EIS system like this. Let me represent this way as what I call, in this case, a web service client. And this web service client now can interact with your system, and the interaction of your web service client with your system, you have a choice. You can actually have it interacting through a, in this case, you could be a JAX-RS servlet or a JAX-WS servlet. OK. Either one of them.

And, of course, the interaction of this web service client through the JAX-RS, which, by the way, can now make use of a component here, could be a web service broker, for example, component, which might be me now, give a talk to the business delegate, which talks to the facade. Or the same thing here. It could be calling a web service broker, which allows me to talk to the business delegate, which talks to EJB, or I could call directly the EJB. I can also do this direct call too-- why not-- from this component.

But the bottom line, you can access your facade that represents web services, but this time it's from outside. We can even do better. We can also, if we want, and we have also another alternative here, where I can go ahead and make use of a stateless session bean JAX-WS servlet or a stateless session bean JAX-RS servlet. And these, by the way-- here, I said stateless. Actually it could be also a single session bean. That also can be used. And I can make the web service also call these components, which themselves can call the business tier, the interface, or rather, the session facade.

So in this case, what we're showing you is that now, an outside system can interact with your application, your existing enterprise application, and all what we have done in the case of web services is we created the infrastructure, the web services infrastructure, that allow a web service client to talk to your application, either through JAX-RS or through JAX-WS. We can investigate these JAX-WS and these JAX-RS APIs. We can investigate this web services infrastructure that allows now two systems talk to each other through web services, through the concept of, of course, what we call the JAXB, rather the JAX-RS or the JAX-WS APIs.

And, of course, when we talk about these web services, here I just said web services, but, of course, there are two types of web services. There is a SOAP web service, and there is, of course, REST web service. Now why is it that-- now, by the way, also if you follow the Java EE specification, the Java EE specification also tells you that you don't have to use an EJB container. Let's assume that you have a Tomcat Apache up server. You can now use what we call web profile, and you can actually use an embedded EJB container inside the web container and interact with it. In fact, that's what we're going to do in the course.

And this way, it allows you to deploy your web services into a WAR file, rather than an enterprise archive file. I'll share that with you, of course, later on. So why is it that we would like to use an application server for these web services? Just because, in general, the app server provides a lot of services for you, for your managed components for free, rather than coding that.

And that comes from the layer pattern, which is an architecture pattern, where in general, we say we do have a hardware machine that would be your server. That would be your hardware platform. And then to make the hardware work, what we need to do is we need to now install an OS system on the top of it, and then to run Java-- that's an operating system. It could be Linux, Solaris, Windows, and so forth. And then if you want to run Java on the top of that, what you need is the JVM.

So we could look at all of this as what we call a lower platform, these two. And then what you need to do is if you want to take advantage of having a middleware server like this WebLogic or GlassFish and so forth, so obviously, this app service provides lots of services for your managed components, which are servlets, JSPs, JSF components, enterprise Java beans, stateless session beans, stateful session beans, single session bean, and message-driven bean, and so forth. We could actually have an EIS system interacting with your system through an asynchronous communication and sending messages to a JMS system here, which is picked up in the queue or a topic by an MDB, by a message-driven bean, and getting processed.

So that's why you need to install an application server, a Java EE app server. And this Java EE app server, this pretty much would be an upper platform. I can look at it as an upper platform. But every app server has a specification. I can now specify the specification through a layer here like the one that we are dealing with this in this course would be the Java EE 6 specification. And that would be what we call specs and frameworks.

And that would be related to your app server. That's typically called a virtual platform. Why? Because it changes. If it was EE 6, it was EE 4, and then EE 5, and then EE 6, and now, of course, and so forth, and the next one EE 7 and so forth. And your applications in which you've built all these components are represented here on the top of this as an application platform. Your applications.

So what we are going to focus on in this course is the web services, the interaction with web services. That's what we're going to focus on. This APIs, the JAX-WS for SOAP web services, and the JAX-RS for RESTful web services, and the concepts and the characteristics of every web service. That's what we are going to focus on. And then towards the end, we talk about securing these web services.

So and that we said, obviously using these types of technologies, obviously, you need pretty much the concept of having to have to install a bunch of APIs and having to do a little bit of an implementation. Of course, many of these technologies, unfortunately, they suffer from the platform-specific type of a language or programming language and so forth.

And also they were quite complex. That's why we came up, by the way, in this case, with the idea of web services. So this, the W3C, which is the Worldwide Web Consortium, what they've done, of course, in this case is they introduced these web services, which is nothing but a software system design to support the interoperability of a machine to machine interaction over the network. That's the idea.

Of course, to be able to build these web services, we need also some of the APIs that allow us to build these web services, and we're going to use, for example, technologies like the WSDL file, which is the Web Service Description language would allow us to actually describe the web service that you're trying to expose to the client.

And then we'll also make use of messages. These messages can have the form of SOAP, and we'll take a look at how SOAP is built, and our XML, which also can be used-- the XML has tendency to be used, for example, by REST. That's the raw type of XML documents, and SOAP is used for SOAP web services.

Of course, over the years what happened to these web services, ladies and gentlemen, is that they evolved, and beyond these definitions, and we're going to take a look at all what actually has been added to the whole machinery if you want to, the whole machinery of web services. So characteristics of web services, why they're liked, because their platform-neutral, which means I can have an app server like WebLogic talk to another system. It could be a mainframe, could be a .Net system, could be through web services.

So a platform neutral data interchange, client server type of an architecture, where we do have a web service client which represents, in this case, by the way, the client side, and then the service side would be these servers that answer to all response to a request or web service request. So in general, SOAP and REST web services are not tied to HTTP as a transport protocol, but just because of the fact that HTTP is quite popular and it's ubiquitous. It exists almost everywhere. That's why HTTP became, if you want, the de facto type of a web service, a transport protocol.

So of course, whenever we work with a web services, we need to describe these web services. Every web service that you want to code or you want to call an operation represented by, in this case, a web service, we need to describe how actually we are to interact with-- we are going to interact with these operations.

And that's where we came up with this idea of the WSDL. We'll get into the WSDL file in detail and understand how all of this API is built. That's called the Web Service Description language, which is similar to the Java interface. And pretty much list all the operations, the parameters, the return type, and so forth.

And WSDL file is usually primarily used for SOAP web services, and the WSDL 2.0 actually can support RESTful web services, but it's not up to the level yet. We also can make use of another file, which is called the Web Service Application Description Language. That's what we call nowadays the WADL file. This is nothing, again, but an XML description language of RESTful web services.

Don't forget that sometimes we need the human readable type of representation. That would be HTML. As you know, there are now engines that are used on the web tier, and these engines, what they do is they allow us to convert an XML document into an HTML document. An example of that is a machinery or that API. Anybody have the XSLT? That would be an example, or like a JSF plugin would a renderer and so forth.

So because we use web services for business to business, but don't forget also, in some cases, we also need B to C too, business to consumer, because we human beings, we understand the HTML concept. We know, because HTML will be written in a language like the English language, so we can read and understand what the information that, of course, is represented to us.

And don't forget that these web services are self-describing, which means giving a starting URL, you will discover all the rest. We'll talk about all of that. That's what we call a progressive disclosure, and we'll take a look at that. Rest focuses a lot on progressive disclosure. And to help facilitate this platform, a neutral data exchange, what we have done in this case is we made use of a couple of ways to represent the format of the messages or the web service messages, and that's using either the Extensible Markup Language, which is XML, which is, by the way, used by both SOAP and REST.

There's a whole-- and sometimes it is attractive, because it has a big library or big processing line, not many number or large number of processing libraries that exist to support the XML for almost every language. And it has a bunch of APIs that help you process these XML documents, and that's like the SAX. Anybody heard of SAX? Or DOM and so forth, and StAX. The one that we are interested by in this course is really JAXB, and we actually dedicated one chapter or one lesson for this JAXB in this course.

SOAP web services rely on XML, but, of course, the libraries hide all the portion of the XML part of it, which is SOAP. And by the way, nowadays also, lots of businesses do make use of JSON, which is quietly used for RESTful web services. And by the way, why people like JSON? Because it maps very nicely to JavaScript objects. And so it's a subset of JavaScript. Less variables then XML, but it does a very, very good job. The support is evolving for all the languages, and nowadays, actually, it became one attractive format for web services that everybody wants to use for web service, of course, and messages.

And the whole approach behind getting into these web services is a couple of ways. There are two main types of web services-- what we call SOAP web services, and SOAP web services are heavily standard, and, of course, evolved throughout the years. But now they became quite a mature type of a web services. XML data is transmitted over HTTP. That's, again, in general, the de facto type of, or if you want, the popular transport protocol.

And the XML data lists the methods and the parameter calls and [INAUDIBLE] to call and so forth. That's to do with the WSDL. We'll take a look at all of that. And, of course, an XML response, which is generated, in this case, containing the method return data and so forth. And by the way, for a SOAP web services, nowadays you can actually build them or develop them in a couple of different ways.

Either the WSDL, you start with WSDL, and you end up with code, and that's called a top-down development methodology. And the second one is the code. You start from the code, and you get to the WSDL, you generate the WSDL, and that's what we call a bottom-up. In fact, we do have for every one of them, we do have one lesson. And we'll dedicate that one lesson for each one of them, and we'll take a look at those in detail later on.

Of course, now we do have another type, which is REST. REST became quite attractive. Why? Because of the fact that it's a lightweight and less format approach. So because of the different layers that were created in SOAP, somehow the issue of performance becomes a topic, and that's where the idea of moving data, especially if you're reading lots and lots of data at once, REST became quite attractive.

And that's why we're going to investigate how REST is attractive and how REST would do an excellent job. So REST uses HTTP operations as methods. And REST, by the way, what's good about REST, it relies on the HTTP API. So the GET and the PUT and the POST, and so forth, so we're going to see how all of those are used within the context of RESTful web services.

And different URLs represent resources. Basically, REST focuses more on resources. We'll take a look at that. And of course, the format of the RESTful web service messages are either in XML or JSON. And of course, we'll look into that into different examples and how actually we can characterize a message in a form of XML, or a message.


## Introduction to Web Services: Part 2 12m
## Introduction to Web Services: Part 3 4m
## Practice 1-1: Configuring NetBeans to Control WebLogic Server 5m
## Practice 1-2: Creating and Deploying Web Service Sample Applications 14m
## Practice 1-3: Web Service Testing 6m
## Skill Check: Introduction to Web Services - Score 80% or higher to pass
