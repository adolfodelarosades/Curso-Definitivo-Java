# 10: Handling Events

   * Handling Events - 35m
   * Activity 32,33,34 - 25m

It's time for us to continue with chapter 10, handling events. We are reaching to advanced JSF last chapter. In this chapter, we're going to see the JSF event model and how to use action and the value change events. Apart from this, register event listener, and capturing and responding to life cycle events we will discuss in this chapter.

For this [INAUDIBLE] the topic which they have created here to let you understand the types of JSF events, event processing life cycle, value change event, action event, phase event, and system events. Let's start with the types of JSF event. JSF supports four types of events. Number one is value chain even. Number two, action event. Number three, phase event. Number four, system event.

The first two events are actually application events that you normally used for business processing. That means when you're changing the value of a particular component, like in dropdown list box and text boxes, we like to do something when the change happens. Take the help of value change event. Action event, when you're hitting the button, clicking the buttons, or hitting the Enter key on a particular component, like command button, command link, or simple buttons or a link that you may have, go link, go button, you can use action events over there.

Phase events, system events, they are life cycle events. When you submit a page for the request processing, we have multiple phases. If you'd like to capture those phases to do something, for auditing purpose, to log some information in a file that you're reaching to create a restore view phase, and now it is apply value phase, before that you want to do something, after that you want to do something, you can take the help of the phase events and the system events.

Events, select one manual, like here this say value change listener. Components like select one menu supports value change events. They have their attributes that you can use. Value chain listener attribute. You have to specify a method which is responsible for handling that event. And that method, you can create it in a managed bean class. Or you can create a separate class implementing value change listener, and by overriding value change event handler methods.

See the event processing life cycle phases with each phase of the life cycle [INAUDIBLE] apply request value phase you have the process events. You will be able to capture those events. What happened when the phase begins, what happened when the phase completed. You like to log those information, you can do this by capturing life cycle phase events.

Now application events we're going to discuss here are generated by the UI components. Includes subclasses of faces events. Application events, they are the subclass of the faces events, and there are two application events that you can see. One is action event, and the value change event. Normally what happened that these application events are processed at the time of invoke applications. Before action processing logic.

The first preference goes to value change event. Second, action event. And third to action processing logic. But we have other options to specify that we want to process all the events just after apply request value phase by saying [INAUDIBLE] properties [INAUDIBLE] that we will see a little later.

See here what they say. Action events. Action event that happens when you actually hit the button or the component that supports action event. You'd like to activate this event handling on a particular component, like command button, let's say, action listener. Action listener specifies the name of the method that can handle action event. And as I said earlier, this method can be in a managed bean, or it can be in a separate class that implements action listener interface.

If you have to do something with managed bean properties, you want to manipulate those data, you want to play with those data, read data or modify the data, on action event processing, we're of course going to put them into managed bean. So that's why here this say actions are designed for navigation and to perform business logic. Do not get confused with the action action action listener. Action here is for processing logic. Action processing logic. That includes navigations or to have some business logic to be included. Action listener is for action event handler methods, which you can write in a managed bean, or you can have a class, separate class implementing action listener interface.

If you have a managed bean and you want to write handler in the managed bean, you just go ahead and type any name that you want. Any name. In a managed bean class, have public. Write any name that you want. Just do not forget to have a parameter type, single parameter action event type. This will be action event handler methods in the managed bean.

You will have a faces context with you always that you can use to obtain the components ID. See, with the e you can get the components ID associated with the current context. You can also obtain the request parameter map. SGP request, SGP response object you want to do something with them, you can get it from the context. Parameters that you have in SGP request, you can leave them here in the event handing.

If you want, you can create a separate class. Like here they have a separate last location listener, and the say implement action listener. And there, once you implement action listener, you have to override the method that is process action. Here you have no choice, you need to use the same name, process action. And it's going to have the parameter action event. But in managed bean, you can type whatever the name that you like. Just the parameter action event.

In this, you just go ahead and write the logic that you'd like to do when you hit the button, or when you generate the action events. Either by clicking on the button, or by hitting Enter key. Registering an action listener on a components. See action listener equal to. If your action event handler is in a managed bean, then just give the name of the bean. DVD dock, and type the name of event handler method. Like here this say bean.choose a locale from link. Similarly, if it is in separate class that you have used to implement action listener, in that case you can use JSF code tag action listener, and say type equal to package name and the class name that implements action listener interface.

Immediate components, it's again very important here in the case of event processing. Immediate attributes on the components where you have included some events bypass the event processing life cycle and fire immediately following the Apply Request Value phase. Your event is going to be processed just after Apply Value phase.

Remember what I said earlier, if immediate is not available, then your action events, value change events are processed at that time of invoke applications completing apply value, update model-- or validations, update model, and then invoke applications. So immediately equal to true. It will [INAUDIBLE]. The events are going to be processed just after apply value phase, skipping the rest of event processing, life cycle processing.

So that's what they had to say, immediate input components fire events before the Process Validations phase, which is useful if you want to use the value of input to alter other elements of the form. So this is going to be useful when you have to play with the components' attributes and you want to manipulate the value of a component's state. The time of apply value, submitted value is going to be applied within the component state. And just after, if I process my event logic, I can play with those values and perform some manipulations. So that is what is possible. And then we can go for other phases.

Value change events. Here they say value change events occur when the user changes the value of a component that implements editable value holder. This is, again, an interface. This interface is implemented on those component which are editable. So if you have the generic list of the components and you want to check which components are editable, you can take the help of editable value holder and check if the component reference is in [INAUDIBLE] editable value holder or not. Just like you input text, dropdown list [INAUDIBLE] where you can do some changes. It is applicable on that. Select one menu is one of them which is editable value holder components. And here we can have value change listener.

Value change listener as well you can have a separate class that implements listener, value change event listener. Or, you can have a bean method. And there you can type methods containing a parameter for value change event. So this is the example of the bean method that you can use to handle the value change event. Whenever you change the value, it is going to process this bean method.

See this, where the country changed the bean method. And here, the parameter, they have value change event. In a managed bean you can type this, any name that you want. Just the parameter must be value change event type. And then you can write your logic. Like here this say defining the list of locale available from this country list. And they say if loc.getcountry equals event.getnewvalue, this event will give you the new value which was updated in a dropdown list box.

So this is form country. This is doing what? This is actually giving you a dropdown list box. And under that, you have list of value, multiple list of value. When you select one of the value from there, let's say here we have US, China. We can have here Japan, for example. When you select one of the value from here, that is going to be the current value will be here.

Depending on your choice, it is going to submit the request. That's why see here they have onchange equal to submit. This is JavaScript. That means you're going to generate the postback request. When you generate the postback request, the life cycle will begin. At the time of invoke applications, it is going to call form.countrychange method, which will see the value that you have submitted. Let's say US, I said. And if I go to here the code, event will carry the value that you have submitted. That is, you can get it through event.getnewvalue, which will be US. And then you can check here the locale. Locale is a Java object containing the country code and the language code. So this say loc.getcountry if it is equals to selected value-- that is US, for example-- then facescontext.getcurrentinstance.getviewroot.setlocale(loc).

The loc for the US locale will be set in your view rule. So the page that will be rendered to you will be rendered in US English. If you select here Chinese, then Chinese language, in Japanese language, like that. If you wish, you can separate the logic from the managed bean and put them in a different class. Here they're creating a class NameChanged implement in ValueChangeListener. And this way, you have to override method process value change, which will have the same signature as stated earlier in the case of bean methods for value change event. Value change event, and then here you can write your logic that you want to do when the value is getting changed. OK.

Registering a value change listener on a component. If you have a different class, a class that implements value change listener, then you can use JSF code library f:valueChangeListener to specify the class name that implements value change listener so that when you generate an event, or event is generated, when you make some changes, it will be handled by the process value change method found in name change. That's what you specified here.

There are several example which are available in example folder you can try. We can create autofill fields, and you can use the immediate attributes as well. It's an example of value change events.

Quiz. If you're designing a user interface, where the next page opens based on where a user clicks on a map graphic. All right, before I answer this quiz, I'm going to take you to have a look on the example, which they have it here in this folder, [INAUDIBLE] folder. They have two examples. One of them is Rushmore example. I'll just run it so that you see what is happening there. And then I'll explain this example.

All right, OK. So this is now, here you see the picture image. We can see here four faces. If I click on the first one, it's showing me the page containing the information for George Washington. If we go to the next, next face, different page, different person information. If we go to third, click on third face, see, different page. That means navigation is going to be default when I'm selecting that particular face.

What's happening there? It's one image, it's one button. If you see the code, index of [INAUDIBLE] contains one single button. It's not that you have multiple buttons. The only thing here, the button shows images. It has image attribute, and we specified here the image URL from this resource folder images, and we're specifying an image file that shows four faces.

Now this [INAUDIBLE] class in this button type, we see what happened there, action listener. And here, there's the action processing. When I hit the button, it processes the logic, event processing going on. At a time of invoke application, it first execute the action event handler methods, and then we're going to decide navigation through action processing logic method, which is in Navigate.

Now if I go back to this bean, and if you see the bean which is there, and the source package, this bean, what they have done is they have created multiple rectangle. This rectangle, they have created it here to identify the location where you're going to hit with the mouse. Remember, a rectangle what they have it here, like this, they have created the rectangle with given x- and y-coordinates. That's what here x and y and x and y, x and y, x and y, like that, they have specified.

When I'm clicking on a particular area, action event is letting me know x- and the y-coordinate were where I'm pointing and hitting the button. So we can calculate the x- and y-coordinate. We can find it, and we can check if that x and y point is the part of the rectangle that is surrounding the particle faces. This way, we've figured out that you click on the face one or face two or face three or face four, and then we're going to decide which page to go to.

Now that's what here they did. At the time of invoke applications, action listener, what they say, equal to rushmore.handlemouseclick. It will call this method. And this method, what you're doing it, you just have here faces context reference [INAUDIBLE]. With the e, you say get component, get client ID context. You can also obtain the client ID on which the action event was generated. With the context.getexternalcontext, I can obtain the request parameter map. Request parameter map has to be request object containing some parameter, some informations.

That map, I can obtain it. And once I get request parameter, I can say the request parameter associated with that particular client, client ID, point x client ID [INAUDIBLE]. x- and y-coordinate, I would like to find it on the button components, the client ID plus point x client ID plus point y. Actually the parameter that contains x and y and this HTTP request object that has the button ID .x, button ID .y. So that's why we obtain here the button ID, client ID on which is was first, x and y, and then we're converting it to the [INAUDIBLE] and holding it in x and y. Repeating here point object for the x and y and checking if the rectangle that we have created here, if it contains that point. This rectangle was holding x and y coordinates just to surround that particular faces that you have.

For four distinct faces, we're going to have four different rectangles. If you're hitting on those faces somewhere, then your x- and y-coordinate is going to be part of that particular rectangle, which will determine that outcome value is going to be Washington. Outcome value is going to be Jefferson. Like that, it is going to decide the outcome value.

Action listener processing is done. Then it's time to go for action processing, the last one, for navigation. [INAUDIBLE] navigate, say return outcome. They'll return these values. And these values are nothing. They are the page name, and you'll be navigated to those pages.

All right, President Washington. Lincoln. If I click anywhere else, then the same page is rendered to me. You can see here it is refreshing the contents. Sam page rendered to me because the outcome value remain null. It returns null, and you stay on the same page.

Quiz. If you're designing user interface where the next page opens based on where a user clicks on a map graphic, you need to implement what. C, an action listener that determines to compute the location of the click. With a value change event, you can create a user interface that changes the look of the application if the user enters a specific text string into an input text components.

With a value change event, you can create a user interface that changes the look of the application. Possible. Yes. True, we can.

What is the event model in complement that use the immediate true. Immediate true, remember, it lets the event be processed just after apply request value phase. Fire immediately following the Apply Request Value phase. All right? A. [INAUDIBLE] the right answer.

Let's see the list of the life cycle events which we say phase events. Phase listener, type equal to com.corejsf.phasetracker. You can do what? You can specify a class, implementing phase listener. The phase tracker is the class. They have implemented phase listener. And you can use, f:phaseListener is specify the class name. When you implement phase listener, you have to override multiple methods to track each phase events. You can also register this in the faces-config.xml file and saying life cycle, phase listener, and specifying the class that implements phase listener event for the whole applications. And this is for individual pages that you'd like to monitor or do something when that page is going to be part of the processing.

The next slide, you see that if you are implementing the phase listener in a class, you have to override three method, because this interface provides three methods to you. Get phase ID, after phase, and before phase. Let's say here is a code that they say before phase, after phase. And here you can specify the logger to record some information. And you can also invoke the phase ID to get the phase ID be printed. All right?

So this is what the complete class phase tracker implementing phase listener. Overriding getPhaseID, overriding beforePhase, overriding afterPhase. What you want to do once the phase is beginning, what you want to do after the phase. This is going to be processed with each life cycle phases.

Life cycle events, system events. It's a good way for the notification system that individual components will be able to notify you about life cycle events, because you have lifecycle callback methods. We have here see post construct [INAUDIBLE] application event, pre-destroy application event, life cycle callback events.

What you can do for this purpose. In a managed bean, in a managed bean, class A for example is my managed bean, in managed bean, if I type [INAUDIBLE] public void init. And I want to do something just after the class gets instantiated. I can here say @PostConstruct, which will help me to execute the set of instructions to do something just after the class gets instantiated.

Similarly, you can type predestroy on the method, which will be invoked automatically when an object is going for destructions. It means it is going for the garbage collections. Several life cycle events that you have here, it's application event. But you see that post restore state. Remember create and restore? You see post restore is an event. This method will be invoked just after restore view phase.

Pre validate, post validate. Before validation phase, after validation phase. Pre render view events. Before render response. Post construct view. A lot of options that you have it here that you can use to do something with the face events.

Here see there are four ways to receive system events. System events. f:event, input text value. Or this say f:event type equal to postValidate listener bean.method. Type what? Post validate. See these are the system event that you're not going to create an event. You're not going to initiate any events. This will be initiated automatically when you submit a page for the processing. And you have to receive those events to do something. I can say event type post validate, and listener equal to some method that I would like to execute when the post validate is happening. After validate, it is going to call this method.

With an annotations for a UI component or renderer class, if you have UI components or renderer classes, you can specify @listenerfor. And here you can specify system event class that implements your PreRenderViewEvent class. PreRenderViewEvent class, that is what you have it here. You specify that. That means it is going to listen to those events.

Or, you can [INAUDIBLE] faces.config file using system event listener. And it's specifying a listener class, and the event class. By calling the subscribe to event method, you can also subscribe to some system events for the particular UI components of an application class.

So we have here the options. See the code. What this say, f:event type equal to postValidate listener equal to bb.validate. That being just after validate phase, it is going to call this method. And in this method, you can specify something, log something, do something, write something. f:event type equal to preRenderView on the pages, listener equal to user.checkLogin. Before a page is going to be rendered back to the browser, PreRenderView. Before render, it is going to call user.checkLogin. And user.checkLogin, if you see that user has not logged in, you can decide to navigate to the login page. So that's what all about this chapter.
