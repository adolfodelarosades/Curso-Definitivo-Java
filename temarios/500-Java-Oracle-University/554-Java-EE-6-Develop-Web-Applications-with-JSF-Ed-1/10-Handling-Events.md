# 10: Handling Events

   * Handling Events - 35m
   * Activity 32,33,34 - 25m

## Handling Events - 35m

It's time for us to continue with chapter 10, handling events. We are reaching to advanced JSF last chapter. In this chapter, we're going to see the JSF event model and how to use action and the value change events. Apart from this, register event listener, and capturing and responding to life cycle events we will discuss in this chapter.

For this [INAUDIBLE] the topic which they have created here to let you understand the types of JSF events, event processing life cycle, value change event, action event, phase event, and system events. Let's start with the types of JSF event. JSF supports four types of events. Number one is value chain even. Number two, action event. Number three, phase event. Number four, system event.

The first two events are actually application events that you normally used for business processing. That means when you're changing the value of a particular component, like in dropdown list box and text boxes, we like to do something when the change happens. Take the help of value change event. Action event, when you're hitting the button, clicking the buttons, or hitting the Enter key on a particular component, like command button, command link, or simple buttons or a link that you may have, go link, go button, you can use action events over there.

Phase events, system events, they are life cycle events. When you submit a page for the request processing, we have multiple phases. If you'd like to capture those phases to do something, for auditing purpose, to log some information in a file that you're reaching to create a restore view phase, and now it is apply value phase, before that you want to do something, after that you want to do something, you can take the help of the phase events and the system events.

Events, select one manual, like here this say value change listener. Components like select one menu supports value change events. They have their attributes that you can use. Value chain listener attribute. You have to specify a method which is responsible for handling that event. And that method, you can create it in a managed bean class. Or you can create a separate class implementing value change listener, and by overriding value change event handler methods.

See the event processing life cycle phases with each phase of the life cycle [INAUDIBLE] apply request value phase you have the process events. You will be able to capture those events. What happened when the phase begins, what happened when the phase completed. You like to log those information, you can do this by capturing life cycle phase events.

Now application events we're going to discuss here are generated by the UI components. Includes subclasses of faces events. Application events, they are the subclass of the faces events, and there are two application events that you can see. One is action event, and the value change event. Normally what happened that these application events are processed at the time of invoke applications. Before action processing logic.

The first preference goes to value change event. Second, action event. And third to action processing logic. But we have other options to specify that we want to process all the events just after apply request value phase by saying [INAUDIBLE] properties [INAUDIBLE] that we will see a little later.

See here what they say. Action events. Action event that happens when you actually hit the button or the component that supports action event. You'd like to activate this event handling on a particular component, like command button, let's say, action listener. Action listener specifies the name of the method that can handle action event. And as I said earlier, this method can be in a managed bean, or it can be in a separate class that implements action listener interface.

If you have to do something with managed bean properties, you want to manipulate those data, you want to play with those data, read data or modify the data, on action event processing, we're of course going to put them into managed bean. So that's why here this say actions are designed for navigation and to perform business logic. Do not get confused with the action action action listener. Action here is for processing logic. Action processing logic. That includes navigations or to have some business logic to be included. Action listener is for action event handler methods, which you can write in a managed bean, or you can have a class, separate class implementing action listener interface.

If you have a managed bean and you want to write handler in the managed bean, you just go ahead and type any name that you want. Any name. In a managed bean class, have public. Write any name that you want. Just do not forget to have a parameter type, single parameter action event type. This will be action event handler methods in the managed bean.

You will have a faces context with you always that you can use to obtain the components ID. See, with the e you can get the components ID associated with the current context. You can also obtain the request parameter map. SGP request, SGP response object you want to do something with them, you can get it from the context. Parameters that you have in SGP request, you can leave them here in the event handing.

If you want, you can create a separate class. Like here they have a separate last location listener, and the say implement action listener. And there, once you implement action listener, you have to override the method that is process action. Here you have no choice, you need to use the same name, process action. And it's going to have the parameter action event. But in managed bean, you can type whatever the name that you like. Just the parameter action event.

In this, you just go ahead and write the logic that you'd like to do when you hit the button, or when you generate the action events. Either by clicking on the button, or by hitting Enter key. Registering an action listener on a components. See action listener equal to. If your action event handler is in a managed bean, then just give the name of the bean. DVD dock, and type the name of event handler method. Like here this say bean.choose a locale from link. Similarly, if it is in separate class that you have used to implement action listener, in that case you can use JSF code tag action listener, and say type equal to package name and the class name that implements action listener interface.

Immediate components, it's again very important here in the case of event processing. Immediate attributes on the components where you have included some events bypass the event processing life cycle and fire immediately following the Apply Request Value phase. Your event is going to be processed just after Apply Value phase.

Remember what I said earlier, if immediate is not available, then your action events, value change events are processed at that time of invoke applications completing apply value, update model-- or validations, update model, and then invoke applications. So immediately equal to true. It will [INAUDIBLE]. The events are going to be processed just after apply value phase, skipping the rest of event processing, life cycle processing.

So that's what they had to say, immediate input components fire events before the Process Validations phase, which is useful if you want to use the value of input to alter other elements of the form. So this is going to be useful when you have to play with the components' attributes and you want to manipulate the value of a component's state. The time of apply value, submitted value is going to be applied within the component state. And just after, if I process my event logic, I can play with those values and perform some manipulations. So that is what is possible. And then we can go for other phases.

Value change events. Here they say value change events occur when the user changes the value of a component that implements editable value holder. This is, again, an interface. This interface is implemented on those component which are editable. So if you have the generic list of the components and you want to check which components are editable, you can take the help of editable value holder and check if the component reference is in [INAUDIBLE] editable value holder or not. Just like you input text, dropdown list [INAUDIBLE] where you can do some changes. It is applicable on that. Select one menu is one of them which is editable value holder components. And here we can have value change listener.

Value change listener as well you can have a separate class that implements listener, value change event listener. Or, you can have a bean method. And there you can type methods containing a parameter for value change event. So this is the example of the bean method that you can use to handle the value change event. Whenever you change the value, it is going to process this bean method.

See this, where the country changed the bean method. And here, the parameter, they have value change event. In a managed bean you can type this, any name that you want. Just the parameter must be value change event type. And then you can write your logic. Like here this say defining the list of locale available from this country list. And they say if loc.getcountry equals event.getnewvalue, this event will give you the new value which was updated in a dropdown list box.

So this is form country. This is doing what? This is actually giving you a dropdown list box. And under that, you have list of value, multiple list of value. When you select one of the value from there, let's say here we have US, China. We can have here Japan, for example. When you select one of the value from here, that is going to be the current value will be here.

Depending on your choice, it is going to submit the request. That's why see here they have onchange equal to submit. This is JavaScript. That means you're going to generate the postback request. When you generate the postback request, the life cycle will begin. At the time of invoke applications, it is going to call form.countrychange method, which will see the value that you have submitted. Let's say US, I said. And if I go to here the code, event will carry the value that you have submitted. That is, you can get it through event.getnewvalue, which will be US. And then you can check here the locale. Locale is a Java object containing the country code and the language code. So this say loc.getcountry if it is equals to selected value-- that is US, for example-- then facescontext.getcurrentinstance.getviewroot.setlocale(loc).

The loc for the US locale will be set in your view rule. So the page that will be rendered to you will be rendered in US English. If you select here Chinese, then Chinese language, in Japanese language, like that. If you wish, you can separate the logic from the managed bean and put them in a different class. Here they're creating a class NameChanged implement in ValueChangeListener. And this way, you have to override method process value change, which will have the same signature as stated earlier in the case of bean methods for value change event. Value change event, and then here you can write your logic that you want to do when the value is getting changed. OK.

Registering a value change listener on a component. If you have a different class, a class that implements value change listener, then you can use JSF code library f:valueChangeListener to specify the class name that implements value change listener so that when you generate an event, or event is generated, when you make some changes, it will be handled by the process value change method found in name change. That's what you specified here.

There are several example which are available in example folder you can try. We can create autofill fields, and you can use the immediate attributes as well. It's an example of value change events.

Quiz. If you're designing a user interface, where the next page opens based on where a user clicks on a map graphic. All right, before I answer this quiz, I'm going to take you to have a look on the example, which they have it here in this folder, [INAUDIBLE] folder. They have two examples. One of them is Rushmore example. I'll just run it so that you see what is happening there. And then I'll explain this example.

All right, OK. So this is now, here you see the picture image. We can see here four faces. If I click on the first one, it's showing me the page containing the information for George Washington. If we go to the next, next face, different page, different person information. If we go to third, click on third face, see, different page. That means navigation is going to be default when I'm selecting that particular face.

What's happening there? It's one image, it's one button. If you see the code, index of [INAUDIBLE] contains one single button. It's not that you have multiple buttons. The only thing here, the button shows images. It has image attribute, and we specified here the image URL from this resource folder images, and we're specifying an image file that shows four faces.

Now this [INAUDIBLE] class in this button type, we see what happened there, action listener. And here, there's the action processing. When I hit the button, it processes the logic, event processing going on. At a time of invoke application, it first execute the action event handler methods, and then we're going to decide navigation through action processing logic method, which is in Navigate.

Now if I go back to this bean, and if you see the bean which is there, and the source package, this bean, what they have done is they have created multiple rectangle. This rectangle, they have created it here to identify the location where you're going to hit with the mouse. Remember, a rectangle what they have it here, like this, they have created the rectangle with given x- and y-coordinates. That's what here x and y and x and y, x and y, x and y, like that, they have specified.

When I'm clicking on a particular area, action event is letting me know x- and the y-coordinate were where I'm pointing and hitting the button. So we can calculate the x- and y-coordinate. We can find it, and we can check if that x and y point is the part of the rectangle that is surrounding the particle faces. This way, we've figured out that you click on the face one or face two or face three or face four, and then we're going to decide which page to go to.

Now that's what here they did. At the time of invoke applications, action listener, what they say, equal to rushmore.handlemouseclick. It will call this method. And this method, what you're doing it, you just have here faces context reference [INAUDIBLE]. With the e, you say get component, get client ID context. You can also obtain the client ID on which the action event was generated. With the context.getexternalcontext, I can obtain the request parameter map. Request parameter map has to be request object containing some parameter, some informations.

That map, I can obtain it. And once I get request parameter, I can say the request parameter associated with that particular client, client ID, point x client ID [INAUDIBLE]. x- and y-coordinate, I would like to find it on the button components, the client ID plus point x client ID plus point y. Actually the parameter that contains x and y and this HTTP request object that has the button ID .x, button ID .y. So that's why we obtain here the button ID, client ID on which is was first, x and y, and then we're converting it to the [INAUDIBLE] and holding it in x and y. Repeating here point object for the x and y and checking if the rectangle that we have created here, if it contains that point. This rectangle was holding x and y coordinates just to surround that particular faces that you have.

For four distinct faces, we're going to have four different rectangles. If you're hitting on those faces somewhere, then your x- and y-coordinate is going to be part of that particular rectangle, which will determine that outcome value is going to be Washington. Outcome value is going to be Jefferson. Like that, it is going to decide the outcome value.

Action listener processing is done. Then it's time to go for action processing, the last one, for navigation. [INAUDIBLE] navigate, say return outcome. They'll return these values. And these values are nothing. They are the page name, and you'll be navigated to those pages.

All right, President Washington. Lincoln. If I click anywhere else, then the same page is rendered to me. You can see here it is refreshing the contents. Sam page rendered to me because the outcome value remain null. It returns null, and you stay on the same page.

Quiz. If you're designing user interface where the next page opens based on where a user clicks on a map graphic, you need to implement what. C, an action listener that determines to compute the location of the click. With a value change event, you can create a user interface that changes the look of the application if the user enters a specific text string into an input text components.

With a value change event, you can create a user interface that changes the look of the application. Possible. Yes. True, we can.

What is the event model in complement that use the immediate true. Immediate true, remember, it lets the event be processed just after apply request value phase. Fire immediately following the Apply Request Value phase. All right? A. [INAUDIBLE] the right answer.

Let's see the list of the life cycle events which we say phase events. Phase listener, type equal to com.corejsf.phasetracker. You can do what? You can specify a class, implementing phase listener. The phase tracker is the class. They have implemented phase listener. And you can use, f:phaseListener is specify the class name. When you implement phase listener, you have to override multiple methods to track each phase events. You can also register this in the faces-config.xml file and saying life cycle, phase listener, and specifying the class that implements phase listener event for the whole applications. And this is for individual pages that you'd like to monitor or do something when that page is going to be part of the processing.

The next slide, you see that if you are implementing the phase listener in a class, you have to override three method, because this interface provides three methods to you. Get phase ID, after phase, and before phase. Let's say here is a code that they say before phase, after phase. And here you can specify the logger to record some information. And you can also invoke the phase ID to get the phase ID be printed. All right?

So this is what the complete class phase tracker implementing phase listener. Overriding getPhaseID, overriding beforePhase, overriding afterPhase. What you want to do once the phase is beginning, what you want to do after the phase. This is going to be processed with each life cycle phases.

Life cycle events, system events. It's a good way for the notification system that individual components will be able to notify you about life cycle events, because you have lifecycle callback methods. We have here see post construct [INAUDIBLE] application event, pre-destroy application event, life cycle callback events.

What you can do for this purpose. In a managed bean, in a managed bean, class A for example is my managed bean, in managed bean, if I type [INAUDIBLE] public void init. And I want to do something just after the class gets instantiated. I can here say @PostConstruct, which will help me to execute the set of instructions to do something just after the class gets instantiated.

Similarly, you can type predestroy on the method, which will be invoked automatically when an object is going for destructions. It means it is going for the garbage collections. Several life cycle events that you have here, it's application event. But you see that post restore state. Remember create and restore? You see post restore is an event. This method will be invoked just after restore view phase.


## Activity 32,33,34 - 25m

Let's begin with the practice for lesson 10, handling event. This practice, we're going to implement preferences page and add in the capability of changing the languages without having to alter the browser language setting. So depending on the user choice, we will decide whether they would like to see the application in English or in German language.

10.1, it's about implementing preferences pages. They would like you to have a page like this so that you can decide the [? list.xhtml ?] that shows the content should display title, EAR, or [? genre, ?] or only title, or only EAR, or the combination of any one of them. So for this purpose, we're just going to prepare our managed bean class with the name [? preps ?]. And as well, we're going to create it in [? com.example ?] beans.

We will have here Boolean properties so that we can capture the user choice. And accordingly, we're going to render the column. First job is to go back to DVD library applications and, in this application, have a managed bean added into this package. New. I can say new Java class. Name, what it's listed as [? preps.java ?]. And as well you can type it here [? implements ?] [INAUDIBLE], because we're going to use name bean. Give here [? @name ?] [? annotations, ?] [? session ?] [? scope ?]. And click to [? fix ?] import.

The spelling mistake, so you can fix it here. Just remove it. And now you again say [? fix ?] import. OK. Good.

Under this, they want you to have three properties to capture your choice from the page that you will create. These three properties are for the title, genre, and for the [INAUDIBLE]. We can have [INAUDIBLE] for all of them. Insert code, and [INAUDIBLE]. Good.

So that's what here they say in this constructor, you can decide the default value for them. By default, it's going to be false, but we're going to want to set them to true. So I'm just going to have this constructor added into my page, [INAUDIBLE] [? .javabeans ?], and I'm just going to add it here, constructor. And this constructor, we are initializing the value for them as true.

Next, have a [? prep.xhtml ?] file open. It's already created, so we're just going to open it. And we have here Back button. Or if you want, you can let it be there. And they say change the command link placeholder to a button [INAUDIBLE] from the [? message ?] bundle. That's what we will make the changes.

And then we can have a panel grid. And in this panel grid, we can have multiple checkboxes added. Very first, let's change this value part to command button. It's already there.

All right. Now we just type here [? back ?] [? home. ?] Now we don't need. Delete it. We can say here close, and say, value equal to [? read ?] [? it ?] [? from ?] the [? message ?] bundle.

[INAUDIBLE] properties that they want you to have it here, that is [? btn_preps. ?] This one. All right, good. After that, within this form, what we can have it, we can have a panel grid inside the form. And within the panel grid, we're just going to have all those check boxes.

OK, panel grid. And then this [? says ?] bundle [? will be reading ?] the caption label from there, column title. And then we're going to have a check box. When [? inside ?] the check box, you check uncheck. Depending on your selection, the value will be updated and perhaps the title.

All right. Second one. OK, now the panel grid is closed. And the form is closed.

All right. On the [? list.xhtml, ?] we need to specify [? rendered ?] properties so that column can be rendered or cannot be rendered. And this is going to be determined by the value of managed bean preps title, EAR, or genre.

So each one column, you have to use this. I'm just going to go with [? list.xhtml. ?] And see now here we have a column one, first column. This column is for what? For the title. We can decide here render. I'm not going to say true and false, I'm just going to [? read ?] this form my managed bean preps, which was set up with the help of given check boxes.

So I can say here title. Same thing I can repeat it with other column as well. Make sure that you type right properties in the right column. This is for [INAUDIBLE]. And then I'm going to do this with the column genre. Title, render properties.

All right. Once you do this all, you can redeploy your application and check how it goes. So let's go back to this. Save it. Save the changes.

All right, this is going for redeployment. And now we can initiate a first request to this page. Type here username, password. It is showing me all the column right now, because all of them are by default true. Now if you say Set User Preferences, you have-- see the option-- they're by default checked.

I just want to see the DVD title and the EAR. I just unchecked one of them. OK. We do not have here the button. Let's click on Update Preferences. And see, it is going to show you [? list.xhtml, ?] but only two column. Go back to Set Preferences, and say you just want to see one column. Only one column.

So that's what all about the practices. Remember in this practice, here you have Update Preferences. I'm using command link, though they have suggested that should be command button. You can change it and put them down just after all the check boxes. Just to give them a similar look.

So command link, which I have it here, I can put them down. It doesn't matter [INAUDIBLE] look and feel, and make it command button. Save it.

All right. Try it. See now we're getting here button.

Same thing you do if you want to see both. You want to see these two. And by default, it is going to be all true, because you set that value in constructor. Good.

Next practice is little long practice, because here we have to configure our applications to accept user selection for localizations. So you first have to make changes in my page, [? prep.xhtml ?] page, so that the user can have these type of options to select. And for that, you have to copy some images and make some changes here. And to let your [? Faces ?] context be updated with requested locale, you have to type this code in your bean.

So what they're saying here, copy the locale, change the Java class from this resource locale directory and paste it to the bean's package. We'll do this. Resources I have here the locale folder, a [? localechange.java ?], copy and paste it to the bean's package.

Open this. See? [? com.example ?] [? bean's ?] perfectly right. It's a managed bean. Name is Locale. If you want to default this property, you call Locale. And it has here the method [? lang ?] [? changed ?], which is updating the [? Faces ?] context with your choice of locale.

Now what else? Design your [? preps.xhtml ?] to give the choice to the user. And here they say that we want to have the command link so that locale change can be possible. And we have to display images as well. So what they're doing here, in the panel group that you already have it, or if you want you can have a new panel group, you just have a command link [? immediately ?] equal to true, [? action ?] equal to [? locale.linechanged ?], and have an image. So the link will be displayed as an image. So your graphic image is going to be surrounded by the command link.

Very first, we need to add this JSF [? core ?] libraries and have this all information be added. I'm just going to copy this information on the page. Let's [INAUDIBLE] the form, paste it. And let's see what we have done it one by one, it is going to display the message, some messages waiting from resource bundle.

Then we're going to have a panel group. In this panel group, we're going to have a command link. This command link is surrounding your images. We do not have image right now. We need to put them here. Let's check whether we have the images available or not.

These images, we need to copy it from the resource file. We'll do that. And the next one is going to have another command link for the US flag.

So you've got two command links and two images. And we have a panel group. It's a different group, so you can create a panel group.

Let's copy these two images which is available to you in the source image directory to your web locations. So I'm just going to copy these two images from here-- one and two-- copy them back to [? image. ?] All right, see that graphic image libraries equal to images, it is referring to this folder available under Resources. This we don't need here. Just delete it. All right, good.

Now see command link. When I click on the command link, which is now [? of ?] an image, the value's going to be image type, what value you want to be initiated. See the command link value, it does not have the value binding. We're not going to type anything. It is not input type, that we type and then we have a value binding that can be assigned to the bean properties. [? But ?] we want. If I click on this link, we want some value to be assigned to my bean locale.

For this purpose, we have to take the help of setPropertyActionListener tag. This is in JSF [? core ?] libraries. The setPropertyActionListener tag will do what? Will help you to assign the value of your choice to a particular bean properties. So here they say value equal to DE will be assigned to [? locale.language ?]. When they hit on second command link, and value equal to EN will be assigned to [? locale.language ?].

Once it is assigned to [? locale.language ?] at the time of update model, then you're going for invoke application, you're going for-- what you say-- render response. But look what, this say [INAUDIBLE] equal to true. That means the action listener property is going to processed just after Apply Value phase. Apply Value phase. And once the value's updated in your locale bean, which is here locale changer, this is the line-change method that we have to find it, we have to call it so that it can update the current [? Faces ?], [? Faces ?] context, locale.

See what next. This say because the context is reset during the life cycle of JSF applications, you need to add a [? root ?] view tag the master layout. Master layout template. You know why? Because if you do it there, it will be applicable on every page that is implementing master layout. This is one of the benefits of template.

So in this master layout, they want you to add f:view locale and [? locale.currentlocking ?]. [INAUDIBLE] [? HTML ?] tag you do this. So I'm just going to type it in my master layout. Master layout, it is in template [? just after ?] [? HTML ?]. And here, you can close it.

This is f:view. This tag is available to you in JSF [? core ?] libraries. So you must have here JSF [? core ?] libraries added. I can type here a new set of [? core ?] libraries for JSF [? core ?]. See now I can copy this and paste it one more time, and make appropriate changes for JSF [? core ?]. And I'm going to type it here [? f. ?] That's what they wanted you to do it here.

Save the master layout, and then open [? purse.xhtml ?]. This XHTML page is going to use the master layout template. UI composition template [? equals ?] the master layout template. You have to use it. So go to-- let's save it here. And see the [? preps.xhtml ?], this one.

UI composition that you have it here template [? masterlayout.xhtml ?]. It's already there. You will define heading. You can have the heading, the content is all there.

Now they say have this Facelets tag added into the root of XHTML tag in your [? preps.xhtml ?]. And add the following tags above the form tag at the beginning of the page. At the beginning of the page. And at the end of the page, they say add it.

So we'll do this. We can add this [? URL ?]. Now once you complete this step and save it, you see what they have the next? They want you to add a UI composition so template can be implemented on the [? preps.xhtml ?]. So see the [? preps.xhtml, ?] the template is already implemented. If it is so that it is already implemented, UI compositions and all those things, then you do not have to do this all. In case if it is not available, not done, then you just add UI composition at the top of the form, and close it at the bottom at the end of the page so that everything's going to be a part of [? you ?] define content and [? you ?] define heading. So I don't have to do it here because I found everything is already there.

Now if you see this page, refresh it. You will see it here that you have two command link which is displayed in the form of the images for German and for US. If I click on the first option, it is going to change the locale of your page, making it German. You see that second one, it displaying everything in English. So once you update the locale, it is actually doing what? It is using that [INAUDIBLE] resource bundles, and everything that you have used from the beginning, [? MSGF ?] name, [? MSG ?] column title, is all going to be read from the German from this default locale. So that's all about this practice.

Pre validate, post validate. Before validation phase, after validation phase. Pre render view events. Before render response. Post construct view. A lot of options that you have it here that you can use to do something with the face events.

Here see there are four ways to receive system events. System events. f:event, input text value. Or this say f:event type equal to postValidate listener bean.method. Type what? Post validate. See these are the system event that you're not going to create an event. You're not going to initiate any events. This will be initiated automatically when you submit a page for the processing. And you have to receive those events to do something. I can say event type post validate, and listener equal to some method that I would like to execute when the post validate is happening. After validate, it is going to call this method.

With an annotations for a UI component or renderer class, if you have UI components or renderer classes, you can specify @listenerfor. And here you can specify system event class that implements your PreRenderViewEvent class. PreRenderViewEvent class, that is what you have it here. You specify that. That means it is going to listen to those events.

Or, you can [INAUDIBLE] faces.config file using system event listener. And it's specifying a listener class, and the event class. By calling the subscribe to event method, you can also subscribe to some system events for the particular UI components of an application class.

So we have here the options. See the code. What this say, f:event type equal to postValidate listener equal to bb.validate. That being just after validate phase, it is going to call this method. And in this method, you can specify something, log something, do something, write something. f:event type equal to preRenderView on the pages, listener equal to user.checkLogin. Before a page is going to be rendered back to the browser, PreRenderView. Before render, it is going to call user.checkLogin. And user.checkLogin, if you see that user has not logged in, you can decide to navigate to the login page. So that's what all about this chapter.
