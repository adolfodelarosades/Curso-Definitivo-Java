# Capítulo 1.Comprender la persistencia de objetos/relaciones

### Chapter 1. Understanding object/relational persistence

* 1.1. What is persistence?

   * 1.1.1. Relational databases

   * 1.1.2. Understanding SQL

   * 1.1.3. Using SQL in Java

* 1.2. The paradigm mismatch

   * 1.2.1. The problem of granularity

   * 1.2.2. The problem of subtypes

   * 1.2.3. The problem of identity

   * 1.2.4. Problems relating to associations

   * 1.2.5. The problem of data navigation

* 1.3. ORM and JPA

* 1.4. Summary


***En este capítulo***

* Persistencia con bases de datos SQL en aplicaciones Java

* El desajuste del paradigma objeto/relacional

* Presentamos ORM, JPA e Hibernate

Este libro trata sobre **Hibernate**; nuestro enfoque es usar **Hibernate** como proveedor de la **API de persistencia de Java**. Cubrimos características básicas y avanzadas y describimos algunas formas de desarrollar nuevas aplicaciones usando **Java Persistence**. A menudo, estas recomendaciones no son específicas de **Hibernate**. A veces son nuestras propias ideas sobre las mejores formas de hacer las cosas cuando se trabaja con datos persistentes, explicadas en el contexto de **Hibernate**.

El enfoque para administrar datos persistentes ha sido una decisión de diseño clave en cada proyecto de software en el que hemos trabajado. Dado que los datos persistentes no son un requisito nuevo o inusual para las aplicaciones **Java**, esperaría poder hacer una elección simple entre soluciones de persistencia similares y bien establecidas. Piense en marcos de aplicaciones web (**JavaServer Faces** versus **Struts versus GWT**), componente GUI frameworks (**Swing** frente a **SWT**), o motores de plantillas (**JSP** frente a **Thymeleaf**). Cada una de las soluciones de la competencia tiene varias ventajas y desventajas, pero todas comparten el mismo alcance y enfoque general. Desafortunadamente, este aún no es el caso con las tecnologías de persistencia, donde vemos algunas soluciones muy diferentes para el mismo problema.

La persistencia siempre ha sido un tema candente de debate en la comunidad de **Java**. ¿Es la persistencia un problema que ya está resuelto por **SQL** y extensiones como los **procedimientos almacenados**, o es un problema más generalizado que debe ser abordado por modelos de componentes especiales de **Java**, como **EJB**? ¿Deberíamos codificar a mano incluso las operaciones **CRUD** (crear, leer, actualizar, eliminar) más primitivas en **SQL** y **JDBC**, o debería automatizarse este trabajo? ¿Cómo logramos la portabilidad si cada sistema de administración de bases de datos tiene su propio ***dialecto SQL***? ¿Deberíamos abandonar **SQL** por completo y adoptar una tecnología de base de datos diferente, como sistemas de bases de datos de objetos o sistemas **NoSQL**? Es posible que el debate nunca termine, pero una solución llamada **mapeo de objetos/relaciones(ORM)** ahora tiene una amplia aceptación, gracias en gran parte a las innovaciones de **Hibernate**, una implementación de servicio **ORM** de código abierto.

Antes de que podamos comenzar con **Hibernate**, debe comprender los problemas centrales de la persistencia de objetos y **ORM**. Este capítulo explica por qué necesita herramientas como **Hibernate** y especificaciones como la **API de persistencia de Java** (**JPA**).

Primero, definimos la gestión de datos persistentes en el contexto de las aplicaciones orientadas a objetos y discutimos la relación de **SQL**, **JDBC** y **Java**, las tecnologías y estándares subyacentes sobre los que se basa **Hibernate**. Luego discutimos el llamado desajuste de **paradigma objeto/relacional** y los problemas genéricos que encontramos en el desarrollo de software orientado a objetos con **bases de datos SQL**. Estos problemas dejan en claro que necesitamos herramientas y patrones para minimizar el tiempo que tenemos que dedicar al código relacionado con la persistencia en nuestras aplicaciones.

La mejor manera de aprender **Hibernate** no es necesariamente lineal. Entendemos que es posible que desee probar **Hibernate** de inmediato. Si así es como desea proceder, salte al siguiente capítulo y configure un proyecto con el **ejemplo "Hello World"**. Le recomendamos que regrese aquí en algún momento a medida que avanza en este libro; de esa manera, estará preparado y tendrá todos los conceptos básicos que necesita para el resto del material.

## 1.1. ¿Qué es la persistencia?

Casi todas las aplicaciones requieren datos persistentes. La persistencia es uno de los conceptos fundamentales en el desarrollo de aplicaciones. Si un sistema de información no conserva los datos cuando se apaga, el sistema sería de poca utilidad práctica. La persistencia de objetos significa que los objetos individuales pueden sobrevivir al proceso de aplicación; se pueden guardar en un almacén de datos y volver a crear en un momento posterior. Cuando hablamos de **persistencia en Java, normalmente nos referimos a mapear y almacenar instancias de objetos en una base de datos usando SQL**. Empezamos echando un breve vistazo a la tecnología y cómo se usa en **Java**. Armados con esta información, continuamos nuestra discusión sobre la persistencia y cómo se implementa en las aplicaciones orientadas a objetos.

### 1.1.1. Bases de datos relacionales

Usted, como la mayoría de los ingenieros de software, probablemente haya trabajado con **SQL** y bases de datos relacionales; muchos de nosotros manejamos tales sistemas todos los días. Los sistemas de administración de bases de datos relacionales tienen interfaces de programación de aplicaciones basadas en **SQL**; por lo tanto, llamamos a los productos de bases de datos relacionales actuales ***sistemas de administración de bases de datos SQL (DBMS)*** o, cuando hablamos de sistemas particulares, ***bases de datos SQL***.

La tecnología relacional es una cantidad conocida, y esto por sí solo es razón suficiente para que muchas organizaciones la elijan. Pero decir sólo esto es mostrar menos respeto del debido. Las bases de datos relacionales están arraigadas porque son un enfoque increíblemente flexible y sólido para la gestión de datos. Debido a la base teórica bien investigada del modelo de datos relacionales, las bases de datos relacionales pueden garantizar y proteger la integridad de los datos almacenados, entre otras características deseables. Es posible que esté familiarizado con la introducción del ***modelo relacional de EF Codd*** hace cuatro décadas, A Relational Model of Data for Large Shared Data Banks ( Codd, 1970 ). Un compendio más reciente que vale la pena leer, con un enfoque en SQL, es el de CJ DateSQL y Teoría Relacional ( Fecha, 2009 ).

Los **DBMS** relacionales no son específicos de **Java**, ni una base de datos SQL es específica de una aplicación en particular. Este importante principio se conoce como independencia de datos. En otras palabras, y no podemos enfatizar lo suficiente este hecho importante, los datos duran más que cualquier aplicación. La tecnología relacional proporciona una forma de compartir datos entre diferentes aplicaciones, o entre diferentes partes del mismo sistema general (la aplicación de ingreso de datos y la aplicación de informes, por ejemplo). La tecnología relacional es un denominador común de muchos sistemas y plataformas tecnológicas dispares. Por lo tanto, el modelo de datos relacionales suele ser la base para la representación común de las entidades comerciales en toda la empresa.

Antes de entrar en más detalles sobre los aspectos prácticos de las bases de datos **SQL**, debemos mencionar un tema importante: aunque se comercializa como relacional, un sistema de base de datos que proporciona solo una interfaz de lenguaje de datos **SQL** no es realmente relacional y, en muchos sentidos, ni siquiera lo es cerca del concepto original. Naturalmente, esto ha llevado a la confusión. Los practicantes de **SQL** culpan al modelo de datos relacionales por las deficiencias en el lenguaje **SQL**, y los expertos en gestión de datos relacionales culpan al **estándar SQL** por ser una implementación débil del modelo y los ideales relacionales. Los ingenieros de aplicaciones están atrapados en algún punto intermedio, con la carga de entregar algo que funcione. Destacamos algunos aspectos importantes y significativos de este tema a lo largo de este libro, pero generalmente nos enfocamos en los aspectos prácticos. Problemas prácticos en la gestión de bases de datos: una referencia para el profesional del pensamiento de Fabian Pascal ( Pascal, 2000 ) y una introducción a los sistemas de bases de datos de Chris Date ( Date, 2003 ) para la teoría, los conceptos y los ideales de los sistemas de bases de datos (relacionales). Este último libro es una excelente referencia (es grande) para todas las preguntas que pueda tener sobre las bases de datos y la gestión de datos.

### 1.1.2. Entendiendo SQL

Para usar **Hibernate** de manera efectiva, ***debe comenzar con una sólida comprensión del modelo relacional y SQL***. Debe comprender el modelo relacional y temas como ***la normalización*** para garantizar ***la integridad de sus datos***, y deberá utilizar su ***conocimiento de SQL*** para ajustar el ***rendimiento de su aplicación Hibernate***. **Hibernate** automatiza muchas tareas de codificación repetitivas, pero su conocimiento de la tecnología de persistencia debe extenderse más allá de **Hibernate** si desea aprovechar todo el poder de las bases de datos SQL modernas. Para profundizar, consulte la bibliografía al final de este libro.

Probablemente haya utilizado **SQL** durante muchos años y esté familiarizado con las operaciones y sentencias básicas escritas en este lenguaje. Aún así, sabemos por nuestra propia experiencia que **SQL** a veces es difícil de recordar, y algunos términos varían en el uso.

Revisemos algunos de los términos de **SQL** utilizados en este libro. Utiliza **SQL** como un **lenguaje de definición de datos** (**DDL**) al crear , modificar y colocar artefactos como tablas y restricciones en el catálogo del **DBMS**. Cuando este esquema esté listo, use **SQL** como un **lenguaje de manipulación de datos** (**DML**) para realizar operaciones en los datos, incluidas inserciones, actualizaciones y eliminaciones . Recupera datos ejecutando consultas con restricciones, proyecciones y productos cartesianos . Para informes eficientes, utilice SQL para unir, agregar y agrupar los datos según sea necesario. Incluso puede anidar instrucciones SQL una dentro de otra, una técnica que utiliza subselecciones. Cuando cambien los requisitos de su negocio, tendrá que modificar el esquema de la base de datos nuevamente con declaraciones **DDL** después de que se hayan almacenado los datos; esto se conoce como evolución del esquema .

Si es un veterano de **SQL** y quiere saber más sobre la optimización y cómo se ejecuta **SQL**, obtenga una copia del excelente libro ***SQL Tuning, de Dan Tow ( Tow, 2003 )***. Para ver el lado práctico de **SQL** a través de la lente de ***cómo no usar SQL***, ***SQL Antipatterns: Avoiding the Pitfalls of Database Programming ( Karwin, 2010 )*** es un buen recurso.

Aunque la base de datos **SQL** es una parte de **ORM**, la otra parte, por supuesto, consiste en ***los datos de su aplicación Java*** que deben conservarse y cargarse desde la base de datos.

### 1.1.3. Usando SQL en Java

Cuando trabaja con una base de datos **SQL** en una aplicación **Java**, emite declaraciones **SQL** a la base de datos a través de la **API de conectividad de base de datos Java** (**JDBC**). Ya sea que el **SQL** se haya escrito a mano e incrustado en el código **Java** o se haya generado sobre la marcha mediante el código **Java**, utilice la **API de JDBC** para vincular argumentos al preparar los parámetros de consulta, ejecutar la consulta, desplazarse por el resultado de la consulta y recuperar valores del resultado. establecer, y así sucesivamente. Estas son tareas de acceso a datos de bajo nivel; como ingenieros de aplicaciones, estamos más interesados en el problema comercial que requiere este acceso a los datos. Lo que realmente nos gustaría escribir es un código que guarde y recupere instancias de nuestras clases, liberándonos de esta monotonía de bajo nivel.

Debido a que estas tareas de acceso a datos suelen ser tan tediosas, debemos preguntarnos si el modelo de datos relacionales y (especialmente) **SQL** son las opciones correctas para la persistencia en aplicaciones orientadas a objetos. Respondemos a esta pregunta inequívocamente: ¡sí! Hay muchas razones por las que las bases de datos **SQL** dominan la industria informática: los sistemas de gestión de bases de datos relacionales son la única tecnología de gestión de datos genérica comprobada y casi siempre son un requisito en los proyectos de **Java**.

Tenga en cuenta que no estamos afirmando que la tecnología relacional sea siempre la mejor solucion. Hay muchos requisitos de gestión de datos que justifican un enfoque completamente diferente. Por ejemplo, los sistemas distribuidos a escala de Internet (motores de búsqueda web, redes de distribución de contenido, intercambio entre pares, mensajería instantánea) tienen que lidiar con volúmenes de transacciones excepcionales. Muchos de estos sistemas no requieren que después de que se complete una actualización de datos, todos los procesos vean los mismos datos actualizados (coherencia transaccional sólida). Los usuarios pueden estar contentos con una consistencia débil; después de una actualización, puede haber una ventana de inconsistencia antes de que todos los procesos vean los datos actualizados. Algunas aplicaciones científicas funcionan con conjuntos de datos enormes pero muy especializados. Dichos sistemas y sus desafíos únicos generalmente requieren soluciones de persistencia igualmente únicas y, a menudo, personalizadas.

#### Sistemas relacionales a escala de internet

Para comprender por qué los sistemas relacionales y las garantías de integridad de datos asociadas a ellos son difíciles de escalar, le recomendamos que primero se familiarice con el **teorema CAP**. De acuerdo con esta regla, un sistema distribuido no puede ser consistente, disponible y tolerante contra fallas de partición, todo al mismo tiempo.

Un sistema puede garantizar que todos los nodos verán los mismos datos al mismo tiempo y que las solicitudes de lectura y escritura de datos siempre se responderán. Pero cuando una parte del sistema falla debido a un problema del host, la red o el centro de datos, debe renunciar a una consistencia fuerte (linealización) o al 100 % de disponibilidad. En la práctica, esto significa que necesita una estrategia que detecte fallas en la partición y restablezca la consistencia o la disponibilidad hasta cierto punto (por ejemplo, haciendo que alguna parte del sistema no esté disponible temporalmente para que la sincronización de datos ocurra en segundo plano). A menudo, depende de los datos, el usuario o la operación si es necesaria una consistencia sólida.

Para **DBMS** relacionales diseñados para escalar fácilmente, eche un vistazo a **VoltDB** ( www.voltdb.com ) y **NuoDB** ( www.nuodb.com ). Otra lectura interesante es cómo Google escala su base de datos más importante, para el negocio de la publicidad, y por qué es relacional/SQL, en "F1: el **RDBMS** distribuido tolerante a fallas que respalda el negocio publicitario de Google" ( Shute, 2012 ) .

En este libro, pensaremos en los problemas de almacenamiento y uso compartido de datos en el contexto de una aplicación orientada a objetos que utiliza un modelo de dominio. En lugar de trabajar directamente con las filas y columnas de un **`java.sql.ResultSet`**, la lógica comercial de una aplicación interactúa con el modelo de dominio orientado a objetos específico de la aplicación. Si el esquema SQL de base de datos de un sistema de subastas en línea tiene las tablas **`ITEM`** y **`BID`**, por ejemplo, la aplicación **Java** define las clases **`Item`** y **`Bid`**. En lugar de leer y escribir el valor de una fila y columna en particular con la API **`ResultSet`**, la aplicación carga y almacena instancias de las clases **`Item`** y **`Bid`**.

Por lo tanto, en tiempo de ejecución, la aplicación opera con instancias de estas clases. Cada instancia de a **`Bid`** tiene una referencia a una subasta **`Item`** y cada una **`Item`** puede tener una colección de referencias a instancias **`Bid`**. La lógica empresarial no se ejecuta en la base de datos (como un procedimiento almacenado de **SQL**); se implementa en **Java** y se ejecuta en el nivel de aplicación. Esto permite que la lógica empresarial utilice conceptos sofisticados orientados a objetos, como la ***herencia*** y el ***polimorfismo***. Por ejemplo, podríamos usar **patrones de diseño** bien conocidos como **Strategy**, **Mediator** y **Composite** (ver **Design Patterns: Elements of Reusable Object-Oriented Software [ Gamma, 1995]**), todos los cuales dependen de llamadas a métodos polimórficos.

Ahora una advertencia: no todas las aplicaciones **Java** están diseñadas de esta manera, ni deberían estarlo. Las aplicaciones simples pueden estar mucho mejor sin un modelo de dominio. Use el JDBC **`ResultSet`** si eso es todo lo que necesita. Llame a los procedimientos almacenados existentes y lea también sus conjuntos de resultados **SQL**. Muchas aplicaciones necesitan ejecutar procedimientos que modifican grandes conjuntos de datos, cerca de los datos. Puede implementar alguna funcionalidad de generación de informes con consultas SQL simples y mostrar el resultado directamente en la pantalla. **SQL** y la **API de JDBC** son perfectamente útiles para manejar representaciones de datos tabulares, y JDBC **`RowSet`** facilita aún más las operaciones **CRUD**. Trabajar con una representación de este tipo de datos persistentes es sencillo y se entiende bien.

Pero en el caso de aplicaciones con lógica de negocios no trivial, el enfoque del **modelo de dominio** ayuda a mejorar significativamente la reutilización y el mantenimiento del código. En la práctica, ambas estrategias son comunes y necesarias.

Durante varias décadas, los desarrolladores han hablado de un desajuste de paradigma . Este desajuste explica por qué cada proyecto empresarial dedica tanto esfuerzo a las preocupaciones relacionadas con la persistencia. Los paradigmas a los que se hace referencia son el **modelado de objetos** y el **modelado relacional** o, más prácticamente, **la programación orientada a objetos** y **SQL**.

Con esta comprensión, puede comenzar a ver los problemas, algunos bien entendidos y otros menos entendidos, que debe resolver una aplicación que combina ambas representaciones de datos: ***un modelo de dominio orientado a objetos*** y ***un modelo relacional persistente***. Echemos un vistazo más de cerca a este llamado ***desajuste de paradigma***.

## 1.2. El desajuste del paradigma

***El desajuste del paradigma objeto/relacional se puede dividir en varias partes***, que examinamos una a la vez. Comencemos nuestra exploración con un ejemplo simple que no presenta problemas. A medida que lo desarrollemos, verá que comienza a aparecer la discrepancia.

Suponga que tiene que diseñar e implementar ***una aplicación de comercio electrónico en línea***. En esta aplicación, necesita una ***clase*** para representar información sobre un ***usuario del sistema*** y necesita ***otra clase*** para representar información sobre los ***detalles de facturación del usuario***, como se muestra en la figura 1.1.

**Figura 1.1. Un diagrama UML simple de las entidades `User` y `BillingDetails`**

<img width="1270" alt="image" src="https://user-images.githubusercontent.com/23094588/226070737-183ffb76-163a-4a4c-af32-64787b1cb3e2.png">

En este diagrama, puedes ver que un **`User`** tiene muchos **`BillingDetails`**. Puede navegar la relación entre las clases en ambas direcciones; esto significa que puede iterar a través de colecciones o llamar a métodos para llegar al "otro" lado de la relación. Las clases que representan estas entidades pueden ser extremadamente simples:

```java
public class User {

    String username;
    String address;
    Set billingDetails;

    // Accessor methods (getter/setter), business methods, etc.
}

public class BillingDetails {

    String account;
    String bankname;
    User user;

    // Accessor  methods (getter/setter), business methods, etc.
}
``` 
 

Tenga en cuenta que solo le interesa el estado de las entidades con respecto a la persistencia, por lo que hemos omitido la implementación de accesos a propiedades y métodos comerciales, como **`getUsername()`** o **`billAuction()`**.

Es fácil idear un diseño de esquema SQL para este caso:

```sql
create table USERS (
    USERNAME varchar(15) not null primary key,
    ADDRESS varchar(255) not null
);

create table BILLINGDETAILS (
    ACCOUNT varchar(15) not null primary key,
    BANKNAME varchar(255) not null,
    USERNAME varchar(15) not null,
    foreign key (USERNAME) references USERS
);
```

La columna de **clave foránea** restringida(foreign key–constrained) **`USERNAME`** en **`BILLINGDETAILS`** representa la relación entre las dos entidades. Para este modelo de dominio simple, el desajuste objeto/relacional es apenas evidente; es sencillo escribir código **JDBC** para insertar, actualizar y eliminar información sobre usuarios y detalles de facturación.

Ahora veamos qué sucede cuando consideras algo un poco más realista. El desajuste del paradigma será visible cuando agregue más entidades y relaciones de entidades a su aplicación.

### 1.2.1. El problema de la granularidad

El problema más obvio con la implementación actual es que ha diseñado una dirección como un valor **`String`** simple. En la mayoría de los sistemas, es necesario almacenar la información de la calle, la ciudad, el estado, el país y el código postal por separado. Por supuesto, podría agregar estas propiedades directamente a la clase **`User`**, pero debido a que es muy probable que otras clases en el sistema también contengan información de direcciones, tiene más sentido crear una clase **`Address`**. La figura 1.2 muestra el modelo actualizado.

**Figura 1.2. El `User` tiene una `Address`**.

<img width="1218" alt="image" src="https://user-images.githubusercontent.com/23094588/226071500-d86519df-dff8-4263-a6af-177b6d17a9a5.png">

¿Debería agregar también una tabla **`ADDRESS`**? No necesariamente; es común mantener la información de la dirección en la tabla **`USERS`**, en columnas individuales. Es probable que este diseño funcione mejor, porque no se necesita una combinación de tabla si desea recuperar el usuario y la dirección en una sola consulta. La mejor solución puede ser crear un nuevo tipo de datos SQL para representar direcciones y agregar una sola columna de ese nuevo tipo en la tabla **`USERS`** en lugar de varias columnas nuevas.

Tiene la opción de agregar varias columnas o una sola columna (de un nuevo tipo de datos SQL). Esto es claramente un problema de ***granularidad***. En términos generales, la granularidad se refiere al tamaño relativo de los tipos con los que está trabajando.

Volvamos al ejemplo. Agregar un nuevo tipo de datos al catálogo de la base de datos, para almacenar instancias **`Address`** de Java en una sola columna, parece el mejor enfoque:

```sql
create table USERS (
    USERNAME varchar(15) not null primary key,
    ADDRESS address not null
);
```

Un nuevo tipo **`Address`** (clase) en Java y un nuevo tipo **`ADDRESS`** de datos SQL deberían garantizar la interoperabilidad. Pero encontrará varios problemas si verifica la compatibilidad con los tipos de datos definidos por el usuario (UDT) en los sistemas de administración de bases de datos SQL actuales.

La compatibilidad con UDT es una de las denominadas ***extensiones relacionales de objetos*** del SQL tradicional. Este término por sí solo es confuso, porque significa que el sistema de administración de bases de datos tiene (o se supone que admite) un sistema de tipo de datos sofisticado, algo que se da por sentado si alguien le vende un sistema que puede manejar datos de manera relacional. Desafortunadamente, la compatibilidad con UDT es una característica un tanto oscura de la mayoría de los DBMS de SQL y ciertamente no es portátil entre diferentes productos. Además, el estándar SQL admite tipos de datos definidos por el usuario, pero de forma deficiente.

Esta limitación no es culpa del modelo de datos relacionales. Puede considerar la falta de estandarización de una función tan importante como las consecuencias de las guerras de bases de datos relacionales de objetos entre proveedores a mediados de la década de 1990. Hoy en día, la mayoría de los ingenieros aceptan que los productos SQL tienen sistemas de tipos limitados, sin hacer preguntas. Incluso con un sistema UDT sofisticado en su SQL DBMS, es probable que aún duplique las declaraciones de tipo, escribiendo el nuevo tipo en Java y nuevamente en SQL. intentos de encontrar un una mejor solución para el espacio de Java, como **SQLJ**, por desgracia, no ha tenido mucho éxito. Los productos DBMS rara vez admiten la implementación y ejecución de clases de Java directamente en la base de datos y, si hay soporte disponible, generalmente se limita a una funcionalidad muy básica y compleja en el uso diario.

Por estas y otras razones, el uso de UDT o tipos de Java en una base de datos SQL no es una práctica común en la industria en este momento, y es poco probable que encuentre un esquema heredado que haga un uso extensivo de UDT. Por lo tanto, no puede y no almacenará instancias de su nueva clase **`Address`** en una sola columna nueva que tenga el mismo tipo de datos que la capa de Java.

La solución pragmática para este problema tiene varias columnas de tipos de SQL integrados definidos por el proveedor (como tipos de datos booleanos, numéricos y de cadena). Por lo general, define la tabla **`USERS`** de la siguiente manera:

```sql
create table USERS (
    USERNAME varchar(15) not null primary key,
    ADDRESS_STREET varchar(255) not null,
    ADDRESS_ZIPCODE varchar(5) not null,
    ADDRESS_CITY varchar(255) not null
);
```

Las clases en el modelo de dominio de Java vienen en una gama de diferentes niveles de granularidad: desde clases de entidad de grano grueso como **`User`**, hasta clases de grano más fino como **`Address`**, hasta simples extensiones **`SwissZipCode`**,  **`AbstractNumericZipCode`** (o cualquiera que sea el nivel de abstracción que desee). Por el contrario, solo dos niveles de granularidad de tipo son visibles en la base de datos SQL: tipos de relación creados por usted, como **`USERS`** y **`BILLINGDETAILS`**, y tipos de datos integrados como **`VARCHAR`**, **`BIGINT`** o **`TIMESTAMP`**.

Muchos mecanismos de persistencia simples no reconocen este desajuste y, por lo tanto, terminan forzando la representación menos flexible de los productos SQL en el modelo orientado a objetos, aplanándolo efectivamente.

Resulta que el problema de la granularidad no es especialmente difícil de resolver. Probablemente ni siquiera lo discutiríamos, si no fuera por el hecho de que es visible en tantos sistemas existentes. Describimos la solución a este problema en la sección 4.1.

Surge un problema mucho más difícil e interesante cuando consideramos los modelos de dominio que dependen de la herencia, una característica del diseño orientado a objetos que puede utilizar para facturar a los usuarios de su aplicación de comercio electrónico de formas nuevas e interesantes.

### 1.2.2. El problema de los subtipos

En Java, implementa la herencia de tipos usando ***superclases*** y ***subclases***. Para ilustrar por qué esto puede presentar un problema de desajuste, agreguemos a su aplicación de comercio electrónico para que ahora pueda aceptar no solo la facturación de la cuenta bancaria, sino también tarjetas de crédito y débito. La forma más natural de reflejar este cambio en el modelo es usar herencia para la superclase **`BillingDetails`**, junto con varias subclases concretas: **`CreditCard`**, **`BankAccount`**, etc. Cada una de estas subclases define datos ligeramente diferentes (y una funcionalidad completamente diferente que actúa sobre esos datos). El diagrama de clases UML de la figura 1.3 ilustra este modelo.

**Figura 1.3. Uso de la herencia para diferentes estrategias de facturación**

<img width="1285" alt="image" src="https://user-images.githubusercontent.com/23094588/226072304-6265be15-5d8d-45aa-b871-be0dd39e6bf1.png">

¿Qué cambios debe realizar para admitir esta estructura de clases Java actualizada? ¿Puedes crear una tabla **`CREDITCARD`** que se extienda **`BILLINGDETAILS`**? Los productos de bases de datos SQL generalmente no implementan la herencia de tablas (o incluso la herencia de tipos de datos), y si la implementan, no siguen una sintaxis estándar y podrían exponernos a problemas de integridad de datos (reglas de integridad limitadas para vistas actualizables).

No hemos terminado con la herencia. Tan pronto como introducimos la herencia en el modelo, tenemos la posibilidad de ***polimorfismo***.

La clase **`User`** tiene una asociación con la superclase **`BillingDetails`**. Esta es una ***asociación polimórfica***. En tiempo de ejecución, una instancia **`User`** puede hacer referencia a una instancia de cualquiera de las subclases de **`BillingDetails`**. De manera similar, desea poder escribir consultas polimórficas que se refieran a la clase **`BillingDetails`** y que la consulta devuelva instancias de sus subclases.

Las bases de datos SQL también carecen de una forma obvia (o al menos una forma estandarizada) de representar una ***asociación polimórfica***. Una restricción de clave externa se refiere exactamente a una ***tabla de destino***; no es sencillo definir una ***clave externa*** que se refiera a varias tablas. Tendría que escribir una restricción de procedimiento para hacer cumplir este tipo de ***regla de integridad***.

El resultado de esta discrepancia de subtipos es que la estructura de herencia en un modelo debe persistir en una base de datos SQL que no ofrece un mecanismo de herencia. En el capítulo 6, discutimos cómo las soluciones **ORM** como **Hibernate** resuelven el problema de persistir una jerarquía de clases en una tabla o tablas de bases de datos SQL, y cómo se puede implementar el comportamiento polimórfico. Afortunadamente, este problema ahora se entiende bien en la comunidad y la mayoría de las soluciones admiten aproximadamente la misma funcionalidad.

El siguiente aspecto del problema del desajuste entre el objeto y la relación es la cuestión de la ***identidad del objeto***. Probablemente haya notado que el ejemplo se define **`USERNAME`** como la clave principal de la tabla **`USERS`**. ¿Fue una buena elección? ¿Cómo manejas objetos idénticos en Java?

### 1.2.3. El problema de la identidad

Si bien el problema de la identidad puede no ser obvio al principio, lo encontrará a menudo en su sistema de comercio electrónico en crecimiento y expansión, como cuando necesita verificar si dos instancias son idénticas. Hay tres formas de abordar este problema: dos en el mundo Java y una en su base de datos SQL. Como era de esperar, trabajan juntos solo con algo de ayuda.

Java define dos nociones diferentes de igualdad:

* Identidad de la instancia(más o menos equivalente a la ubicación de la memoria, verificada con **`a == b`**)

* Igualdad de instancia, según lo determinado por la implementación del método **`equals()`** (también llamada ***igualdad por valor(equality by value)***)

Por otro lado, la identidad de una fila de la base de datos se expresa como una comparación de los valores de la clave principal(primary key). Como verá en la sección 10.1.2, ni **`equals()`** tampoco **`==`** es siempre equivalente a una comparación de valores de clave principal. Es común que varias instancias no idénticas en Java representen simultáneamente la misma fila de la base de datos, por ejemplo, en subprocesos de aplicaciones que se ejecutan simultáneamente. Además, algunas dificultades sutiles están involucradas en la implementación **`equals()`** correcta para una clase persistente y en la comprensión de cuándo esto podría ser necesario.

Usemos un ejemplo para discutir otro problema relacionado con la identidad de la base de datos. En la definición de la tabla **`USERS`**, **`USERNAME`** es la clave principal(primary key). Desafortunadamente, esta decisión dificulta cambiar el nombre de un usuario; necesita actualizar no solo la fila en **`USERS`**, sino también los valores de clave externa(foreign key) en (muchas) filas de **`BILLINGDETAILS`**. Para resolver este problema, más adelante en este libro le recomendamos que utilice **claves sustitutas(surrogate keys)** siempre que no pueda encontrar una buena **clave natural(natural key)**. También discutimos lo que hace una buena **clave primaria (primary key)**. Una columna de **clave sustituta(surrogate key)** es una columna de **clave principal(primary key)** sin significado para el usuario de la aplicación; en otras palabras, una clave que no se presenta al usuario de la aplicación. **Su única finalidad es la identificación de datos dentro de la aplicación**.

Por ejemplo, puede cambiar las definiciones de su tabla para que se vean así:

```sql
create table USERS (
    ID bigint not null primary key,
    USERNAME varchar(15) not null unique,
    ...


);

create table BILLINGDETAILS (
    ID bigint not null primary key,
    ACCOUNT varchar(15) not null,
    BANKNAME varchar(255) not null,
    USER_ID bigint not null,
    foreign key (USER_ID) references USERS
);
```

Las columnas **`ID`** contienen ***valores generados por el sistema***. Estas columnas se introdujeron únicamente en beneficio del modelo de datos, entonces, ¿cómo deberían representarse (si es que lo hacen) en el ***modelo de dominio de Java***? Discutimos esta pregunta en la sección 4.2 y encontramos una solución con **ORM**.

En el contexto de la persistencia, la identidad está estrechamente relacionada con la forma en que el sistema maneja el almacenamiento en caché y las transacciones. Diferentes soluciones de persistencia han elegido diferentes estrategias, y esto ha sido un área de confusión. Cubrimos todos estos temas interesantes, y mostramos cómo están relacionados, en la sección 10.1 .

Hasta ahora, la aplicación básica de comercio electrónico que ha diseñado ha expuesto los problemas de discrepancia de paradigmas con la granularidad del mapeo, los subtipos y la identidad. Ya casi está listo para pasar a otras partes de la aplicación, pero primero debemos discutir el importante concepto de asociaciones: cómo se mapean y manejan las relaciones entre entidades. ¿Es la restricción de clave externa en la base de datos todo lo que necesita?

### 1.2.4. Problemas relacionados con las asociaciones

En su **modelo de dominio**, las asociaciones representan las relaciones entre entidades. Las clases **`User`**, **`Address`** y **`BillingDetails`** están todas asociadas; pero a diferencia de **`Address`**, **`BillingDetails`** se sostiene por sí mismo. **`BillingDetails`** las instancias se almacenan en su propia tabla. El mapeo de asociaciones y la gestión de asociaciones de entidades son conceptos centrales en cualquier solución de persistencia de objetos.

Los lenguajes orientados a objetos representan asociaciones usando referencias a objetos; pero en el mundo relacional, una ***columna restringida por clave externa(foreign key–constrained column)*** representa una asociación, con copias de valores clave. La restricción es una regla que garantiza la integridad de la asociación. Hay diferencias sustanciales entre los dos mecanismos.

Las referencias a objetos son inherentemente direccionales; ***la asociación es de una instancia a la otra***. Son punteros. Si una asociación entre instancias debe ser navegable en ambas direcciones, debe definir la asociación dos veces , una vez en cada una de las clases asociadas. Ya has visto esto en las clases del modelo de dominio:

```java
public class User {
    Set billingDetails;
}

public class BillingDetails {
    User user;
}
``` 
 
La ***navegación*** en una dirección particular no tiene sentido para un modelo de datos relacionales porque puede crear asociaciones de datos arbitrarias con operadores de unión y proyección (join and projection). El desafío es asignar un modelo de datos completamente abierto, que sea independiente de la aplicación que trabaja con los datos, a un modelo de navegación dependiente de la aplicación: una vista restringida de las asociaciones que necesita esta aplicación en particular.

***Las asociaciones de Java pueden tener una multiplicidad de muchos a muchos***. Por ejemplo, las clases podrían verse así:

```java
public class User {
    Set billingDetails;
}

public class BillingDetails {
    Set users;
}
```

Pero la declaración de clave externa(foreign key) sobre la tabla **`BILLINGDETAILS`** es una asociación de ***muchos a uno(many-to-one)***: cada cuenta bancaria está vinculada a un usuario en particular. Cada usuario puede tener varias cuentas bancarias vinculadas.

Si desea representar una asociación de ***muchos a muchos(many-to-many)*** en una base de datos SQL, debe introducir una nueva tabla, generalmente llamada ***tabla de enlace(link table)***. ***En la mayoría de los casos, esta tabla no aparece en ninguna parte del modelo de dominio***. Para este ejemplo, si considera que la relación entre el usuario y la información de facturación es de ***muchos a muchos(many-to-many)***, defina la tabla de vínculos de la siguiente manera:

```sql
create table USER_BILLINGDETAILS (
    USER_ID bigint,
    BILLINGDETAILS_ID bigint,
    primary key (USER_ID, BILLINGDETAILS_ID),
    foreign key (USER_ID) references USERS,
    foreign key (BILLINGDETAILS_ID) references BILLINGDETAILS
);
```

Ya no necesita la columna **`USER_ID`** de clave externa(foreign key) y la restricción en la tabla **`BILLINGDETAILS`**; esta tabla adicional ahora gestiona los enlaces entre las dos entidades. Discutimos los mapeos de asociaciones y colecciones en detalle en el capítulo 7.

Hasta ahora, los problemas que hemos considerado son principalmente estructurales: puede verlos considerando una vista puramente estática del sistema. Quizás el problema más difícil en la persistencia de objetos es un problema dinámico: cómo se accede a los datos en tiempo de ejecución.

### 1.2.5. El problema de la navegación de datos

Hay una diferencia fundamental en la forma de acceder a los datos en Java y en una base de datos relacional. En Java, cuando accede a la información de facturación de un usuario, llama someUser.getBillingDetails().iterator().next()o algo similar. Esta es la forma más natural de acceder a datos orientados a objetos y, a menudo, se describe como caminar por la red de objetos . Navega de una instancia a otra, incluso iterando colecciones, siguiendo punteros preparados entre clases. Desafortunadamente, esta no es una forma eficiente de recuperar datos de una base de datos SQL.

Lo más importante que puede hacer para mejorar el rendimiento del código de acceso a datos es minimizar el número de solicitudes a la base de datos . La forma más obvia de hacer esto es minimizar el número de consultas SQL. (Por supuesto, otras formas más sofisticadas, como el almacenamiento en caché extenso, siguen como segundo paso).

Por lo tanto, el acceso eficiente a datos relacionales con SQL generalmente requiere uniones entre las tablas de interés. El número de tablas incluidas en la unión al recuperar datos determina la profundidad de la red de objetos que puede navegar en la memoria. Por ejemplo, si necesita recuperar un correo electrónico Usery no está interesado en la información de facturación del usuario, puede escribir esta consulta simple:

seleccione * de USUARIOS u donde u.ID = 123
Por otro lado, si necesita recuperar un Usery luego visitar cada una de las BillingDetailsinstancias asociadas (digamos, para enumerar todas las cuentas bancarias del usuario), escriba una consulta diferente:

seleccione * de USUARIOS u
    unión externa izquierda BILLINGDETAILS bd
        en bd.USER_ID = u.ID
donde u.ID = 123
Como puede ver, para usar uniones de manera eficiente, necesita saber a qué parte de la red de objetos planea acceder cuando recupere la instancia inicial antes de comenzar a navegar por la red de objetos. Sin embargo, tenga cuidado: si recupera demasiados datos (probablementemás de lo que podría necesitar), está desperdiciando memoria en el nivel de la aplicación. También puede sobrecargar la base de datos SQL con enormes conjuntos de resultados de productos cartesianos . Imagine recuperar no solo usuarios y cuentas bancarias en una consulta, sino también todos los pedidos pagados de cada cuenta bancaria, los productos en cada pedido, etc.

Cualquier solución de persistencia de objetos que valga la pena proporciona funcionalidad para obtener los datos de instancias asociadas solo cuando se accede a la asociación por primera vez en código Java. Esto se conoce como carga diferida : recuperar datos solo bajo demanda. Este estilo fragmentado de acceso a datos es fundamentalmente ineficiente en el contexto de una base de datos SQL, porque requiere ejecutar una declaración para cada nodo o colección de la red de objetos a la que se accede. Este es el temido problema de selecciones n+1 .

Este desajuste en la forma de acceder a los datos en Java y en una base de datos relacional es quizás la fuente más común de problemas de rendimiento en los sistemas de información de Java. Sin embargo, aunque hemos sido bendecidos con innumerables libros y artículos que nos aconsejan usar StringBufferpara la concatenación de cadenas, evitar el producto cartesiano y los problemas de selección n+1 sigue siendo un misterio para muchos programadores de Java. (Admítelo: simplemente pensaste StringBuilderque sería mucho mejor que StringBuffer.)

Hibernate proporciona características sofisticadas para obtener de manera eficiente y transparente redes de objetos de la base de datos a la aplicación que accede a ellos. Discutimos estas características en el capítulo 12 .

Ahora tenemos una gran lista de problemas de desajuste de objeto/relacional, y puede ser costoso (en tiempo y esfuerzo) encontrar soluciones, como sabrá por experiencia. Nos llevará la mayor parte de este libro dar una respuesta completa a estas preguntas y demostrar que ORM es una solución viable. Comencemos con una descripción general de ORM, el estándar de persistencia de Java y el proyecto Hibernate.

1.3. ORM y JPA
En pocas palabras, el mapeo objeto/relacional es la persistencia automatizada (y transparente) de objetos en una aplicación Java a las tablas en una base de datos SQL, utilizando metadatos que describen el mapeo entre las clases de la aplicación y el esquema de la base de datos SQL. En esencia, ORM funciona transformando (reversiblemente) los datos de una representación a otra. Antes de continuar, debe comprender lo que Hibernate no puede hacer por usted.

Una supuesta ventaja de ORM es que protege a los desarrolladores del desordenado SQL. Este punto de vista sostiene que no se puede esperar que los desarrolladores orientados a objetos comprendan bien SQL o las bases de datos relacionales y que encuentren SQL de alguna manera ofensivo. Por el contrario, creemos que los desarrolladores de Java deben tener un nivel suficiente de familiaridad y apreciación del modelado relacional y SQL para poder trabajar con Hibernate. ORM es una técnica avanzada utilizada por desarrolladores que ya lo han hecho de la manera más difícil. Para usar Hibernate de manera efectiva, debe poder ver e interpretar las declaraciones SQL que emite y comprender sus implicaciones de rendimiento.

Veamos algunos de los beneficios de Hibernate:

Productividad: Hibernate elimina gran parte del trabajo duro (más de lo que cabría esperar) y le permite concentrarse en el problema empresarial. Independientemente de la estrategia de desarrollo de aplicaciones que prefiera (de arriba hacia abajo, comenzando con un modelo de dominio, o de abajo hacia arriba, comenzando con un esquema de base de datos existente), Hibernate, junto con las herramientas adecuadas, reducirá significativamente el tiempo de desarrollo .
Mantenibilidad: el ORM automatizado con Hibernate reduce las líneas de código (LOC), lo que hace que el sistema sea más comprensible y fácil de refactorizar . Hibernate proporciona un búfer entre el modelo de dominio y el esquema SQL, aislando cada modelo de cambios menores en el otro.
Rendimiento: aunque la persistencia codificada a mano puede ser más rápida en el mismo sentido que el código ensamblador puede ser más rápido que el código Java, las soluciones automatizadas como Hibernate permiten el uso de muchas optimizaciones en todo momento . Un ejemplo de esto es el almacenamiento en caché eficiente y fácilmente ajustable en el nivel de aplicación. Esto significa que los desarrolladores pueden gastar más energía optimizando a mano los pocos cuellos de botella reales restantes en lugar de optimizar todo prematuramente.
Independencia del proveedor: Hibernate puede ayudar a mitigar algunos de los riesgos asociados con el bloqueo del proveedor. Incluso si planea no cambiar nunca su producto DBMS, las herramientas ORM que admiten varios DBMS diferentes permiten un cierto nivel de portabilidad . Además, la independencia de DBMS ayuda en escenarios de desarrollo donde los ingenieros usan una base de datos local liviana pero la implementan para pruebas y producción en un sistema diferente.
El enfoque de Hibernate para la persistencia fue bien recibido por los desarrolladores de Java, y la API de persistencia de Java estándar se diseñó de manera similar.

JPA se convirtió en una parte clave de las simplificaciones introducidas en las recientes especificaciones EJB y Java EE. Deberíamos tener claro desde el principio que ni la persistencia de Java ni Hibernate se limitan al entorno Java EE; son soluciones de propósito general para el problema de persistencia que cualquier tipo de aplicación Java (o Groovy o Scala) puede usar.

La especificación JPA define lo siguiente:

Una función para especificar metadatos de mapeo: cómo las clases persistentes y sus propiedades se relacionan con el esquema de la base de datos. JPA se basa en gran medida en las anotaciones de Java en las clases de modelos de dominio, pero también puede escribir asignaciones en archivos XML.
API para realizar operaciones CRUD básicas en instancias de clases persistentes, principalmente javax.persistence.EntityManagerpara almacenar y cargar datos.
Un lenguaje y API para especificar consultas que se refieren a clases y propiedades de clases. Este lenguaje es el lenguaje de consulta de persistencia de Java (JPQL) y se parece a SQL. La API estandarizada permite la creación programática de consultas de criterios sin manipulación de cadenas.
Cómo interactúa el motor de persistencia con las instancias transaccionales para realizar comprobaciones sucias, obtención de asociaciones y otras funciones de optimización. La especificación JPA más reciente cubre algunas estrategias básicas de almacenamiento en caché.
Hibernate implementa JPA y admite todas las asignaciones, consultas e interfaces de programación estandarizadas.

1.4. Resumen
Con la persistencia de objetos , los objetos individuales pueden sobrevivir a su proceso de aplicación, guardarse en un almacén de datos y volver a crearse más tarde. El desajuste objeto/relacional entra en juego cuando el almacén de datos es un sistema de gestión de base de datos relacional basado en SQL. Por ejemplo, una red de objetos no se puede guardar en una tabla de base de datos; debe desensamblarse y conservarse en columnas de tipos de datos SQL portátiles. Una buena solución para este problema es el mapeo objeto/relacional (ORM).
ORM no es una panacea para todas las tareas de persistencia; su trabajo es liberar al desarrollador del 95% del trabajo de persistencia de objetos, como escribir instrucciones SQL complejas con muchas uniones de tablas y copiar valores de conjuntos de resultados JDBC a objetos o gráficos de objetos.
Una solución de middleware ORM con funciones completas puede proporcionar portabilidad de la base de datos, ciertas técnicas de optimización como el almacenamiento en caché y otras funciones viables que no son fáciles de codificar manualmente en un tiempo limitado con SQL y JDBC.
Algún día podrían existir mejores soluciones que ORM. Es posible que nosotros (y muchos otros) tengamos que repensar todo lo que sabemos sobre los sistemas de administración de datos y sus lenguajes, los estándares API de persistencia y la integración de aplicaciones. Pero la evolución de los sistemas actuales hacia verdaderos sistemas de bases de datos relacionales con una perfecta integración orientada a objetos sigue siendo pura especulación. No podemos esperar, y no hay señales de que ninguno de estos problemas mejore pronto (una industria multimillonaria no es muy ágil). ORM es la mejor solución disponible actualmente, y es un ahorro de tiempo para los desarrolladores que se enfrentan a la falta de coincidencia entre objetos y relaciones todos los días.
