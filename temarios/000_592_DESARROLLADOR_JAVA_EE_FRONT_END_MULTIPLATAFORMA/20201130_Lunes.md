# 20201130 Lunes

## Arquitectura Hexagonal

La arquitectura hexagonal, también conocida como arquitectura de puertos y adaptadores, tiene como objetivo aislar toda la lógica de aplicación del exterior, haciendo independiente de mecanismos de entrada y salida, sistemas de almacenamiento de datos, políticas de seguridad, etc. 

### El Hexágono

El esquema de esta arquitectura se representa en forma de hexágono, no porque tenga que tener seis lados exactamente, sino porque es una forma de marcar la frontera entre el interior (la lógica de negocio) y el exterior.

En el centro del hexágono encontramos el dominio, formado por las entidades que representan nuestro modelo de datos y la definición de los repositorio de datos y funcionalidades de la aplicación (interfaces de servicio).

Por encima del dominio están los **casos de uso o lógica de aplicación**, que no son más que implementaciones de las interfaces de servicio con la lógica de aplicación. Todo ello, independizado de los mecanismos utilziados para el acceso a los datos, así como de la interacción con los usuarios.

Por encima de los casos de uso encontramos los adaptadores, que ya contienen detalles específicos de la infraestructura. Estos elementos se consideran ya fuera del hexagono al ser dependientes del exterior.

![hexagono-01](images/hexagono-01.png)

### Puertos y Adaptadores

A la arquitectura hexagonal se le conoce también como **puertos y adaptadores** porque esta basada en dicho concepto.

Un puerto no es más que la especificación sobre como el exterior intereactúa con la aplicación. A nivel de código, los puertos se definen mediante interfaces. En este sentido distinguimos dos tipos de puertos:

* **Primarios**. Se trata de las interfaces que definen  la funcionalidad del sistema, podriamos decir que son las interfaces de servicio y son implementadas en el interior del hexágono. Estas interfaces son **usadas por los adaptadores primarios**. 

* **Secundarios**. Sirven de interfaz de salida para comunicarse con sistemas externos, como bases de datos. Estas interfaces son **implementadas por los adaptadores secundarios**.

Un adaptador es una **implementación de la interfaz del puerto** para una infraestructura específica. Por ejemplo, un ejemplo de adaptador sería una clase que implementase la interfaz secundaria de datos para proporcionar acceso a una capa de persistencia JPA. Otro ejemplo sería un controlador REST, que utilizase el puerto de la interfaz de servicio para exponer la funcionalidad al exterior en forma de recursos Web.

Un puerto puede ser implementado por múltiples adaptadores.

La siguiente imagen muestra otra visión de la arquitectura hexagonal, más orientada al concepto de puertos y adaptadores:

![hexagono-02](images/hexagono-02.png)

### Otras Arquitecturas

Existen otras variantes de la arquitectura hexagonal, como son:

* **Aquitectura de capas o de cebolla**. Consiste en definir la aplicación en forma de capas, de dentro hacia afuera, donde las capas más externas dependen de las más internas, pero nunca al revés, siguiendo el principio de inversión de dependencias.
En la capa central se encuentra el dominio o core, por encima de este el repositorio y en una tercera capa superior la lógica de negocio. En la capa más externa tendríamos la parte de la aplicación que se comunica con el exterior (base de datos, usuario, ...)

* **Arquitectura limpia**. No es más que una unión de la arquitectura de capas y la hexagonal que se basa en el mismo principio de abstraer la aplicación de los detalles de comunicación con el exterior.

## :computer: `22_gestion_candidatos_hexagonal`

Vamos a crear un proyecto desde el inicio pero tiene que hacerla funcionalidad que teniamos en el proyecto `06_gestion_candidatos_spring_jpa`.

### 01. Mavenizar el proyecto y poner las Dependencias.

```html
<parent>
   <groupId>proyectos.padre.grupo</groupId>
   <artifactId>proyecto.padre</artifactId>
   <version>0.0.1-SNAPSHOT</version>
</parent>
```

### 02. Modelo de Datos

La creación de nuestro Modelo de Datos va a ser un poco diferente ya que antes estaba basado en nuestra Base de Datos y en base a ello realizabamos las Entidades. Sabemos que hay una BD pero no nos vamos a condicionar a ella. Sabemos que vamos a trabajar con candidatos entonces debo pensar que atributos tiene que tener un `Candidato`, por ejemplo el campo `idCandidato` no es revelante representalo como un atributo de la clase `Candidato`.

Vamos a crear la **Clase Candidato**.

`Candidato.java`

```java
package model;

public class Candidato {
	
	public int codigoCandidato;
	private String nombre;
	private String puesto;
	private String foto;
	private String email;
	private int edad;
	
	public Candidato() {
		super();
	}

	public Candidato(int codigoCandidato, String nombre, String puesto, String foto, String email, int edad) {
		super();
		this.codigoCandidato= codigoCandidato;
		this.nombre = nombre;
		this.puesto = puesto;
		this.foto = foto;
		this.email = email;
		this.edad = edad;
		
	}
  
	public int getCodigoCandidato() {
		return codigoCandidato;
	}

	public void setCodigoCandidato(int codigoCandidato) {
		this.codigoCandidato = codigoCandidato;
	}
	
	public String getNombre() {
		return nombre;
	}
	public void setNombre(String nombre) {
		this.nombre = nombre;
	}
	public String getPuesto() {
		return puesto;
	}
	public void setPuesto(String puesto) {
		this.puesto = puesto;
	}
	public String getFoto() {
		return foto;
	}
	public void setFoto(String foto) {
		this.foto = foto;
	}
	public String getEmail() {
		return email;
	}
	public void setEmail(String email) {
		this.email = email;
	}
	public int getEdad() {
		return edad;
	}
	public void setEdad(int edad) {
		this.edad = edad;
	}	

}
```

Ya tengo el Modelo de Datos, no es una Entidad es una clase común y corriente Java.

### 03. Repository

En la capa de Repository lo que vamos a tener es una Interface. El repository no se implementa como parte del Nucleo de la aplicaión. El Repository aquí lo que ofrece es un ***Puerto***, implementado con una Interface. 

Aquí debo pensar a nivel de datos sin pensar en la BD que debe tener mi aplicación.

* Alta de Candidato
* Eliminar Candidato por códigoCandidato
* Recuperar todos los Candidatos
* Buscar Candidato por Código.

`CandidatoRepository.java`

```java
package repository.port;

import java.util.List;

import model.Candidato;

public interface CandidatosRepository {
   void saveCandidato(Candidato candidato);
	 void deleteCandidatoByCodigo(int codigo);
	 List<Candidato> findAll();
	 Candidato findByCodigo(int codigo);
	 Candidato findByEmail(String email);
}
```

### 04. Capa de Servicio

En la Capa de Servicio ya puedo contar con los métodos desde el Repository aun que no hayan sido implementados pero con lo que tengo me basta para crear la Capa de Servicio.

Empezamos por desarrollar la Interface, lo que conoceremos como un ***Puerto***. 
Esta es una ***Interface primaria***, la que se va a utilizar en el Controller  

`CandidatosService`

```java
package service.port;

import java.util.List;

import model.Candidato;

public interface CandidatosService {
   void guardarCandidato(Candidato candidato);
   void eliminarCandidato(int codigoCandidato);
   List<Candidato> obtenerCandidatos();
}
```

Ahora vamos a implementar esta Interface con la siguiente Clase, que será instancia por Spring y donde inyectaremos el Repository. **Esta Implementación no la hacemos como parte del NUCLEO sino como parte de los ADAPTADORES**. En esta clase no se maneja la Transaccionalidad de JPA por que nos estariamos vinculando a ella.

`CandidatosServiceImpl`

```java
package service;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import model.Candidato;
import repository.port.CandidatosRepository;
import service.port.CandidatosService;

@Service
public class CandidatosServiceImpl implements CandidatosService {

	@Autowired
	CandidatosRepository repository;
	
	@Override
	public void guardarCandidato(Candidato candidato) {
		if(repository.findByEmail(candidato.getEmail())!=null) {
			repository.saveCandidato(candidato);
		}
	}

	@Override
	public void eliminarCandidato(int codigoCandidato) {
		if(repository.findByCodigo(codigoCandidato)!=null) {
			repository.deleteCandidatoByCodigo(codigoCandidato);
		}
	}

	@Override
	public List<Candidato> obtenerCandidatos() {
		return repository.findAll();
	}

}
```

**HASTA AQUÍ HEMOS TERMINADO EL NUCLEO O CORE DE LA APLICACIÓN**






