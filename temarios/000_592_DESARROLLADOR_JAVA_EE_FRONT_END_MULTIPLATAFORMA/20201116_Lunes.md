# 20201116 Lunes

## :computer: `21_formacion_ejb_weblogic`

![21-00-ej](images/21-00-ej.png)

Partiendo del proyecto `19_formacion_factoria` vamos a realizar una versión usando EJB.

### Creación del Data Source en WebLogic

![21-01-ej](images/21-01-ej.png)
![21-02-ej](images/21-02-ej.png)
![21-03-ej](images/21-03-ej.png)
![21-04-ej](images/21-04-ej.png)
![21-05-ej](images/21-05-ej.png)
![21-06-ej](images/21-06-ej.png)
![21-07-ej](images/21-07-ej.png)
![21-08-ej](images/21-08-ej.png)
![21-09-ej](images/21-09-ej.png)
![21-10-ej](images/21-10-ej.png)
![21-11-ej](images/21-11-ej.png)
![21-12-ej](images/21-12-ej.png)

### Creación Proyecto en Eclipse

![21-13-ej](images/21-13-ej.png)

### Mavenizar Proyecto

![21-14-ej](images/21-14-ej.png)

### Dar Características JPA

![21-15-ej](images/21-15-ej.png)

### Modificación del Archivo `persistence.xml`

Copiamos el archivo `persistence.xml` del proyecto `19_formacion_factoria` al actual pero tenemos que realizar algunos cambios, en el proyecto anterior la conexión a la BD la haciamos directamente pero con el uso de WebLogic ya vamos a usar el DataSource creado en el primer paso. Por lo que entramos en la pestaña Conexión y cambiamos los valores como se muestra en las siguientes imagenes.

![21-16-ej](images/21-16-ej.png)

Mientras que en la pestaña de General tenemos

![21-17-ej](images/21-17-ej.png)

El archivo `persistence.xml` nos queda así:

```html
<?xml version="1.0" encoding="UTF-8"?>
<persistence version="2.2" xmlns="http://xmlns.jcp.org/xml/ns/persistence" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd">
   <persistence-unit name="formacionPU" transaction-type="JTA">
      <provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>
      <jta-data-source>jdbc/formacionds</jta-data-source>
         <class>model.Alumno</class>
         <class>model.Curso</class>
      <properties>			
         <property name="hibernate.transaction.jta.platform" value="org.hibernate.engine.transaction.jta.platform.internal.WeblogicJtaPlatform"/>				
      </properties>
   </persistence-unit>
</persistence>
```

Como descubrimos que existe un pequeño conflicto entre Hibernate y EJB se tuvo que poner la etiqueta `<properties>` para que trabajen correctamente.

Existe otra alternativa para no trabajar con Hibernate y usar el Motor de Persistencia que viene integrado en WebLogic que en este caso es **EclipseLink** para lo cual nuestro `persistence.xml` quedaría así:

![21-18-ej](images/21-18-ej.png)

**NOTA** *Las Entidades las copiamos directamente del proyecto `19_formacion_factoria`, no usamos el asistente para crear las Entidades.*

### Creación del EJB.

La lógica del Servicio del proyecto `19_formacion_factoria` es la siguiente:

![21-21-ej](images/21-21-ej.png)

Dos Clases con sus respectivas Interfaces y la clase de Factoria.

Todo este Servicio lo debemos implementar usando EJBs. 

Vamos a necesitar un EJB para `Alumnos` y otro para `Cursos` y el Factory ya no va a ser necesario ya que EJB nos lo proporciona implícitamente.

![21-19-ej](images/21-19-ej.png)

![21-20-ej](images/21-20-ej.png)

Como estamos partiendo de código ya desarrollado en otra aplicación vamos a copiar los métodos ya desarrollados en el servicio y lo vamos a meter en las Clases del EJB y lo vamos a adaptar.

Partimos de `AlumnosServiceImpl` del proyecto `19_formacion_factoria`:

`AlumnosServiceImpl`

```java
...

public class AlumnosServiceImpl implements AlumnosService {
	
   private static EntityManager em;
   static {
      EntityManagerFactory factory=Persistence.createEntityManagerFactory("formacionPU");
      em=factory.createEntityManager();
   }
   
   @Override
   public void altaAlumno(Alumno alumno) {
      EntityTransaction tx = em.getTransaction();
      tx.begin();
      em.persist(alumno);
      tx.commit();
   }
	
   @Override
   public Alumno buscarAlumnoPorUsuario(String usuario){
      return em.find(Alumno.class,usuario);
   }

}
```

Y adaptandola a EJBs nos queda así:

`AlumnosServiceImpl`

```java
...

@Stateless
@LocalBean
public class AlumnosServiceImpl implements AlumnosService {

   @PersistenceContext(unitName = "formacionPU")
   private EntityManager em;
	
   @Override
   public void altaAlumno(Alumno alumno) {
      em.persist(alumno);
   }
	
   @Override
   public Alumno buscarAlumnoPorUsuario(String usuario){
      return em.find(Alumno.class,usuario);
   }

}
```

Observaciones del EJB:

* La clase esta anotada con `@Stateless` lo que indica que es un EJB, también anotada con `@LocalBean`
* Eliminamos la Factoria y en su lugar Inyectamos directamente el `EntityManager` usando la anotación `@PersistenceContext(unitName = "formacionPU")`.
* Eliminamos todo lo referente a las transacciones.

Con todos estos cambios la clase reduce en gran medida su código.

Normalmente primero códificamos la Interface y luego la Clase pero en este caso hemos iniciado coiando el código en la Clase, para generar la Interface a partir de la Clase podemos usar la opción:

![21-22-ej](images/21-22-ej.png)

![21-23-ej](images/21-23-ej.png)

![21-24-ej](images/21-24-ej.png)

Realizamos los mismos pasos para el EJB de `Cursos`.

![21-25-ej](images/21-25-ej.png)

![21-26-ej](images/21-26-ej.png)

En este último paso no se debería haber usado el atributo `em`, solo se seleccionan los métodos.

![21-27-ej](images/21-27-ej.png)

Las Clases e Interfaces finales de los EJBs son:

Interface `AlumnosService`

```java
package service;

import javax.ejb.Local;

import model.Alumno;

@Local
public interface AlumnosService {
   Alumno buscarAlumnoPorUsuario(String usuario);
   void altaAlumno(Alumno alumno);
}
```

Clase `AlumnosServiceImpl`

```java
package service;

import javax.ejb.LocalBean;
import javax.ejb.Stateless;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

import model.Alumno;

/**
 * Session Bean implementation class AlumnosServiceImpl
 */
@Stateless
@LocalBean
public class AlumnosServiceImpl implements AlumnosService {

   @PersistenceContext(unitName = "formacionPU")
   private EntityManager em;
	
   @Override
   public void altaAlumno(Alumno alumno) {
      em.persist(alumno);
   }
	
   @Override
   public Alumno buscarAlumnoPorUsuario(String usuario){
      return em.find(Alumno.class,usuario);
   }

}
```

Interface `CursosService`

```java
package service;

import javax.ejb.Local;
import model.Curso;

@Local
public interface CursosService {
   void altaCurso(Curso curso);
}
```

Clase `CursosServiceImpl`

```java
package service;

import javax.ejb.LocalBean;
import javax.ejb.Stateless;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

import model.Curso;

/**
 * Session Bean implementation class CursosServiceImpl
 */
@Stateless
@LocalBean
public class CursosServiceImpl implements CursosService {

   @PersistenceContext(unitName = "formacionPU")
   private EntityManager em;
	
   @Override
   public void altaCurso(Curso curso) {
      em.persist(curso);
   }
   
}
```

### Modificar Controllers

Como hemos visto, con estos cambios el Factory a sido eliminado por lo que debemos hacer algunos cambios en nuestros Controladores que lo usaban así:

Originalmente teniamos:

```java
AlumnosService service =  FormacionFactory.getAlumnosService();
```

o

```java
CursoService service = FormacionFactory.getCursosService();
```

En lugar de Instanciar el Servicio con la Factoria, vamos a inyectar los EJBs dentro de los Action de la siguiente forma.

```java
...

@EJB
AlumnosService service;
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
   ...
```
o

```java
...

@EJB
CursosService service;
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
	
   ...
```

Simplemente usamos la anotación `@EJB` para inyectar el EJB.

### Vistas

Las Vistas no sufren ningún cambio.

### Probar la aplicación.

![21-28-ej](images/21-28-ej.png)
![21-29-ej](images/21-29-ej.png)
![21-30-ej](images/21-30-ej.png)
![21-31-ej](images/21-31-ej.png)
![21-32-ej](images/21-32-ej.png)

## Relación Entre Entidades

![05-39](images/05-39.png)
![05-40](images/05-40.png)
![05-41](images/05-41.png)
![05-42](images/05-42.png)
![05-43](images/05-43.png)
![05-44](images/05-44.png)
![05-45](images/05-45.png)
![05-46](images/05-46.png)

## :computer: `22_ejemplo_relaciones`

![22-00-ej](images/22-00-ej.png)

Este proyecto nuevo nos va a servir para ver algunos ejemplos de **Relación Entre Entidades**. Este proyecto no tiene ninguna parte visual solo nos va a servir para ver las relaciones existentes entre las Tablas `Cursos` y `Preguntas`.
de la BD `formacion`.

### BD `formacion`

Tablas `Cursos` y `Preguntas`

![22-01-ej](images/22-01-ej.png)
![22-02-ej](images/22-02-ej.png)
![22-03-ej](images/22-03-ej.png)

### Creación del Proyecto Eclipse

![22-04-ej](images/22-04-ej.png)

### Mavenizar el Proyecto e incluir las dependencias de Hibernate.

`pom.xml`

```html
<!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-core --> 
<dependency>
   <groupId>org.hibernate</groupId>
   <artifactId>hibernate-core</artifactId>
   <version>5.4.18.Final</version>
</dependency>
```

### Creación de una Nueva Conexión

El siguiente paso sería usar el asistente para crear las Entidades de `Cursos` y `Preguntas` **pero en ejemplos anteriores vimos que al  hacer este paso teniamos el problema de duplicación de campos por usar el conector de MySQL 8, para evitar estos problemas vamos a usar el conector de MySQL 5**.

Entramos en la opción **JPA Tools -> Generate Entities Tables...** y vamos a crear una nueva conexión para poder usar el Driver de MySQL 5.

![22-05-ej](images/22-05-ej.png)
![22-06-ej](images/22-06-ej.png)
![22-07-ej](images/22-07-ej.png)
![22-08-ej](images/22-08-ej.png)
![22-09-ej](images/22-09-ej.png)
![22-10-ej](images/22-10-ej.png)

Una vez que ya tenemos la conección con MySQL 5 vamos a generar las Entidades.

![22-11-ej](images/22-11-ej.png)
![22-12-ej](images/22-12-ej.png)

En este caso si tenemos una relación entre las tablas las cuales se relacionan por medio del campo `idCurso`, presionamos en `+` para añadir la relación.

![22-13-ej](images/22-13-ej.png)

Vamos a indicar que es una *Asociación Simple* entre las tablas `Cursos` y `Preguntas`.

![22-14-ej](images/22-14-ej.png)

En la siguiente pantalla

![22-15-ej](images/22-15-ej.png)

Debemos indicar a través de que campo se relacionan las tablas, al presionar en `Add` pone cualquier campo dde las tablas.

![22-16-ej](images/22-16-ej.png)

Debemos modificarlo para poner exactamente el que nosotros necesitemos.

![22-17-ej](images/22-17-ej.png)

En la siguiente pantalla debemos indicar la relación existente entre `Cursos` y `Preguntas` y en este caso corresponde a una relación **One to many** *Cada Curso tiene muchas Preguntas.*

![22-18-ej](images/22-18-ej.png)

Se nos muestra gráficamente la relación y si la seleccionamos muestra más detalles.

![22-19-ej](images/22-19-ej.png)

En la siguiente pantalla.

![22-20-ej](images/22-20-ej.png)

Solo vamos a cambiar el paquete donde vamos a almacenar las Entidades `model`.

![22-21-ej](images/22-21-ej.png)

En la siguiente pantalla vamos a definir para cada Entidad como se van a generar las llaves.

![22-22-ej](images/22-22-ej.png)
![22-23-ej](images/22-23-ej.png)

Al presionar Finish se generan las dos Entidades.

![22-24-ej](images/22-24-ej.png)

Vamos a ver cada una de las Entidades.

Entidad `Curso` (UNO)

```java
package model;

import java.io.Serializable;
import javax.persistence.*;
import java.util.Date;
import java.util.List;

/**
 * The persistent class for the cursos database table.
 * 
 */
@Entity
@Table(name="cursos")
@NamedQuery(name="Curso.findAll", query="SELECT c FROM Curso c")
public class Curso implements Serializable {
   private static final long serialVersionUID = 1L;

   @Id
   @GeneratedValue(strategy=GenerationType.IDENTITY)
   private int idCurso;

   private int duracion;

   @Temporal(TemporalType.DATE)
   private Date fechaInicio;

   private String nombre;

   //bi-directional many-to-one association to Pregunta
   @OneToMany(mappedBy="curso")
   private List<Pregunta> preguntas;

   public Curso() {
   }

   public int getIdCurso() {
      return this.idCurso;
   }

   public void setIdCurso(int idCurso) {
      this.idCurso = idCurso;
   }

   public int getDuracion() {
      return this.duracion;
   }

   public void setDuracion(int duracion) {
      this.duracion = duracion;
   }

   public Date getFechaInicio() {
      return this.fechaInicio;
   }

   public void setFechaInicio(Date fechaInicio) {
      this.fechaInicio = fechaInicio;
   }

   public String getNombre() {
      return this.nombre;
   }

   public void setNombre(String nombre) {
      this.nombre = nombre;
   }

   public List<Pregunta> getPreguntas() {
      return this.preguntas;
   }

   public void setPreguntas(List<Pregunta> preguntas) {
      this.preguntas = preguntas;
   }

   public Pregunta addPregunta(Pregunta pregunta) {
      getPreguntas().add(pregunta);
      pregunta.setCurso(this);

      return pregunta;
   }

   public Pregunta removePregunta(Pregunta pregunta) {
      getPreguntas().remove(pregunta);
      pregunta.setCurso(null);

      return pregunta;
   }

}
```

Observaciones sobre la Entidad `Curso` (Entidad "UNO"):

* Anotada con `@Entity`
* Anotada con `@Table(name="cursos")`
* Anotada con `@NamedQuery(name="Curso.findAll", query="SELECT c FROM Curso c")`
* Implementa `Serializable`
* El atributo que representa la clave principal esta anotada con `@Id` y `  @GeneratedValue(strategy=GenerationType.IDENTITY)` para la estrategía de generación de la clave.
* Los campos de tipo `Date` se anotan con `@Temporal(TemporalType.DATE)`
* **Los campos de la Tabla `cursos` son: `idCurso`, `nombre`, `duracion`, `fechaInicio`** y el asistente en la Entidad a añadido los atributos `idCurso`, `nombre`, `duracion`, `fechaInicio` pero añade un atributo más.
* **SE AÑADE EL ATRIBUTO `private List<Pregunta> preguntas;` CON LA ANOTACIÓN `@OneToMany(mappedBy="curso")`**, esto lo hace por que establecimos una relación ONE-TO-MANY entre la tabla `cursos` con respecto a la tabla `preguntas` *Un Curso puede tener Muchas Preguntas* por lo que lo representa con este atributo.
* Añade los métodos `getters` y `setters` para todos los atributos.
* Añade dos métodos especiales para añadir y remover preguntas en la colección de preguntas.

Entidad `Pregunta` (MUCHOS)

```java
package model;

import java.io.Serializable;
import javax.persistence.*;


/**
 * The persistent class for the preguntas database table.
 * 
 */
@Entity
@Table(name="preguntas")
@NamedQuery(name="Pregunta.findAll", query="SELECT p FROM Pregunta p")
public class Pregunta implements Serializable {
   private static final long serialVersionUID = 1L;

   @Id
   @GeneratedValue(strategy=GenerationType.IDENTITY)
   private int idPregunta;

   private String enunciado;

   //bi-directional many-to-one association to Curso
   @ManyToOne
   //name es el nombre de la Foreing Key, es decir, el nombre de la columna de relación 
   // en el lado muchos
   // es el nombre de la primary key en el lado uno
   @JoinColumn(name="idCurso", referencedColumnName = "idCurso")
   private Curso curso;

   public Pregunta() {
   }

   public int getIdPregunta() {
      return this.idPregunta;
   }

   public void setIdPregunta(int idPregunta) {
      this.idPregunta = idPregunta;
   }

   public String getEnunciado() {
      return this.enunciado;
   }

   public void setEnunciado(String enunciado) {
      this.enunciado = enunciado;
   }

   public Curso getCurso() {
      return this.curso;
   }

   public void setCurso(Curso curso) {
      this.curso = curso;
   }

}
```

Observaciones sobre la Entidad `Pregunta` (Entidad MUCHOS):

* Anotada con `@Entity`
* Anotada con `@Table(name="preguntas")`
* Anotada con `@NamedQuery(name="Pregunta.findAll", query="SELECT p FROM Pregunta p")`
* Implementa `Serializable`
* El atributo que representa la clave principal esta anotada con `@Id` y `  @GeneratedValue(strategy=GenerationType.IDENTITY)` para la estrategía de generación de la clave.
* **Los campos de la Tabla `preguntas` son: `idPregunta`, `idCurso`, `enunciado`** y el asistente en la Entidad a añadido los atributos `idPregunta`, `enunciado`, **pero para `idCurso` a insertado un atributo `curso` INCLUYE TODO EL CURSO NO SOLAMENTE el `idCurso`**.
* El atributo `curso` esta anotado con `@ManyToOne` y con `@JoinColumn(name="idCurso")` esto lo que permite es relacionar la Entidad `Pregunta` con `Curso`, dado que `Pregunta` representa la Entidad MUCHOS es anotada con `@ManyToOne` y con `@JoinColumn(name="idCurso")` le decimos cual es la columna de Curso que sirve para relacionarse en este caso es `idCurso`. **LO ÚNICO QUE EL ASISTENTE NO PONE Y QUE LO DEBEMOS HACER MANUALMENTE ES INDICAR LA COLUMNA REFERENCIADA DE LA OTRA TABLA CON LA QUE SE VA A RELACIONAR** Por lo que la Anotación final nos queda así **@JoinColumn(name="idCurso", referencedColumnName = "idCurso")**

### Creación de los EJBs.

![22-25-ej](images/22-25-ej.png)

Vamos a crear algunos métodos de ejemplos de las relaciones entre Entidades. En la Interface tenemos:

`CursosService`

```java
package service;

import java.util.Date;
import java.util.List;

import javax.ejb.Local;

import model.Curso;
import model.Pregunta;

@Local
public interface CursosService {
	
   List<Pregunta> preguntasCurso(String curso);
   List<Pregunta> preguntasCursoDuracion(Date fechaInicio);
   List<Curso> cursosPorPregunta(String texto);
   
}
```

La implementación de la Interface es la siguiente:

`CursosServiceImp`

```java
package service;

import java.util.Date;
import java.util.List;

import javax.ejb.LocalBean;
import javax.ejb.Stateless;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.TemporalType;
import javax.persistence.TypedQuery;

import model.Curso;
import model.Pregunta;

/**
 * Session Bean implementation class CursosService
 */
@Stateless
@LocalBean
public class CursosServiceImp implements CursosService {

   @PersistenceContext
   EntityManager em;
   @Override
   public List<Pregunta> preguntasCurso(String curso){
    	
      /* 1er Forma
      String jpql = "SELECT c FROM Curso c WHERE c.nombre=?1";
      TypedQuery<Curso> query = em.createQuery(jpql, Curso.class);
      query.setParameter(1, curso);
      List<Curso> cursos=query.getResultList();
    	
      if(cursos.size() > 0) {
         Curso cr =cursos.get(0);
         return cr.getPreguntas();
      }
    	
      return null;
      */
		
      //2da Forma Con JOINs Implicitos //Mejor solucion que la anterior carga menos recursos
      String jpql = "SELECT p FROM Pregunta p WHERE p.curso.nombre=?1";
      TypedQuery<Pregunta> query = em.createQuery(jpql, Pregunta.class);
      query.setParameter(1, curso);
      return query.getResultList();
   }
   
   @Override
   public List<Pregunta> preguntasCursoDuracion(Date fechaInicio) {
      String jpql = "SELECT p FROM Pregunta p WHERE p.curso.fechaInicio>?1";
      TypedQuery<Pregunta> query = em.createQuery(jpql, Pregunta.class);
      query.setParameter(1, fechaInicio, TemporalType.DATE);
      return query.getResultList();
   }
	
   @Override
   public List<Curso> cursosPorPregunta(String texto) {
      String jpql="SELECT c FROM Curso c JOIN c.preguntas p WHERE p.enunciado LIKE ?1";
      TypedQuery<Curso> query=em.createQuery(jpql,Curso.class);
      query.setParameter(1, "%"+texto+"%");
      return query.getResultList();
   }

}
```

Vamos a explicar cada uno de los métodos.

1. `preguntasCurso(String curso)` 

   En este método, dado el nombre de un curso, vamos a recuperar una lista de preguntas para ese curso. En la primera solución, lo primero que hacemos 













## JOINS

![05-47](images/05-47.png)
![05-48](images/05-48.png)
![05-49](images/05-49.png)
![05-50](images/05-50.png)

## Claves Primarias Compuestas

![05-51](images/05-51.png)
![05-52](images/05-52.png)
![05-53](images/05-53.png)
![05-54](images/05-54.png)
