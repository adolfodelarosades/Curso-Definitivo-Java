# 20201116 Lunes

## :computer: `21_formacion_ejb_weblogic`

Partiendo del proyecto `19_formacion_factoria` vamos a realizar una versión usando EJB.

![21-00-ej](images/21-00-ej.png)

### Creación del Data Source en WebLogic

![21-01-ej](images/21-01-ej.png)
![21-02-ej](images/21-02-ej.png)
![21-03-ej](images/21-03-ej.png)
![21-04-ej](images/21-04-ej.png)
![21-05-ej](images/21-05-ej.png)
![21-06-ej](images/21-06-ej.png)
![21-07-ej](images/21-07-ej.png)
![21-08-ej](images/21-08-ej.png)
![21-09-ej](images/21-09-ej.png)
![21-10-ej](images/21-10-ej.png)
![21-11-ej](images/21-11-ej.png)
![21-12-ej](images/21-12-ej.png)

### Ubicación del Log de WebLogic

`/Users/adolfodelarosa/Documents/WEBLOGIC12/user_projects/domains/formacion_domain/servers/AdminServer/logs/AdminServer.log`

### Creación Proyecto en Eclipse

![21-13-ej](images/21-13-ej.png)

### Mavenizar Proyecto

![21-14-ej](images/21-14-ej.png)

### Dar Características JPA

![21-15-ej](images/21-15-ej.png)

### Modificación del Archivo `persistence.xml`

Copiamos el archivo `persistence.xml` del proyecto `19_formacion_factoria` al actual pero tenemos que realizar algunos cambios, en el proyecto anterior la conexión a la BD la haciamos directamente pero con el uso de WebLogic ya vamos a usar el DataSource creado en el primer paso. Por lo que entramos en la pestaña Conexión y cambiamos los valores como se muestra en las siguientes imagenes.

![21-16-ej](images/21-16-ej.png)

Mientras que en la pestaña de General tenemos

![21-17-ej](images/21-17-ej.png)

El archivo `persistence.xml` nos queda así:

```html
<?xml version="1.0" encoding="UTF-8"?>
<persistence version="2.2" xmlns="http://xmlns.jcp.org/xml/ns/persistence" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd">
   <persistence-unit name="formacionPU" transaction-type="JTA">
      <provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>
      <jta-data-source>jdbc/formacionds</jta-data-source>
         <class>model.Alumno</class>
         <class>model.Curso</class>
      	 <properties>			
            <property name="hibernate.transaction.jta.platform" value="org.hibernate.engine.transaction.jta.platform.internal.WeblogicJtaPlatform"/>				
         </properties>
   </persistence-unit>
</persistence>
```

**Como descubrimos que existe un pequeño conflicto entre Hibernate y EJB se tuvo que poner la etiqueta `<properties>` para que trabajen correctamente**.

```html
<properties>			
   <property name="hibernate.transaction.jta.platform" 
	     value="org.hibernate.engine.transaction.jta.platform.internal.WeblogicJtaPlatform"/>
</properties>
```

Existe otra alternativa para no trabajar con Hibernate y usar el Motor de Persistencia que viene integrado en WebLogic que en este caso es **EclipseLink** para lo cual nuestro `persistence.xml` quedaría así:

![21-18-ej](images/21-18-ej.png)

**NOTA** *Las Entidades las copiamos directamente del proyecto `19_formacion_factoria`, no usamos el asistente para crear las Entidades.*

### Creación del EJB.

La lógica del Servicio del proyecto `19_formacion_factoria` es la siguiente:

![21-21-ej](images/21-21-ej.png)

Dos Clases con sus respectivas Interfaces y la clase de Factoria.

Todo este Servicio lo debemos implementar usando EJBs. 

Vamos a necesitar un EJB para `Alumnos` y otro para `Cursos` y el Factory ya no va a ser necesario ya que EJB nos lo proporciona implícitamente.

![21-19-ej](images/21-19-ej.png)

![21-20-ej](images/21-20-ej.png)

Como estamos partiendo de código ya desarrollado en otra aplicación vamos a copiar los métodos ya desarrollados en el servicio y lo vamos a meter en las Clases del EJB y lo vamos a adaptar.

Partimos de `AlumnosServiceImpl` del proyecto `19_formacion_factoria`:

`AlumnosServiceImpl`

```java
...

public class AlumnosServiceImpl implements AlumnosService {
	
   private static EntityManager em;
   static {
      EntityManagerFactory factory=Persistence.createEntityManagerFactory("formacionPU");
      em=factory.createEntityManager();
   }
   
   @Override
   public void altaAlumno(Alumno alumno) {
      EntityTransaction tx = em.getTransaction();
      tx.begin();
      em.persist(alumno);
      tx.commit();
   }
	
   @Override
   public Alumno buscarAlumnoPorUsuario(String usuario){
      return em.find(Alumno.class,usuario);
   }

}
```

Y adaptandola a EJBs nos queda así:

`AlumnosServiceImpl`

```java
...

@Stateless
@LocalBean
public class AlumnosServiceImpl implements AlumnosService {

   @PersistenceContext(unitName = "formacionPU")
   private EntityManager em;
	
   @Override
   public void altaAlumno(Alumno alumno) {
      em.persist(alumno);
   }
	
   @Override
   public Alumno buscarAlumnoPorUsuario(String usuario){
      return em.find(Alumno.class,usuario);
   }

}
```

Observaciones del EJB:

* La clase esta anotada con `@Stateless` lo que indica que es un EJB, también anotada con `@LocalBean`. La anotación `@Stateless` es la que lo convierte en un EJB y le indica al contenedor de aplicaciones que debe encargarse de manejarlo. La anotación `@LocalBean` indica que a esta clase no se va a acceder de forma remota (desde fuera de nuestra aplicación).
* Eliminamos la Factoria y en su lugar Inyectamos directamente el `EntityManager` usando la anotación `@PersistenceContext(unitName = "formacionPU")`.
* Eliminamos todo lo referente a las transacciones.

Con todos estos cambios la clase reduce en gran medida su código.

Normalmente primero códificamos la Interface y luego la Clase pero en este caso hemos iniciado copiando el código en la Clase, para generar la Interface a partir de la Clase podemos usar la opción:

![21-22-ej](images/21-22-ej.png)

![21-23-ej](images/21-23-ej.png)

![21-24-ej](images/21-24-ej.png)

Realizamos los mismos pasos para el EJB de `Cursos`.

![21-25-ej](images/21-25-ej.png)

![21-26-ej](images/21-26-ej.png)

En este último paso no se debería haber usado el atributo `em`, solo se seleccionan los métodos.

![21-27-ej](images/21-27-ej.png)

Las Clases e Interfaces finales de los EJBs son:

Interface `AlumnosService`

```java
package service;

import javax.ejb.Local;

import model.Alumno;

@Local
public interface AlumnosService {
   Alumno buscarAlumnoPorUsuario(String usuario);
   void altaAlumno(Alumno alumno);
}
```

Clase `AlumnosServiceImpl`

```java
package service;

import javax.ejb.LocalBean;
import javax.ejb.Stateless;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

import model.Alumno;

/**
 * Session Bean implementation class AlumnosServiceImpl
 */
@Stateless
@LocalBean
public class AlumnosServiceImpl implements AlumnosService {

   @PersistenceContext(unitName = "formacionPU")
   private EntityManager em;
	
   @Override
   public void altaAlumno(Alumno alumno) {
      em.persist(alumno);
   }
	
   @Override
   public Alumno buscarAlumnoPorUsuario(String usuario){
      return em.find(Alumno.class,usuario);
   }

}
```

Interface `CursosService`

```java
package service;

import javax.ejb.Local;
import model.Curso;

@Local
public interface CursosService {
   void altaCurso(Curso curso);
}
```

Clase `CursosServiceImpl`

```java
package service;

import javax.ejb.LocalBean;
import javax.ejb.Stateless;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;

import model.Curso;

/**
 * Session Bean implementation class CursosServiceImpl
 */
@Stateless
@LocalBean
public class CursosServiceImpl implements CursosService {

   @PersistenceContext(unitName = "formacionPU")
   private EntityManager em;
	
   @Override
   public void altaCurso(Curso curso) {
      em.persist(curso);
   }
   
}
```

### Modificar Controllers

Como hemos visto, con estos cambios el Factory a sido eliminado por lo que debemos hacer algunos cambios en nuestros Controladores que lo usaban así:

Originalmente teniamos:

```java
AlumnosService service =  FormacionFactory.getAlumnosService();
```

o

```java
CursoService service = FormacionFactory.getCursosService();
```

En lugar de Instanciar el Servicio con la Factoria, vamos a inyectar los EJBs dentro de los Action de la siguiente forma.

```java
...

@EJB
AlumnosService service;
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
   ...
```
o

```java
...

@EJB
CursosService service;
protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
	
   ...
```

Simplemente usamos la anotación `@EJB` para inyectar el EJB.

### Vistas

Las Vistas no sufren ningún cambio.

### Probar la aplicación.

![21-28-ej](images/21-28-ej.png)
![21-29-ej](images/21-29-ej.png)
![21-30-ej](images/21-30-ej.png)
![21-31-ej](images/21-31-ej.png)
![21-32-ej](images/21-32-ej.png)

## Relación Entre Entidades

![05-39](images/05-39.png)
![05-40](images/05-40.png)
![05-41](images/05-41.png)
![05-42](images/05-42.png)
![05-43](images/05-43.png)
![05-44](images/05-44.png)
![05-45](images/05-45.png)
![05-46](images/05-46.png)

## :computer: `22_ejemplo_relaciones`

Este proyecto nuevo nos va a servir para ver algunos ejemplos de **Relación Entre Entidades**. Este proyecto no tiene ninguna parte visual solo nos va a servir para ver las relaciones existentes entre las Tablas `Cursos` y `Preguntas`.
de la BD `formacion`.

![22-00-ej](images/22-00-ej.png)

### BD `formacion`

Tablas `Cursos` y `Preguntas`

![22-01-ej](images/22-01-ej.png)

![22-02-ej](images/22-02-ej.png)

![22-03-ej](images/22-03-ej.png)

### Creación del Proyecto Eclipse

![22-04-ej](images/22-04-ej.png)

### Mavenizar el Proyecto e incluir las dependencias de Hibernate.

`pom.xml`

```html
<!-- https://mvnrepository.com/artifact/org.hibernate/hibernate-core --> 
<dependency>
   <groupId>org.hibernate</groupId>
   <artifactId>hibernate-core</artifactId>
   <version>5.4.18.Final</version>
</dependency>
```

### Creación de una Nueva Conexión

El siguiente paso sería usar el asistente para crear las Entidades de `Cursos` y `Preguntas` **pero en ejemplos anteriores vimos que al  hacer este paso teniamos el problema de duplicación de campos por usar el conector de MySQL 8, para evitar estos problemas vamos a usar el conector de MySQL 5**.

Entramos en la opción **JPA Tools -> Generate Entities Tables...** y vamos a crear una nueva conexión para poder usar el Driver de MySQL 5.

![22-05-ej](images/22-05-ej.png)
![22-06-ej](images/22-06-ej.png)
![22-07-ej](images/22-07-ej.png)
![22-08-ej](images/22-08-ej.png)
![22-09-ej](images/22-09-ej.png)
![22-10-ej](images/22-10-ej.png)

Una vez que ya tenemos la conección con MySQL 5 vamos a generar las Entidades.

![22-11-ej](images/22-11-ej.png)
![22-12-ej](images/22-12-ej.png)

En este caso si tenemos una relación entre las tablas las cuales se relacionan por medio del campo `idCurso`, presionamos en `+` para añadir la relación.

![22-13-ej](images/22-13-ej.png)

Vamos a indicar que es una *Asociación Simple* entre las tablas `Cursos` y `Preguntas`.

![22-14-ej](images/22-14-ej.png)

En la siguiente pantalla

![22-15-ej](images/22-15-ej.png)

Debemos indicar a través de que campo se relacionan las tablas, al presionar en `Add` pone cualquier campo dde las tablas.

![22-16-ej](images/22-16-ej.png)

Debemos modificarlo para poner exactamente el que nosotros necesitemos.

![22-17-ej](images/22-17-ej.png)

En la siguiente pantalla debemos indicar la relación existente entre `Cursos` y `Preguntas` y en este caso corresponde a una relación **One to many** *Cada Curso tiene muchas Preguntas.*

![22-18-ej](images/22-18-ej.png)

Se nos muestra gráficamente la relación y si la seleccionamos muestra más detalles.

![22-19-ej](images/22-19-ej.png)

En la siguiente pantalla.

![22-20-ej](images/22-20-ej.png)

Solo vamos a cambiar el paquete donde vamos a almacenar las Entidades `model`.

![22-21-ej](images/22-21-ej.png)

En la siguiente pantalla vamos a definir para cada Entidad como se van a generar las llaves.

![22-22-ej](images/22-22-ej.png)
![22-23-ej](images/22-23-ej.png)

Al presionar Finish se generan las dos Entidades.

![22-24-ej](images/22-24-ej.png)

Vamos a ver cada una de las Entidades.

Entidad `Curso` (UNO)

```java
package model;

import java.io.Serializable;
import javax.persistence.*;
import java.util.Date;
import java.util.List;

/**
 * The persistent class for the cursos database table.
 * 
 */
@Entity
@Table(name="cursos")
@NamedQuery(name="Curso.findAll", query="SELECT c FROM Curso c")
public class Curso implements Serializable {
   private static final long serialVersionUID = 1L;

   @Id
   @GeneratedValue(strategy=GenerationType.IDENTITY)
   private int idCurso;

   private int duracion;

   @Temporal(TemporalType.DATE)
   private Date fechaInicio;

   private String nombre;

   //bi-directional many-to-one association to Pregunta
   @OneToMany(mappedBy="curso")
   private List<Pregunta> preguntas;

   public Curso() {
   }

   public int getIdCurso() {
      return this.idCurso;
   }

   public void setIdCurso(int idCurso) {
      this.idCurso = idCurso;
   }

   public int getDuracion() {
      return this.duracion;
   }

   public void setDuracion(int duracion) {
      this.duracion = duracion;
   }

   public Date getFechaInicio() {
      return this.fechaInicio;
   }

   public void setFechaInicio(Date fechaInicio) {
      this.fechaInicio = fechaInicio;
   }

   public String getNombre() {
      return this.nombre;
   }

   public void setNombre(String nombre) {
      this.nombre = nombre;
   }

   public List<Pregunta> getPreguntas() {
      return this.preguntas;
   }

   public void setPreguntas(List<Pregunta> preguntas) {
      this.preguntas = preguntas;
   }

   public Pregunta addPregunta(Pregunta pregunta) {
      getPreguntas().add(pregunta);
      pregunta.setCurso(this);

      return pregunta;
   }

   public Pregunta removePregunta(Pregunta pregunta) {
      getPreguntas().remove(pregunta);
      pregunta.setCurso(null);

      return pregunta;
   }

}
```

Observaciones sobre la Entidad `Curso` (Entidad "UNO"):

* Anotada con `@Entity`
* Anotada con `@Table(name="cursos")`
* Anotada con `@NamedQuery(name="Curso.findAll", query="SELECT c FROM Curso c")`
* Implementa `Serializable`
* El atributo que representa la clave principal esta anotada con `@Id` y `  @GeneratedValue(strategy=GenerationType.IDENTITY)` para la estrategía de generación de la clave.
* Los campos de tipo `Date` se anotan con `@Temporal(TemporalType.DATE)`
* **Los campos de la Tabla `cursos` son: `idCurso`, `nombre`, `duracion`, `fechaInicio`** y el asistente en la Entidad a añadido los atributos `idCurso`, `nombre`, `duracion`, `fechaInicio` pero añade un atributo más.
* **SE AÑADE EL ATRIBUTO `private List<Pregunta> preguntas;` CON LA ANOTACIÓN `@OneToMany(mappedBy="curso")`**, esto lo hace por que establecimos una relación ONE-TO-MANY entre la tabla `cursos` con respecto a la tabla `preguntas` *Un Curso puede tener Muchas Preguntas* por lo que lo representa con este atributo.
* Añade los métodos `getters` y `setters` para todos los atributos.
* Añade dos métodos especiales para añadir y remover preguntas en la colección de preguntas.

Entidad `Pregunta` (MUCHOS)

```java
package model;

import java.io.Serializable;
import javax.persistence.*;


/**
 * The persistent class for the preguntas database table.
 * 
 */
@Entity
@Table(name="preguntas")
@NamedQuery(name="Pregunta.findAll", query="SELECT p FROM Pregunta p")
public class Pregunta implements Serializable {
   private static final long serialVersionUID = 1L;

   @Id
   @GeneratedValue(strategy=GenerationType.IDENTITY)
   private int idPregunta;

   private String enunciado;

   //bi-directional many-to-one association to Curso
   @ManyToOne
   // "name" es el nombre de la Foreing Key, es decir, el nombre de la columna de relación en el lado muchos
   // "referenceColumname" es el nombre de la primary key en el lado uno
   @JoinColumn(name="idCurso", referencedColumnName = "idCurso")
   private Curso curso;

   public Pregunta() {
   }

   public int getIdPregunta() {
      return this.idPregunta;
   }

   public void setIdPregunta(int idPregunta) {
      this.idPregunta = idPregunta;
   }

   public String getEnunciado() {
      return this.enunciado;
   }

   public void setEnunciado(String enunciado) {
      this.enunciado = enunciado;
   }

   public Curso getCurso() {
      return this.curso;
   }

   public void setCurso(Curso curso) {
      this.curso = curso;
   }

}
```

Observaciones sobre la Entidad `Pregunta` (Entidad MUCHOS):

* Anotada con `@Entity`
* Anotada con `@Table(name="preguntas")`
* Anotada con `@NamedQuery(name="Pregunta.findAll", query="SELECT p FROM Pregunta p")`
* Implementa `Serializable`
* El atributo que representa la clave principal esta anotada con `@Id` y `  @GeneratedValue(strategy=GenerationType.IDENTITY)` para la estrategía de generación de la clave.
* **Los campos de la Tabla `preguntas` son: `idPregunta`, `idCurso`, `enunciado`** y el asistente en la Entidad a añadido los atributos `idPregunta`, `enunciado`, **pero para `idCurso` a insertado un atributo `curso` INCLUYE TODO EL CURSO NO SOLAMENTE el `idCurso`**.
* El atributo `curso` esta anotado con `@ManyToOne` y con `@JoinColumn(name="idCurso")` esto lo que permite es relacionar la Entidad `Pregunta` con `Curso`, dado que `Pregunta` representa la Entidad MUCHOS es anotada con `@ManyToOne` y con `@JoinColumn(name="idCurso")` le decimos cual es la columna de Curso que sirve para relacionarse en este caso es `idCurso`. **LO ÚNICO QUE EL ASISTENTE NO PONE Y QUE LO DEBEMOS HACER MANUALMENTE ES INDICAR LA COLUMNA REFERENCIADA DE LA OTRA TABLA CON LA QUE SE VA A RELACIONAR** Por lo que la Anotación final nos queda así **@JoinColumn(name="idCurso", referencedColumnName = "idCurso")**

### Creación de los EJBs.

![22-25-ej](images/22-25-ej.png)

Vamos a crear algunos métodos de ejemplos de las relaciones entre Entidades. En la Interface tenemos:

`CursosService`

```java
package service;

import java.util.Date;
import java.util.List;

import javax.ejb.Local;

import model.Curso;
import model.Pregunta;

@Local
public interface CursosService {
	
   List<Pregunta> preguntasCurso(String curso);
   List<Pregunta> preguntasCursoDuracion(Date fechaInicio);
   List<Curso> cursosPorPregunta(String texto);
   
}
```

La implementación de la Interface es la siguiente:

`CursosServiceImp`

```java
package service;

import java.util.Date;
import java.util.List;

import javax.ejb.LocalBean;
import javax.ejb.Stateless;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.TemporalType;
import javax.persistence.TypedQuery;

import model.Curso;
import model.Pregunta;

/**
 * Session Bean implementation class CursosService
 */
@Stateless
@LocalBean
public class CursosServiceImp implements CursosService {

   @PersistenceContext
   EntityManager em;
   @Override
   public List<Pregunta> preguntasCurso(String curso){
    	
      /* 1er Forma
      String jpql = "SELECT c FROM Curso c WHERE c.nombre=?1";
      TypedQuery<Curso> query = em.createQuery(jpql, Curso.class);
      query.setParameter(1, curso);
      List<Curso> cursos=query.getResultList();
    	
      if(cursos.size() > 0) {
         Curso cr =cursos.get(0);
         return cr.getPreguntas();
      }
    	
      return null;
      */
		
      //2da Forma Con JOINs Implícitos //Mejor solucion que la anterior carga menos recursos
      String jpql = "SELECT p FROM Pregunta p WHERE p.curso.nombre=?1";
      TypedQuery<Pregunta> query = em.createQuery(jpql, Pregunta.class);
      query.setParameter(1, curso);
      return query.getResultList();
   }
   
   @Override
   public List<Pregunta> preguntasCursoDuracion(Date fechaInicio) {
      String jpql = "SELECT p FROM Pregunta p WHERE p.curso.fechaInicio>?1";
      TypedQuery<Pregunta> query = em.createQuery(jpql, Pregunta.class);
      query.setParameter(1, fechaInicio, TemporalType.DATE);
      return query.getResultList();
   }
	
   @Override
   public List<Curso> cursosPorPregunta(String texto) {
      String jpql="SELECT c FROM Curso c JOIN c.preguntas p WHERE p.enunciado LIKE ?1";
      TypedQuery<Curso> query=em.createQuery(jpql,Curso.class);
      query.setParameter(1, "%"+texto+"%");
      return query.getResultList();
   }

}
```

Vamos a explicar cada uno de los métodos.

1. `List<Pregunta> preguntasCurso(String curso)` 

   En este método, dado el nombre de un curso, vamos a recuperar una lista de preguntas para ese curso. 
   
   En la primera solución, lo primero que hacemos es recuperar el Curso que cumple la condición, si existe retornamos el valor de su atributo `preguntas`. Esta solución es válida pero no es la mejor.
   
   Una segunda solución es usar los **JOINs IMPLÍCITOS** (Vea Diapositivas). Consiste en atacar directamente la Entidad que contiene los datos en este caso `Pregunta` y usar su atributo `curso` de tipo `Curso` el cual a su vez contiene el atributo `nombre` que es el que queremos comparar. La sentencia JPQL exacta es: `jpql = "SELECT p FROM Pregunta p WHERE p.curso.nombre=?1"` y basta ejecutar directamente esta sentencia para obtener los resultados. **Esta es una mejor solución que la anterior ya que requiere menos recursos**.
   
2. `List<Pregunta> preguntasCursoDuracion(Date fechaInicio)`   

   En este método, dada una fecha de inicio vamos a recuperar una lista de cursos que inician después de esta fecha.
   
   Para solucionarlo lo hacemos con **JOINs IMPLÍCITOS** la sentencia JPQL es:
   
   `jpql = "SELECT p FROM Pregunta p WHERE p.curso.fechaInicio>?1";`
   
3. `List<Curso> cursosPorPregunta(String texto)`  

   Con este método queremos recuperar los cursos que en sus preguntas contengan un texto que pasamos como parámetros.
   
   Para solucionarlo lo hacemos con **JOINs EXPLÍCITOS** la sentencia JPQL es 
   
   `jpql="SELECT c FROM Curso c JOIN c.preguntas p WHERE p.enunciado LIKE ?1";`
   
   Observe que para asignar el parámetro usamos:
   
   `query.setParameter(1, "%"+texto+"%");`
   

HASTA AQUÍ EL EJEMPLO QUE COMO DIJIMOS NO TIENE PARTE VISUAL NI SE TERMINO DE CONFIGURAR DEL TODO PERO NOS SIRVIO PARA VER LA RELACIÓN ENTRE ENTIDADES Y EL USO DE **JOINs IMPLÍCITOS y EXPLÍCITOS**.

## JOINS

![05-47](images/05-47.png)
![05-48](images/05-48.png)
![05-49](images/05-49.png)
![05-50](images/05-50.png)

## Claves Primarias Compuestas

![05-51](images/05-51.png)
![05-52](images/05-52.png)
![05-53](images/05-53.png)
![05-54](images/05-54.png)

## :computer: `23_formacion_ejb_weblogic_v2`

Partiendo del proyecto `21_formacion_ejb_weblogic` vamos a realizar una versión.

![23-00-ej](images/23-00-ej.png)

En esta nueva versión vamos a involucrar tres tablas de la BD de `Formacion` entre las cuales existe la siguiente relación.

![23-01-ej](images/23-01-ej.png)

*Un alumno puede estar matriculado en uno o más cursos y un curso puede pertenecer a varias matriculas*

Se pide añadir las siguientes a las ya existentes:

* Añadir una opción para buscar alumnos que tengan como mínima una nota que se pasa como parámetro.
* Añadir una opción para buscar alumnos de un cierto curso.
* Añadir una opción para buscar cursos de un alumno con su clave de usuario.
* Listado de todos los cursos.

Partimos de un proyecto ya Mavenizado con las dependencias existentes, que usa JPA y EJBs, pero actualmente solo cuenta con dos Entidades `Alumno` y `Curso` las cuales no tienen ninguna relación entre ellas, nosotros ademas de estas dos Entidades necesitamos la Entidad de `Matricula` y todas ellas con sus respectivas relaciones. ***Lo mejor es borrar las Entidades actuales y generarlas nuevamente con el asistente***.

### Generación de Entidades.

![23-02-ej](images/23-02-ej.png)

![23-03-ej](images/23-03-ej.png)

En este caso seleccionamos 3 tablas y en la siguiente pantalla vamos a relacionar las tablas, en este caso va a ver dos relaciones, la primera entre `Alumno` y `Matricula`.

![23-04-ej](images/23-04-ej.png)

![23-05-ej](images/23-05-ej.png)

![23-06-ej](images/23-06-ej.png)

![23-07-ej](images/23-07-ej.png)

 La segunda relación es entre `Curso` y `Matricula`.
 
 ![23-08-ej](images/23-08-ej.png)

![23-09-ej](images/23-09-ej.png)

![23-10-ej](images/23-10-ej.png)

![23-11-ej](images/23-11-ej.png)

Continuamos en la siguiente pantalla.

![23-12-ej](images/23-12-ej.png)

Establecemos las estrategias de generación de Claves.

![23-13-ej](images/23-13-ej.png)

![23-14-ej](images/23-14-ej.png)

![23-15-ej](images/23-15-ej.png)

### Entidades

Se han generan 4 Entidades.

![23-16-ej](images/23-16-ej.png)

Vamos a analizar cada una de ellas:

Entidad `Alumno` (Entidad UNO):

```java
package model;

import java.io.Serializable;
import javax.persistence.*;
import java.util.List;


/**
 * The persistent class for the alumnos database table.
 * 
 */
@Entity
@Table(name="alumnos")
@NamedQuery(name="Alumno.findAll", query="SELECT a FROM Alumno a")
public class Alumno implements Serializable {
   private static final long serialVersionUID = 1L;

   @Id
   private String usuario;

   private int edad;

   private String email;

   private String nombre;

   private String password;

   //bi-directional many-to-one association to Matricula
   @OneToMany(mappedBy="alumno")
   private List<Matricula> matriculas;

   public Alumno() {
   }
   
   public Alumno(String usuario, int edad, String email, String nombre, String password) {
      super();
      this.usuario = usuario;
      this.edad = edad;
      this.email = email;
      this.nombre = nombre;
      this.password = password;
   }

   public String getUsuario() {
      return this.usuario;
   }

   public void setUsuario(String usuario) {
      this.usuario = usuario;
   }

   public int getEdad() {
      return this.edad;
   }

   public void setEdad(int edad) {
      this.edad = edad;
   }

   public String getEmail() {
      return this.email;
   }

   public void setEmail(String email) {
      this.email = email;
   }

   public String getNombre() {
      return this.nombre;
   }

   public void setNombre(String nombre) {
      this.nombre = nombre;
   }

   public String getPassword() {
      return this.password;
   }

   public void setPassword(String password) {
      this.password = password;
   }

   public List<Matricula> getMatriculas() {
      return this.matriculas;
   }

   public void setMatriculas(List<Matricula> matriculas) {
      this.matriculas = matriculas;
   }

   public Matricula addMatricula(Matricula matricula) {
      getMatriculas().add(matricula);
      matricula.setAlumno(this);

      return matricula;
   }

   public Matricula removeMatricula(Matricula matricula) {
      getMatriculas().remove(matricula);
      matricula.setAlumno(null);

      return matricula;
   }

}
```

Observaciones de Entidad `Alumno`:

* Como Entidad UNO se relaciona con la Entidad MUCHOS con el atributo `private List<Matricula> matriculas;` anotado con `@OneToMany(mappedBy="alumno")`   
* Hemos añadido manualmente un Constructor con los campos sin incluir el atriburo de relación `matriculas`, solo los propios de la Entidad.

Entidad `Cursos` (Entidad UNO)

```java
package model;

import java.io.Serializable;
import javax.persistence.*;
import java.util.Date;
import java.util.List;


/**
 * The persistent class for the cursos database table.
 * 
 */
@Entity
@Table(name="cursos")
@NamedQuery(name="Curso.findAll", query="SELECT c FROM Curso c")
public class Curso implements Serializable {
   private static final long serialVersionUID = 1L;

   @Id
   @GeneratedValue(strategy=GenerationType.IDENTITY)
   private int idCurso;

   private int duracion;

   @Temporal(TemporalType.DATE)
   private Date fechaInicio;

   private String nombre;

   //bi-directional many-to-one association to Matricula
   @OneToMany(mappedBy="curso")
   private List<Matricula> matriculas;

   public Curso() {
   }
	
   public Curso(int idCurso, int duracion, Date fechaInicio, String nombre) {
      super();
      this.idCurso = idCurso;
      this.duracion = duracion;
      this.fechaInicio = fechaInicio;
      this.nombre = nombre;
   }

   public int getIdCurso() {
      return this.idCurso;
   }

   public void setIdCurso(int idCurso) {
      this.idCurso = idCurso;
   }

   public int getDuracion() {
      return this.duracion;
   }

   public void setDuracion(int duracion) {
      this.duracion = duracion;
   }

   public Date getFechaInicio() {
      return this.fechaInicio;
   }

   public void setFechaInicio(Date fechaInicio) {
      this.fechaInicio = fechaInicio;
   }

   public String getNombre() {
      return this.nombre;
   }

   public void setNombre(String nombre) {
      this.nombre = nombre;
   }

   public List<Matricula> getMatriculas() {
      return this.matriculas;
   }

   public void setMatriculas(List<Matricula> matriculas) {
      this.matriculas = matriculas;
   }

   public Matricula addMatricula(Matricula matricula) {
      getMatriculas().add(matricula);
      matricula.setCurso(this);

      return matricula;
   }

   public Matricula removeMatricula(Matricula matricula) {
      getMatriculas().remove(matricula);
      matricula.setCurso(null);

      return matricula;
   }

}
```

Observaciones de Entidad `Curso`:

* Como Entidad UNO se relaciona con la Entidad MUCHOS con el atributo `private List<Matricula> matriculas;` anotado con `@OneToMany(mappedBy="curso")`   
* Hemos añadido manualmente un Constructor con los campos sin incluir el atriburo de relación `matriculas`, solo los propios de la Entidad.

En el Caso de la Entidad `Matriculas` que abarca la Entidad MUCHOS para ambas relaciones y como puede observarse tiene una llave compuesta nos genera dos Entidades:


Entidad `MatriculaPK`:

```java
package model;

import java.io.Serializable;
import javax.persistence.*;

/**
 * The primary key class for the matriculas database table.
 * 
 */
@Embeddable
public class MatriculaPK implements Serializable {
   //default serial version id, required for serializable classes.
   private static final long serialVersionUID = 1L;

   private String usuario;

   private int idCurso;

   public MatriculaPK() {
   }

   public MatriculaPK(String usuario, int idCurso) {
      super();
      this.usuario = usuario;
      this.idCurso = idCurso;
   }

   public String getUsuario() {
      return this.usuario;
   }
   public void setUsuario(String usuario) {
      this.usuario = usuario;
   }
   public int getIdCurso() {
      return this.idCurso;
   }
   public void setIdCurso(int idCurso) {
      this.idCurso = idCurso;
   }

   public boolean equals(Object other) {
      if (this == other) {
         return true;
      }
      if (!(other instanceof MatriculaPK)) {
         return false;
      }
      MatriculaPK castOther = (MatriculaPK)other;
      return 
      	this.usuario.equals(castOther.usuario)
         	&& (this.idCurso == castOther.idCurso);
   }

   public int hashCode() {
      final int prime = 31;
      int hash = 17;
      hash = hash * prime + this.usuario.hashCode();
      hash = hash * prime + this.idCurso;
		
      return hash;
   }
}
```

Observaciones de Entidad `MatriculaPK`:

* Entidad que contiene solo atributos que representan la clave compuesta.
* Hemos añadido un Constructor para estos dos atributos.
* Tiene sobreescrito el `equals` y `hashCode`.

Entidad `Matricula`

```java
package model;

import java.io.Serializable;
import javax.persistence.*;

/**
 * The persistent class for the matriculas database table.
 * 
 */
@Entity
@Table(name="matriculas")
@NamedQuery(name="Matricula.findAll", query="SELECT m FROM Matricula m")
public class Matricula implements Serializable {
   private static final long serialVersionUID = 1L;

   @EmbeddedId
   private MatriculaPK id;

   private double nota;

   //bi-directional many-to-one association to Alumno
   @ManyToOne
   @JoinColumn(name="usuario",  referencedColumnName="usuario")
   private Alumno alumno;
   
   //bi-directional many-to-one association to Curso
   @ManyToOne
   @JoinColumn(name="idCurso", referencedColumnName="idCurso")
   private Curso curso;

   public Matricula() {
   }
	
   public Matricula(MatriculaPK id, double nota) {
      super();
      this.id = id;
      this.nota = nota;
   }

   public MatriculaPK getId() {
      return this.id;
   }

   public void setId(MatriculaPK id) {
      this.id = id;
   }
   
   public double getNota() {
      return this.nota;
   }

   public void setNota(double nota) {
      this.nota = nota;
   }

   public Alumno getAlumno() {
      return this.alumno;
   }

   public void setAlumno(Alumno alumno) {
      this.alumno = alumno;
   }

   public Curso getCurso() {
      return this.curso;
   }

   public void setCurso(Curso curso) {
      this.curso = curso;
   }

}
```

Observaciones de Entidad `Matricula`:

* Esta es la segunda parte de la Entidad `Matricula` por lo que incluye un atributo `id` `MatriculaPK` anotado con `@EmbeddedId` de esta manera incluimos la llave compuesta dentro de esta Entidad. 
* Incluye el atributo de relación `alumno` para realizar la relación con la Entidad `Alumno` anotado con 
`@ManyToOne` y `@JoinColumn(name="usuario",  referencedColumnName="usuario")` (añadida manualmente la referencia.
* Incluye el atributo de relación `curso` para realizar la relación con la Entidad `Curso` anotado con 
`@ManyToOne` y `@JoinColumn(name="idCurso", referencedColumnName="idCurso")` (añadida manualmente la referencia.
* Si dejamos la aplicación y la ejecutamos vamos a tener un problema como se muestra en la imagen:

   ![23-17-ej](images/23-17-ej.png)
   
   Este error sucede por que las llaves de cada Endidad se estan duplicando, por un lado tenemos añadido el atributo `id` el cual contiene internamente ambas claves principales `usuario` y `idCurso`; y por otro lado las anotaciones `@JoinColumn(name="usuario",..` o `@JoinColumn(name="idCurso",..` hacen referencia a esos nombres de llaves, es allí cuando se estan "duplicando" las llaves debemos añadir lo que se nos indica para eliminar el error. Por lo que las anotaciones finalmente nos quedan así:
   
   `@JoinColumn(name="usuario",  referencedColumnName="usuario", insertable = false, updatable = false)`
   
   y
   
   `@JoinColumn(name="idCurso", referencedColumnName="idCurso", insertable = false, updatable = false)`
   
   ![23-18-ej](images/23-18-ej.png)
   
### Archivo `persistence.xml`

`persistence.xml`

```
<?xml version="1.0" encoding="UTF-8"?>
<persistence version="2.2" xmlns="http://xmlns.jcp.org/xml/ns/persistence" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_2.xsd">
   <persistence-unit name="formacionPU" transaction-type="JTA">
      <provider>org.hibernate.jpa.HibernatePersistenceProvider</provider>
      <jta-data-source>jdbc/formacionds</jta-data-source>
      <class>model.Alumno</class>
      <class>model.Curso</class>
      <class>model.Matricula</class>
      <class>model.MatriculaPK</class>
      <properties>			
         <property name="hibernate.transaction.jta.platform" value="org.hibernate.engine.transaction.jta.platform.internal.WeblogicJtaPlatform"/>				
         <!--  <property name="hibernate.dialect" value="org.hibernate.dialect.MySQLDialect"/>-->
      </properties>
   </persistence-unit>
</persistence>
```
   
### Añadir Métodos en los EJBs.

Mostramos el código final en la Capa de Lógica de Negocio **donde usamos JPA para recuperar la información de la BD**, hemos usado ***EntityManager, Querys, TypedQuery, Consultas Parametrizadas, NamedQuery, Relaciones entre Entidades, usando JOINS Implícitos y Explícitos, Claves Primarias Compuestas***

`AlumnosService`

```java
package service;

import java.util.List;
import javax.ejb.Local;
import model.Alumno;

@Local
public interface AlumnosService {

   void altaAlumno(Alumno alumno);

   List<Alumno> alumnos();
   Alumno buscarAlumnoPorUsuario(String usuario);
   List<Alumno> alumnosNotas(double nota);
   List<Alumno> alumnosCurso(int idCurso);
}
```

`AlumnosServiceImpl`

```java
package service;

import java.util.List;

import javax.ejb.LocalBean;
import javax.ejb.Stateless;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.TypedQuery;

import model.Alumno;

/**
 * Session Bean implementation class AlumnosServiceImpl
 */
@Stateless
@LocalBean
public class AlumnosServiceImpl implements AlumnosService {

   @PersistenceContext(unitName = "formacionPU")
   private EntityManager em;
	
   @Override
   public void altaAlumno(Alumno alumno) {
      em.persist(alumno);
   }
   @Override
   public List<Alumno> alumnos() {
      TypedQuery<Alumno> query=em.createNamedQuery("Alumno.findAll",Alumno.class);
      return query.getResultList();
   }
   @Override
   public Alumno buscarAlumnoPorUsuario(String usuario) {
      return em.find(Alumno.class, usuario);
   }
   @Override
   public List<Alumno> alumnosCurso(int idCurso) {
      String jpql="SELECT a FROM Alumno a JOIN a.matriculas m WHERE m.curso.idCurso=?1";
      TypedQuery<Alumno> query=em.createQuery(jpql,Alumno.class);
      query.setParameter(1, idCurso);
      return query.getResultList();
   }
   @Override
   public List<Alumno> alumnosNotas(double nota) {
      String jpql="SELECT distinct a FROM Alumno a JOIN a.matriculas m WHERE m.nota>=?1";
      TypedQuery<Alumno> query=em.createQuery(jpql,Alumno.class);
      query.setParameter(1, nota);
      return query.getResultList();
   }

}
```

`CursosService`

```java
package service;

import java.util.List;
import javax.ejb.Local;
import model.Curso;

@Local
public interface CursosService {

   void altaCurso(Curso curso);
   List<Curso> obtenerCursos();
   List<Curso> cursosAlumno(String usuario);
}
```

`CursosServiceImpl`

```java
package service;

import java.util.List;

import javax.ejb.LocalBean;
import javax.ejb.Stateless;
import javax.persistence.EntityManager;
import javax.persistence.PersistenceContext;
import javax.persistence.TypedQuery;

import model.Curso;

@Stateless
@LocalBean
public class CursosServiceImpl implements CursosService {

   @PersistenceContext(unitName = "formacionPU")
   private EntityManager em;
	
   @Override
   public void altaCurso(Curso curso) {
      em.persist(curso);
   }
   @Override
   public List<Curso> obtenerCursos() {	
      TypedQuery<Curso> query=em.createNamedQuery("Curso.findAll",Curso.class);
      return query.getResultList();
      /* Sin usar NamedQuery
      String jpql="SELECT c FROM Curso c";
      TypedQuery<Curso> query=em.createNamedQuery(jpql,Curso.class);
      return query.getResultList();
      */
   }
   @Override
   public List<Curso> cursosAlumno(String usuario) {
      String jpql="SELECT c FROM Curso c JOIN c.matriculas m WHERE m.alumno.usuario=?1";
      TypedQuery<Curso> query=em.createQuery(jpql,Curso.class);
      query.setParameter(1, usuario);
      return query.getResultList();
   }

}
```

### Añadir Actions

En esta Capa Inyectamos la Capa de Lógica de Negocios (EJBs) para recuperar los datos.

`AltaAlumnoAction`

```java
package controller;

import java.io.IOException;

import javax.ejb.EJB;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import model.Alumno;
import service.AlumnosService;

@WebServlet("/AltaAlumnoAction")
public class AltaAlumnoAction extends HttpServlet {
   private static final long serialVersionUID = 1L;

   @EJB
   AlumnosService service;
   protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
		
      String usuario = request.getParameter("usuario");
      String password = request.getParameter("password");
      String nombre = request.getParameter("nombre");
      String email = request.getParameter("email");
      int  edad = Integer.parseInt(request.getParameter("edad"));
		
      if( service.buscarAlumnoPorUsuario(usuario) == null ) {
         service.altaAlumno(new Alumno(usuario,edad,email,nombre,password));
         request.setAttribute("resultado", true);
      }else {
         request.setAttribute("resultado", false);
      }
   }
}
```

`AltaCursoAction`

```java
package controller;

import java.io.IOException;
import java.text.ParseException;
import java.text.SimpleDateFormat;

import javax.ejb.EJB;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import model.Curso;
import service.CursosService;

@WebServlet("/AltaCursoAction")
public class AltaCursoAction extends HttpServlet {
   private static final long serialVersionUID = 1L;

   @EJB
   CursosService service;
   protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
      try {
         String nombre  = request.getParameter("nombre");
         int duracion  = Integer.parseInt(request.getParameter("duracion"));
         String fechaInicio  = request.getParameter("fechaInicio");
         SimpleDateFormat format = new SimpleDateFormat("yyyy-MM-dd");
         service.altaCurso(new Curso(0,duracion, format.parse(fechaInicio), nombre));
      } catch (NumberFormatException e) {
         e.printStackTrace();
      } catch (ParseException e) {
         e.printStackTrace();
      }
   }
}
```

`AlumnosAction`

```java
package controller;

import java.io.IOException;

import javax.ejb.EJB;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import service.AlumnosService;

@WebServlet("/AlumnosAction")
public class AlumnosAction extends HttpServlet {
   private static final long serialVersionUID = 1L;

   @EJB
   AlumnosService service;
   protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
      request.setAttribute("alumnos", service.alumnos());
   }
}
```

`AlumnosCursoAction`

```java
package controller;

import java.io.IOException;

import javax.ejb.EJB;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import service.AlumnosService;

@WebServlet("/AlumnosCursoAction")
public class AlumnosCursoAction extends HttpServlet {
   private static final long serialVersionUID = 1L;
	
   @EJB
   AlumnosService service;
   protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
      int idCurso=Integer.parseInt(request.getParameter("idCurso"));
      request.setAttribute("alumnoscurso", service.alumnosCurso(idCurso));
   }
}
```

`AlumnosNotaAction`

```java
package controller;

import java.io.IOException;

import javax.ejb.EJB;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import service.AlumnosService;

@WebServlet("/AlumnosNotaAction")
public class AlumnosNotaAction extends HttpServlet {
   private static final long serialVersionUID = 1L;

   @EJB
   AlumnosService service;
   protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
      double nota=Double.parseDouble(request.getParameter("nota"));
      request.setAttribute("alumnosnota", service.alumnosNotas(nota));
   }
}
```

`CursosAction`

```java
package controller;

import java.io.IOException;

import javax.ejb.EJB;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import service.CursosService;

@WebServlet("/CursosAction")
public class CursosAction extends HttpServlet {
   private static final long serialVersionUID = 1L;

   @EJB
   CursosService service;
   protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
      request.setAttribute("cursos", service.obtenerCursos());
   }
}
```

`CursosAlumnoAction`

```java
package controller;

import java.io.IOException;

import javax.ejb.EJB;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

import service.CursosService;

@WebServlet("/CursosAlumnoAction")
public class CursosAlumnoAction extends HttpServlet {
   private static final long serialVersionUID = 1L;

   @EJB
   CursosService service;
   protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
      String usuario=request.getParameter("usuario");
      request.setAttribute("cursosalumno", service.cursosAlumno(usuario));
   }
}
```

### FrontController

El FrontController invoca a los Actions para realizar las acciones y redirigir a la vista correspondiente.

`FrontController`

```java
package controller;

import java.io.IOException;
import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;

@WebServlet("/FrontController")
public class FrontController extends HttpServlet {
   private static final long serialVersionUID = 1L;

   protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
      String url = "";
      String option = request.getParameter("option");
		
      switch(option) {
         case "doAltaAlumno":
            request.getRequestDispatcher("AltaAlumnoAction").include(request, response);
            url = (boolean)request.getAttribute("resultado")? "menu.html":"alumnoRepetido.jsp";
            break;
         case "doAlumnos":
            request.getRequestDispatcher("AlumnosAction").include(request, response);
            url="seleccionalumnos.jsp";
            break;
         case "doAlumnosCurso":
            request.getRequestDispatcher("AlumnosCursoAction").include(request, response);
            url="alumnoscurso.jsp";
            break;
         case "doAlumnosNota":
            request.getRequestDispatcher("AlumnosNotaAction").include(request, response);
            url="alumnosnota.jsp";
            break;
         case "doAltaCurso":
            request.getRequestDispatcher("AltaCursoAction").include(request, response);
            url="menu.html";
            break;
         case "doCursos":
            request.getRequestDispatcher("CursosAction").include(request, response);
            url="seleccioncursos.jsp";
            break;
         case "doCursosAlumno":
            request.getRequestDispatcher("CursosAlumnoAction").include(request, response);
            url="cursosalumno.jsp";
            break;
         case "toMenu":
            url="menu.html";
            break;
         case "toAltaAlumno":
            url="altaAlumno.html";
            break;
         case "toAltaCurso":
            url="altaCurso.html";
            break;
         case "toNota":
            url="nota.html";
            break;
      }
      request.getRequestDispatcher(url).forward(request, response);
   }
}
```

### Añadir Vistas

`menu.html`
```html
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Menú</title>
<link rel="stylesheet" type="text/css" href="css/w3.css">
</head>
<body>
   <div align="center">
      <h1 class="w3-jumbo">Formación</h1>
      <p class="w3-xlarge w3-text-dark-grey">Los mejores cursos del mercado</p>
  	  <p>
  	     <a href="FrontController?option=toAltaAlumno" class="w3-button w3-dark-grey">Alta Alumno</a>
  	     <a href="FrontController?option=doCursos"class="w3-button w3-dark-grey">Buscar Alumnos Curso</a>
  	     <a href="FrontController?option=toNota" class="w3-button w3-dark-grey">Buscar Alumnos Nota</a>
  	  </p>
  	  
      <p>
         <a href="FrontController?option=toAltaCurso" class="w3-button w3-dark-grey">Alta Curso</a>
         <a href="FrontController?option=doAlumnos" class="w3-button w3-dark-grey">Buscar Cursos Alumno</a>
      </p>
   </div>
</body>
</html>
```

`altaAlumno.html`

```html
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Nuevo Usuario</title>
<link rel="stylesheet" type="text/css" href="css/w3.css">
</head>
<body>
    <div class="w3-padding">
        <h1>Nuevo Alumno</h1>
		<fieldset>
			<legend>Datos del Alumno</legend>
			<form action="FrontController?option=doAltaAlumno" method="post">
				<label for="fusuario">Usuario</label><br>
				<input type="text" name="usuario" required="required"><br>
				<label for="fpassword">Contraseña</label><br>
				<input type="password" name="password" required="required"><br>
				<label for="fnombre">Nombre</label><br>
				<input type="text" name="nombre" required="required"><br>
				<label for="femail">Email</label><br>
				<input type="text" name="email" required="required"><br>
				<label for="fedad">Edad</label><br>
				<input type="number" name="edad" required="required"><br><br>
				<input type="submit" value="Guardar">
				<input type="reset">
			</form>
		</fieldset>
	</div>
	<div align="right" class="w3-padding">
		<a href="FrontController?option=toMenu" class="w3-button w3-dark-grey">Volver al menú</a>
	</div>
</body>
</html>
```

`seleccionalumno.jsp`

```html
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8" import ="java.util.*,model.*" %>
<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" type="text/css" href="css/w3.css">
</head>
<body>
	<%List<Alumno> alumnos=(List<Alumno>)request.getAttribute("alumnos"); %>
	<div align="center" class="w3-padding">
	   	<h1>Buscar Cursos de un Alumno</h1>
	   	<form action="FrontController?option=doCursosAlumno" method="Post">
			Alumno: <select name="usuario">
				<%for(Alumno alumno:alumnos){ %>
					<option value="<%=alumno.getUsuario() %>">
						<%=alumno.getNombre() %>
					</option>
				<%} %>
			</select>
		<br/><br/>
		<input type="submit" value="Buscar Cursos"/>	
		</form>
	   <br/><br/>
	</div>
	<br><br>
	<div align="right" class="w3-padding">
		<a href="FrontController?option=toMenu" class="w3-button w3-dark-grey">Volver al menú</a>
	</div>
</body>
</html>
```

`alumnocurso.jsp`

```html
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8" import ="java.util.*,model.*" %>
<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" type="text/css" href="css/w3.css">
</head>
<body>
	<div align="center" class="w3-padding">
	   <h1>Alumnos</h1>
	   <%List<Alumno> alumnos=(List<Alumno>)request.getAttribute("alumnoscurso"); %>
	   <table border="1">
		   <tr><th>Nombre</th><th>Usuario</th></tr>
		   <%for(Alumno alumno:alumnos){ %>
			  <tr>
			     <td><%=alumno.getNombre() %></td><td><%=alumno.getUsuario() %></td>
			  </tr>
		   <%} %>
	   </table>
	   <br/><br/>
	</div>
	<br><br>
	<div align="right" class="w3-padding">
		<a href="FrontController?option=toMenu" class="w3-button w3-dark-grey">Volver al menú</a>
	</div>
</body>
</html>
```

`nota.html`

```html
<!DOCTYPE html>
<html>
<head>
<meta charset="ISO-8859-1">
<title>Menú</title>
<link rel="stylesheet" type="text/css" href="css/w3.css">
</head>
<body>
   <div align="center">
      <h1 class="w3-jumbo">Buscar Alumnos con Nota Mínima</h1>
      <form action="FrontController?option=doAlumnosNota" method="post">
		 Introduce nota mínima:<input type="text" name="nota"/><br/><br/>
		 <input type="submit" value="Mostrar Alumnos"/>
	  </form>
   </div>
</body>
</html>
```

`alumnosnota.jsp`

```html
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8" import ="java.util.*,model.*" %>
<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" type="text/css" href="css/w3.css">
</head>
<body>
	<div align="center" class="w3-padding">
	   <h1>Alumnos</h1>
	   <%List<Alumno> alumnos=(List<Alumno>)request.getAttribute("alumnosnota"); %>
	   <table border="1">
		   <tr><th>Nombre</th><th>Usuario</th></tr>
		   <%for(Alumno alumno:alumnos){ %>

```

`alumnoRepetido.jsp`

```html
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8"%>
<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" type="text/css" href="css/w3.css">
</head>
<body>
	<div align="center" class="w3-padding">
	   <h1>Usuario ya existente.</h1>
	</div>
	<br><br>
	<div align="right" class="w3-padding">
		<a href="FrontController?option=toMenu" class="w3-button w3-dark-grey">Volver al menú</a>
	</div>
</
```

`altaCurso.html`

```html
<html>
<head>
<meta charset="ISO-8859-1">
<title>Nuevo Curso</title>
<link rel="stylesheet" type="text/css" href="css/w3.css">
</head>
<body>
    <div class="w3-padding">
    	<h1>Nuevo Curso</h1>
		<fieldset>
			<legend>Datos del Curso</legend>
			<form action="FrontController?option=doAltaCurso" method="post">
				<label for="fnombre">Nombre</label><br>
				<input type="text" name="nombre" required="required"><br>
				<label for="fduracion">Duración</label><br>
				<input type="number" name="duracion" required="required"><br>
				<label for="ffecha">Fecha</label><br>
				<input type="date" name="fechaInicio" required="required"><br><br>
				<input type="submit" value="Guardar">
				<input type="reset">
			</form>
		</fieldset>
	</div>
	<div align="right" class="w3-padding">
		<a href="FrontController?option=toMenu" class="w3-button w3-dark-grey">Volver al menú</a>
	</div>
</body>
</html>
```

`seleccioncursos.jsp`

```html
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8" import ="java.util.*,model.*" %>
<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" type="text/css" href="css/w3.css">
</head>
<body>
	<%List<Alumno> alumnos=(List<Alumno>)request.getAttribute("alumnos"); %>
	<div align="center" class="w3-padding">
	   	<h1>Buscar Alumnos Matrículados en un Curso</h1>
	   	<form action="FrontController?option=doAlumnosCurso" method="Post">
		<%List<Curso> cursos=(List<Curso>)request.getAttribute("cursos"); %>
		Curso: <select name="idCurso">
			
			<%for(Curso curso:cursos){ %>
				<option value="<%=curso.getIdCurso() %>">
					<%=curso.getNombre() %>
				</option>
			<%} %>
			</select>
		<br/><br/>
		<input type="submit" value="Buscar Alumnos"/>	
		</form>
	   <br/><br/>
	</div>
	<br><br>
	<div align="right" class="w3-padding">
		<a href="FrontController?option=toMenu" class="w3-button w3-dark-grey">Volver al menú</a>
	</div>
</body>
</html>
```

`cursosalumno.jsp`

```html
<%@ page language="java" contentType="text/html; charset=UTF-8"
    pageEncoding="UTF-8" import ="java.util.*,model.*" %>
<!DOCTYPE html>
<html>
<head>
<link rel="stylesheet" type="text/css" href="css/w3.css">
</head>
<body>
	<div align="center" class="w3-padding">
	   <h1>Cursos</h1>
	   <%List<Curso> cursos=(List<Curso>)request.getAttribute("cursosalumno"); %>
		<table border="1">
			<tr><th>Curso</th><th>Duración</th></tr>
			<%for(Curso curso:cursos){ %>
				<tr>
					<td><%=curso.getNombre() %></td><td><%=curso.getDuracion() %></td>
				</tr>
			<%} %>
		</table>
	   <br/><br/>
	</div>
	<br><br>
	<div align="right" class="w3-padding">
		<a href="FrontController?option=toMenu" class="w3-button w3-dark-grey">Volver al menú</a>
	</div>
</body>
</html
```

### Probar la Aplicación

La aplicación funciona correctamente pero podría mejorarse para que las busquedas indiquen en los resultados el filtro usado.

![23-19-ej](images/23-19-ej.png)
![23-20-ej](images/23-20-ej.png)
![23-21-ej](images/23-21-ej.png)
![23-22-ej](images/23-22-ej.png)
![23-23-ej](images/23-23-ej.png)
![23-24-ej](images/23-24-ej.png)
![23-25-ej](images/23-25-ej.png)
![23-26-ej](images/23-26-ej.png)
![23-27-ej](images/23-27-ej.png)
![23-28-ej](images/23-28-ej.png)
![23-29-ej](images/23-29-ej.png)
![23-30-ej](images/23-30-ej.png)
![23-31-ej](images/23-31-ej.png)

### Otros Querys que podemos usar con JPA

Podemos acceder a solo algunos atributos de la Entidad, pero hay que tener cuidado para recuperar los datos que regresa la sentencia JPQL, tenemos que castearla según lo devuelto.

Tmbién podemos ejecutar sentencias SQL directamente en la Capa de Persistencia.

![23-32-ej](images/23-32-ej.png)
