# 20210111 Lunes

## :computer: `10_cliente_app_libreria`

Vamos a crear un Cliente para la aplicación `08_crud_libros` con las siguientes características

![20200111-01](images/20200111-01.png)
![20200111-02](images/20200111-02.png)
![20200111-03](images/20200111-03.png)
![20200111-04](images/20200111-04.png)
![20200111-05](images/20200111-05.png)
![20200111-06](images/20200111-06.png)

### Creación del Modelo

`Libro`

```java
package model;

public class Libro {
	
   private String titulo;
   private int isbn;
   private String tematica;
	
   public Libro() {
      super();
   }

   public Libro(String titulo, int isbn, String tematica) {
      super();
      this.titulo = titulo;
      this.isbn = isbn;
      this.tematica = tematica;
   }

   public String getTitulo() {
      return titulo;
   }

   public void setTitulo(String titulo) {
      this.titulo = titulo;
   }

   public int getIsbn() {
      return isbn;
   }

   public void setIsbn(int isbn) {
      this.isbn = isbn;
   }

   public String getTematica() {
      return tematica;
   }

   public void setTematica(String tematica) {
      this.tematica = tematica;
   }

}
```

### Creación del Servicio

`LibreriaService`

```java
package service;

import java.util.List;

import model.Libro;

public interface LibreriaService {
   List<Libro> todosLibros();
   List<Libro> librosPorTematica(String tematica);
   Libro libroPorIsbn(int isbn);
   void nuevoLibro(Libro libro);
   void actualizarLibro(Libro libro);
   void eliminarLibro(int isbn);
}
```

`LibreriaServiceImpl`

```java
package service;

import java.util.Arrays;
import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpHeaders;
import org.springframework.http.ResponseEntity;
import org.springframework.stereotype.Service;
import org.springframework.web.client.HttpClientErrorException;
import org.springframework.web.client.RestTemplate;

import model.Libro;

@Service
public class LibreriaServiceImpl implements LibreriaService {

   private String url="http://localhost:8080/08_crud_libros/";
   @Autowired
   RestTemplate template;
	
   @Override
   public List<Libro> todosLibros() {
      Libro[] resp=template.getForObject(url+"libros/", Libro[].class);
      return Arrays.asList(resp);
   }

   @Override
   public List<Libro> librosPorTematica(String tematica) {
      Libro[] resp=template.getForObject(url+"libros/{tema}", Libro[].class, tematica);
      return Arrays.asList(resp);
   }

   @Override
   public Libro libroPorIsbn(int isbn) {
      Libro resp=template.getForObject(url+"libro/{isbn}", Libro.class, isbn);
      return resp;
   }

   @Override
   public void nuevoLibro(Libro libro) {
      template.postForLocation(url+"libro", libro);
   }

   @Override
   public void actualizarLibro(Libro libro) {
      template.put(url+"libro", libro);
   }

   @Override
   public void eliminarLibro(int isbn) {
      template.delete(url+"libro/{isbn}", isbn);
   }

}
```
* Hemos inyectado `RestTemplate` que es necesario para recuperar datos a partir de un servicio.
* Hemos definido el URL del servicio que vamos a acceder.
* Este servicio lo hemos realizado utilizando los métodos más básicos, para recuperar información usamos `getForObject()`, para almacenar `postForLocation()`, para actualizar `put()` y para borrar `delete()`.

Existe la posibilidad de implementar el servicio con `getForEntity()` para poder tener acceso a los encabezados en la respuesta.

Por ejemplo el método de actualizar que tenemos así:

```
@Override
public void actualizarLibro(Libro libro) {
   template.put(url+"libro", libro);
}
```

Y lo podemos tener así:

```
@Override
public void actualizarLibro(Libro libro) {
   template.exchange(url+"libro", HttpMethod.PUT, new HttpEntity<Book>(book), Book[].class);
}
```

O incluso lo podemos tener así:

@Override
public void actualizarLibro(Libro libro) {
   ResponseEntity<Libro[]> libros = template.exchange(url+"libro", HttpMethod.PUT, new HttpEntity<Libro>(libro), Libro[].class);
}
```
  
Ya que nuestro servicio después de actualizar devuelve una lista de libros:

```
@PutMapping(value="libro",produces=MediaType.APPLICATION_JSON_VALUE,consumes=MediaType.APPLICATION_JSON_VALUE)
	public List<Libro> modificar(@RequestBody Libro libro){
		service.actualizarLibro(libro);
		return service.todosLibros();
	}
```

Y tal como lo pusimos podríamos recuperar esta información.

En el caso `libroPorIsbn` que lo tenemos así:

```
@Override
public Libro libroPorIsbn(int isbn) {
   Libro resp=template.getForObject(url+"libro/{isbn}", Libro.class, isbn);
   return resp;
}
```

Y que si vemos lo que hace el servicio en este caso tenemos:

```
@GetMapping(value="libro/{isbn}",produces=MediaType.APPLICATION_JSON_VALUE)
public ResponseEntity<Libro> buscarLibro(@PathVariable("isbn") int isbn) {
   Libro libro= service.libroPorIsbn(isbn);
      return libro == null ? new ResponseEntity<Libro>(null,null,HttpStatus.BAD_REQUEST)
                           : new ResponseEntity<Libro>(libro,null,HttpStatus.OK);
		
}
```

El servicio nos devuelve un `ResponseEntity`, usamos `ResponseEntity` cuando queremos modificar la cabecera o el código de respuesta, que es lo que hacemos en este caso, si es `null` retornamos `BAD_REQUEST` y si no retornamos `OK`.

Todos los servicios retornan una cabecera y un cuerpo independientemente de que retorne un `ResponseEntity<>` o un `List<>`, ya es cosa del Cliente si quiere recuperar todo o solamente el cuerpo, si el Cliente solo quiere recuperar el Cuerpo con un `getForObject()` basta, si el Cliente quiere recuperar solamente el cuerpo basta hacerlo como lo tenemos:

```
@Override
public Libro libroPorIsbn(int isbn) {
   Libro resp=template.getForObject(url+"libro/{isbn}", Libro.class, isbn);
   return resp;
}
```

Pero si desde el Cliente queremos recuperar la cabecera y el cuerpo lo ponemos así:

```
@Override
public Libro libroPorIsbn(int isbn) {
   //Recupera Cabecera y cuerpo
   ResponseEntity<Libro> resp1 = template.getForEntity(url+"libros/{isbn}", Libro.class, isbn);
   return resp1.getBody();
}
```

* El método `getForEntity()` se diferencia de `getForObject()` que devuelve el `ResponseEntity` completo por si queremos accceder a la cabecera o al cuerpo. A la cabecera por si me interesa para algo en especial.

Lo mismo pasa en el `libroPorTema` del servicio que cuando lo implementamos lo hicimos así.

```
@GetMapping(value="libros/{tema}",produces=MediaType.APPLICATION_JSON_VALUE)
public ResponseEntity<List<Libro>> librosPorTema(@PathVariable("tema") String tema){
   List<Libro> libros= service.librosPorTematica(tema);
   HttpHeaders headers=new HttpHeaders();
   headers.add("totalLibros", libros.size()+"");
   return new ResponseEntity<List<Libro>>(libros,headers,HttpStatus.OK);
		
}
```
* Nos devuelve un `ResponseEntity` con una lista de libros y en la cabecera decidimos retornar el `totalLibros`. Pero desde el Cliente yo decido si uso solo `getForObject()` solo para recuperar el cuerpo o `getForEntity()` para recuperar cabeceras y cuerpo. para este segundo este caso tendríamos en el cliente:

```
@Override
public List<Libro> librosPorTematica(String tematica) {
   //Si nos interesa también la cabececera:
   ResponseEntity<Libro[]> respuesta = template.getForEntity(url+"libros/{tema}", Libro[].class, tematica);
   HttpHeaders encabezados=respuesta.getHeaders();
   System.out.println(encabezados.get("totalLibros"));
   return Arrays.asList(respuesta.getBody());
```

Son estos algunos de los ajustes que podríamos realizar en nuestro Servicio.

### Creación del Controlador

Una versión del Controlador podría ser la siguiente, ya que habría que ver cuales peticiones se harán AJAX y cuales no.

``
```
package controller;

import java.util.List;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.ModelAttribute;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;

import model.Libro;
import service.LibreriaService;

@Controller
public class ClienteLibreriaController {
	@Autowired
	LibreriaService service;
	
	@GetMapping(value="libros")
	public String todosLibros(Model model) {
		List<Libro> resultado=service.todosLibros();
		model.addAttribute("libros", resultado);
		return "libros";
	}
	
	@PostMapping(value="librosPorTematica")
	public String librosPorTema(@RequestParam("tema") String tema, Model model) {
		List<Libro> resultado=service.librosPorTematica(tema);
		model.addAttribute("resultado", resultado);
		return "libros_por_tema";
	}
	
	@PostMapping(value="librosPorIsbn")
	public String librosPorIsbn(@RequestParam("isbn") int isbn, Model model) {
		Libro resultado=service.libroPorIsbn(isbn);
		model.addAttribute("libro", resultado);
		return "buscar_libro_por_isbn";
	}
	
	@PostMapping(value="nuevoLibro")
	public String nuevoLibro(@ModelAttribute("nuevoLibro") Libro nuevoLibro, Model model) {
		
		service.nuevoLibro(nuevoLibro); 
		
		return "menu";
	}
	
	@PostMapping(value="actualizarLibro")
	public String actualizarLibro(@ModelAttribute("nuevoLibro") Libro libroModificado, Model model) {
		service.actualizarLibro(libroModificado); 
		return "menu";
	}
	
	@PostMapping(value="eliminarLibro")
	public String eliminarLibro(@RequestParam("isbn") int isbn, Model model) {
		service.eliminarLibro(isbn); 
		return "menu";
	}
	
	@GetMapping(value="irNuevoLibro")
	public String irNuevoLibro() {
		
		return "nuevo_libro";
	}
	
	@GetMapping(value="irBuscarPorIsbn")
	public String irBuscarPorIsbn() {
		
		return "buscar_libro_por_isbn";
	}

}
```


``
```
```

``
```
```
