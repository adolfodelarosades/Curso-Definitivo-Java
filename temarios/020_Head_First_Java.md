# Head First Java, 3.ª edición

By Kathy Sierra, Bert Bates, Trisha Gee

<img width="383" alt="image" src="https://github.com/adolfodelarosades/Java/assets/23094588/107057c5-7ac6-4124-a05c-77ec7ed9a1a4">

* **TIME TO COMPLETE**: 21h 49m
* **TOPICS**: Java
* **PUBLISHED BY**: O'Reilly Media, Inc.
* **PUBLICATION DATE**: May 2022
* **PRINT LENGTH**: 752 pages

### ¿Qué aprenderás de este libro?

*Head First Java* es una completa experiencia de aprendizaje en Java y programación orientada a objetos. Con este libro, aprenderá el lenguaje Java con un método único que va más allá de los manuales prácticos y lo ayudará a convertirse en un gran programador. A través de acertijos, misterios y entrevistas introspectivas con objetos famosos de Java, rápidamente se pondrá al día sobre los fundamentos de Java y temas avanzados que incluyen lambdas, streams, generics, threading, networking y la temida GUI de escritorio. Si tiene experiencia con otro lenguaje de programación, *Head First Java* involucrará a su cerebro con enfoques más modernos para la codificación: el Java más elegante, rápido y fácil de leer, escribir y mantener de hoy.

### ¿Qué tiene de especial este libro?

Si ha leído un libro Head First, sabe qué esperar: un formato visualmente rico diseñado para la forma en que funciona su cerebro. Si no lo has hecho, estás de enhorabuena. Con *Head First Java*, aprenderá Java a través de una experiencia multisensorial que involucra su mente, en lugar de un enfoque de texto pesado que lo pone a dormir.

* Mayo 2003: Primera Edición
* Febrero 2005: Segunda Edición
* Mayo 2022: Tercera Edición

## Tabla de contenido (lo real)

### 0. Cómo usar este libro: Introducción

**Tu cerebro en Java**. Aquí estás tratando de aprender algo, mientras que aquí tu cerebro te está haciendo un favor al asegurarse de que el aprendizaje no se quede estancado. Tu cerebro está pensando: "Mejor deja espacio para cosas más importantes, como qué animales salvajes evitar y si hacer snowboard desnudo es una mala idea". Entonces, ¿cómo engañas a tu cerebro para que piense que tu vida depende de conocer Java?

1. "¿Para quién es este libro?"
2. “Sabemos lo que estás pensando”
3. “Metacognición: pensar sobre pensar”
4. "Esto es lo que hicimos NOSOTROS:"
5. “Esto es lo que TÚ puedes hacer para someter tu cerebro”
6. “Lo que necesitas para este libro:”
7. “Cosas de última hora que debes saber:”

### 1. Capítulo 1

**Java te lleva a nuevos lugares**. Desde su humilde lanzamiento al público como la (débil) versión 1.02, Java sedujo a los programadores con su sintaxis amigable, funciones orientadas a objetos, administración de memoria y, lo mejor de todo, la promesa de portabilidad. Nos sumergiremos rápidamente y escribiremos un código, lo compilaremos y lo ejecutaremos. Estamos hablando de sintaxis, bucles, bifurcaciones y lo que hace que Java sea tan genial. Buceo en.

1. “La forma en que funciona Java”
2. “Qué harás en Java”
3. “Una muy breve historia de Java”
4. “Estructura de código en Java”
5. "Escribir una clase con un **`main()`**"
6. “Pruebas booleanas simples”
7. “Ramificación condicional”
8. “Codificación de una aplicación comercial seria”
9. “Phrase-O-Matic”
10. "Ejercicio"
11. “Soluciones de ejercicio”

### 2. Capitulo 2

Me dijeron que habría objetos. En el Capítulo 1, colocamos todo nuestro código en el método **`main()`**. Eso no es exactamente orientado a objetos. Así que ahora tenemos que dejar atrás ese mundo procedimental y comenzar a crear algunos objetos propios. Veremos qué hace que el desarrollo orientado a objetos (OO) en Java sea tan divertido. Veremos la diferencia entre una clase y un objeto. Veremos cómo los objetos pueden mejorar tu vida.

1. “Guerra de sillas”
2. “Haciendo tu primer objeto”
3. “Hacer y probar objetos de películas”
4. "¡Rápido! ¡Fuera de **`main()`**!
5. "Ejecutar el juego de adivinanzas"
6. "Ejercicio"
7. “Soluciones de ejercicio”

### 3. Capítulo 3

**Las variables vienen en dos sabores: primitivas y de referencia**. Tiene que haber más en la vida que integers, Strings y arrays. ¿Qué sucede si tiene un objeto PetOwner con una variable de instancia Dog? ¿O un coche con motor? En este capítulo, desenvolveremos los misterios de los tipos de Java y veremos qué puede declarar como variable, qué puede poner en una variable y qué puede hacer con una variable. Y finalmente veremos cómo es realmente la vida en el garbage-collectible heap.

1. “Declarar una variable”

“Me gustaría un moka doble, no, que sea un int.”

“¡Aléjate de esa palabra clave!”

“Controlando tu objeto Perro”

“Una referencia de objeto es solo otro valor de variable”

“La vida en el montón de basura recolectada”

“Un arreglo es como una bandeja de tazas”

“Un ejemplo de perro”

"Ejercicio"

“Soluciones de ejercicio”

Capítulo 4

El estado afecta el comportamiento, el comportamiento afecta el estado. Sabemos que los objetos tienen estado y comportamiento , representados por variables de instancia y métodos . Ahora veremos cómo se relacionan el estado y el comportamiento . El comportamiento de un objeto utiliza el estado único de un objeto. En otras palabras, los métodos usan valores de variables de instancia. Como, "si el perro pesa menos de 14 libras, haz un sonido de yippy, de lo contrario..." ¡ Vamos a cambiar de estado!

“Recuerda: una clase describe lo que un objeto sabe y lo que hace un objeto ”

“El tamaño afecta a la corteza”

“Puedes enviar cosas a un método”

“Puedes recuperar cosas con un método”

“Puedes enviar más de una cosa a un método”

“Cosas interesantes que puede hacer con parámetros y tipos de devolución”

“Encapsulación”

"¿Cómo se comportan los objetos en una matriz?"

“Declaración e inicialización de variables de instancia”

“Comparación de variables (primitivas o referencias)”

"Ejercicio"

“Soluciones de ejercicio”

Capítulo 5

Pongamos algo de fuerza en nuestros métodos. Experimentaste con variables, jugaste con algunos objetos y escribiste un pequeño código. Pero necesitas más herramientas. Como operadores. Y bucles. Puede ser útil para generar números aleatorios. Y convertir un String en un int , sí, eso sería genial. ¿Y por qué no lo aprendemos todo construyendo algo real, para ver cómo es escribir (y probar) un programa desde cero? Tal vez un juego , como Sink a Startup (similar a Battleship).

“Construyamos un juego estilo Battleship: “Sink a Startup””

“Desarrollo de una clase”

“Escribiendo las implementaciones del método”

“Escribir código de prueba para la clase SimpleStartup”

“El método checkYourself()”

“Código de preparación para la clase SimpleStartupGame Todo sucede en main()”

“El método main() del juego”

"Vamos a jugar"

“Más sobre bucles for ”

“El bucle for mejorado ”

“Lanzamiento de primitivas”

"Ejercicio"

“Soluciones de ejercicio”

Capítulo 6

Java se envía con cientos de clases preconstruidas. No tiene que reinventar la rueda si sabe cómo encontrar lo que necesita en la biblioteca de Java, comúnmente conocida como la API de Java. Tienes mejores cosas que hacer. Si va a escribir código, también puede escribir solo las partes que son personalizadas para su aplicación. La biblioteca central de Java es una pila gigante de clases esperando a que las uses como bloques de construcción.

“En nuestro último capítulo, los dejamos con el suspenso: un error”

“Despierta y huele la biblioteca”

“Algunas cosas que puedes hacer con ArrayList ”

"Comparando ArrayList con una matriz normal"

“Construyamos el juego REAL: “Sink a Startup””

“Código de preparación para la clase StartupBust real ”

“La versión final de la clase Startup”

"Expresiones booleanas súper poderosas"

“Uso de la biblioteca (la API de Java)”

"Ejercicio"

“Soluciones de ejercicio”

Capítulo 7

Planifique sus programas pensando en el futuro. ¿ Qué pasaría si pudieras escribir código que alguien más pudiera extender fácilmente? ¿Qué pasaría si pudiera escribir un código que fuera flexible, para esos molestos cambios de especificación de última hora? Cuando ingrese al Plan de polimorfismo, aprenderá los 5 pasos para un mejor diseño de clase, los 3 trucos para el polimorfismo, las 8 formas de hacer código flexible y, si actúa ahora, una lección adicional sobre los 4 consejos para explotar la herencia. .

“La guerra de las sillas revisada...”

“Entender la herencia”

“Diseñemos el árbol de herencia para un programa de simulación Animal”

“Buscando más oportunidades de herencia”

“Uso de IS-A y HAS-A”

“¿Cómo sabes si tienes tu herencia correcta?”

“Al diseñar con herencia, ¿estás usando o abusando?”

“Cumplimiento del contrato: reglas de anulación”

“Sobrecargando un método”

"Ejercicio"

“Soluciones de ejercicio”

Capítulo 8

La herencia es sólo el comienzo. Para explotar el polimorfismo, necesitamos interfaces. Necesitamos ir más allá de la simple herencia a la flexibilidad que solo puede obtener mediante el diseño y la codificación de las interfaces. ¿Qué es una interfaz? Una clase 100% abstracta. ¿Qué es una clase abstracta? Una clase que no puede ser instanciada. ¿Para qué sirve eso? Lee el capitulo...

"¿Nos olvidamos de algo cuando diseñamos esto?"

“El compilador no te permitirá instanciar una clase abstracta”

“Abstracto vs Concreto”

“DEBES implementar todos los métodos abstractos”

“Polimorfismo en acción”

“¿Qué pasa con los no animales? ¿Por qué no hacer una clase lo suficientemente genérica para tomar cualquier cosa? ”

“Cuando un perro no actúa como un perro”

“Exploremos algunas opciones de diseño para reutilizar algunas de nuestras clases existentes en un programa de PetShop”

“Creación e implementación de la interfaz Pet”

“Invocar la versión de la superclase de un método”

"Ejercicio"

“Soluciones de ejercicio”

Capítulo 9

Los objetos nacen y los objetos mueren. Estás a cargo. Tú decides cuándo y cómo construirlos . Tú decides cuándo abandonarlos . El recolector de basura (gc) recupera la memoria. Veremos cómo se crean los objetos, dónde viven y cómo mantenerlos o abandonarlos de manera eficiente. Eso significa que hablaremos sobre el montón, la pila, el alcance, los constructores, los superconstructores, las referencias nulas y la elegibilidad de gc.

“La pila y el montón: donde viven las cosas”

“Los métodos están apilados”

“¿Qué pasa con las variables locales que son objetos? ”

“El milagro de la creación de objetos”

“Construye un Pato”

“¿No hace el compilador siempre un constructor sin argumentos para ti? ¡No! ”

“Nanorevisión: cuatro cosas para recordar sobre los constructores”

“El papel de los constructores de superclases en la vida de un objeto”

“¿Puede el niño existir antes que los padres?”

"¿Qué pasa con las variables de referencia?"

Cifra 

"Ejercicio"

“Soluciones de ejercicio”

Capítulo 10

Haz las matematicas. La API de Java tiene métodos para valor absoluto, redondeo, mínimo/máximo, etc. Pero, ¿qué pasa con el formateo? Es posible que desee que los números se impriman exactamente con dos puntos decimales o con comas en todos los lugares correctos. Y es posible que también desee imprimir y manipular fechas. ¿Y qué hay de analizar una cadena en un número? ¿O convertir un número en una cadena? Comenzaremos aprendiendo lo que significa que una variable o método sea estático.

“Métodos MATEMÁTICOS: lo más cerca que jamás llegará a un método global ”

“La diferencia entre métodos regulares (no estáticos) y estáticos”

“Inicializar una variable estática”

“Métodos matemáticos”

“Envolviendo una primitiva”

“El autoboxing funciona en casi todas partes”

“Y ahora al revés...convirtiendo un número primitivo en una Cadena”

“Formato de números”

“El especificador de formato”

"Ejercicio"

“Solución de ejercicios”

Capítulo 11

Ordenar es muy fácil en Java. Tiene todas las herramientas para recopilar y manipular sus datos sin tener que escribir sus propios algoritmos de clasificación. Java Collections Framework tiene una estructura de datos que debería funcionar para prácticamente cualquier cosa que necesite hacer. ¿Quiere mantener una lista a la que pueda seguir agregando fácilmente? ¿Quieres encontrar algo por nombre? ¿Quieres crear una lista que elimine automáticamente todos los duplicados? ¿Ordenar a tus compañeros de trabajo por el número de veces que te han apuñalado por la espalda?

“Exploración de la API, la lista y las colecciones de java.util”

“Genéricos significa más seguridad tipográfica”

“Revisando el método sort()”

“La clase Song nueva, mejorada y comparable”

“Clasificación usando solo Comparadores”

“Actualización del código de Jukebox con lambdas”

"Usando un HashSet en lugar de ArrayList"

“Lo que DEBE saber sobre TreeSet...”

“Ya vimos Listas y Conjuntos, ahora usaremos un Mapa”

“Finalmente, de vuelta a los genéricos”

“Solución de ejercicios”

Capítulo 12

¿Qué pasaría si... no necesitaras decirle a la computadora CÓMO hacer algo? En este capítulo veremos la API de Streams. Verá lo útiles que pueden ser las expresiones lambda cuando utilice secuencias y aprenderá a utilizar la API de secuencias para consultar y transformar los datos de una colección.

“Dile a la computadora QUÉ quieres”

“Cuando los bucles for van mal”

“Presentamos la API de secuencias”

"Obtener un resultado de un Stream"

“Directrices para trabajar con flujos”

“Hola Lambda, mi (no tan) vieja amiga”

“Detección de interfaces funcionales”

“Desafío de Lou #1: Encuentra todas las canciones de “rock””

“Desafío de Lou #2: Enumerar todos los géneros”

"Ejercicio"

“Soluciones de ejercicio”

Capítulo 13

Estas cosas pasan. El archivo no está allí. El servidor está caído. Por muy buen programador que seas, no puedes controlarlo todo. Cuando escribe un método arriesgado, necesita un código para manejar las cosas malas que pueden suceder. Pero, ¿cómo saber cuándo un método es riesgoso? ¿Dónde pones el código para manejar la situación excepcional ? En este capítulo, vamos a construir un reproductor de música MIDI que use la arriesgada API de JavaSound, así que será mejor que lo averigüemos.

“Hagamos una máquina de música”

“Primero necesitamos un Secuenciador”

“Una excepción es un objeto... de tipo Excepción”

“Control de flujo en bloques try/catch”

"¿Mencionamos que un método puede lanzar más de una excepción?"

"Múltiples bloques de captura deben ordenarse de menor a mayor"

“Agacharse (declarando) solo retrasa lo inevitable”

“Cocina de código”

“Versión 1: Tu primera aplicación de reproductor de sonido”

"Versión 2: uso de argumentos de línea de comandos para experimentar con sonidos"

"Ejercicio"

“Solución de ejercicios”

capitulo 14

Acéptalo, necesitas hacer GUI. Incluso si cree que por el resto de su vida escribirá solo código del lado del servidor, tarde o temprano necesitará escribir herramientas y querrá una interfaz gráfica. Dedicaremos dos capítulos a las GUI y aprenderemos más características del lenguaje, incluido el manejo de eventos y las clases internas. Pondremos un botón en la pantalla, pintaremos en la pantalla, mostraremos una imagen JPEG e incluso haremos algo de animación.

“Todo comienza con una ventana”

"Obtener un evento de usuario"

“Oyentes, fuentes y eventos”

"Haz tu propio widget de dibujo"

“Cosas divertidas para hacer en paintComponent()”

“Diseños GUI: poner más de un widget en un marco”

“¡La clase interna al rescate!”

“¡Lambdas al rescate! (de nuevo)"

“Usando una clase interna para la animación”

“Una forma más fácil de hacer mensajes/eventos”

"Ejercicio"

“Soluciones de ejercicio”

Capítulo 15

Columpiarse es fácil. A menos que realmente te importe dónde va todo. El código swing parece fácil, pero luego compílelo, ejecútelo, mírelo y piense: "Oye, se supone que eso no debe ir allí". Lo que facilita la codificación es lo que dificulta su control : el Administrador de diseño. Pero con un poco de trabajo, puede hacer que los administradores de diseño se sometan a su voluntad. En este capítulo, trabajaremos en nuestro Swing y aprenderemos más sobre los widgets.

“Componentes de columpio”

“Administradores de diseño”

“Los tres grandes administradores de diseño: borde, flujo y cuadro”

“Jugando con componentes Swing”

“Cocina de código”

“Haciendo el BeatBox”

"Ejercicio"

“Soluciones de ejercicio”

capitulo 16

Los objetos se pueden aplanar e inflar. Los objetos tienen estado y comportamiento. El comportamiento vive en la clase, pero el estado vive dentro de cada objeto individual. Si su programa necesita guardar el estado, puede hacerlo de la manera difícil , interrogando a cada objeto, escribiendo minuciosamente el valor de cada variable de instancia. O bien, puede hacerlo de la manera fácil OO : simplemente liofiliza el objeto (lo serializa) y lo reconstituye (deserializa) para recuperarlo.

“Escribir un objeto serializado en un archivo”

“Si quieres que tu clase sea serializable, implementa Serializable ”

“Deserialización: restauración de un objeto”

"ID de versión: un gran problema de serialización"

“Escribir una cadena en un archivo de texto”

“Lectura de un archivo de texto”

"Quiz Card Player (esquema del código)"

"Ruta, rutas y archivos (jugando con directorios)"

“Finalmente, una mirada más cercana a finally”

“Guardar un patrón de BeatBox”

"Ejercicio"

“Soluciones de ejercicio”

capitulo 17

Conéctate con el mundo exterior. Es fácil. Todos los detalles de red de bajo nivel están a cargo de las clases en la biblioteca java.net. Una de las mejores características de Java es que el envío y la recepción de datos a través de una red es realmente solo E/S con un flujo de conexión ligeramente diferente al final de la cadena. En este capítulo crearemos sockets de cliente. Haremos sockets de servidor. Haremos clientes y servidores. Antes de terminar el capítulo, tendrá un cliente de chat multiproceso completamente funcional. ¿ Acabamos de decir multihilo?

“Conectar, enviar y recibir”

“El cliente de consejos diarios”

"Escribir una aplicación de servidor simple"

"Java tiene múltiples subprocesos pero solo una clase de subproceso"

“Los tres estados de un hilo nuevo”

“Poniendo un hilo a dormir”

“Haciendo y comenzando dos hilos (¡o más!)”

“Hora de cierre en el grupo de hilos”

“Nuevo y mejorado SimpleChatClient”

"Ejercicio"

“Soluciones de ejercicio”

capitulo 18

Hacer dos o más cosas a la vez es difícil. Escribir código multiproceso es fácil. Escribir código multiproceso que funcione de la manera esperada puede ser mucho más difícil. En este capítulo final, le mostraremos algunas de las cosas que pueden salir mal cuando dos o más subprocesos funcionan al mismo tiempo. Aprenderá acerca de algunas de las herramientas en java.util.concurrent que pueden ayudarlo a escribir código multiproceso que funcione correctamente. Aprenderá a crear objetos inmutables (objetos que no cambian) que son seguros para que los usen varios subprocesos. Al final del capítulo, tendrá muchas herramientas diferentes en su conjunto de herramientas para trabajar con concurrencia.

“El problema de Ryan y Monica, en código”

“Usando el candado de un objeto”

“El temido problema de “Actualización Perdida””

“Haz que el método increment() sea atómico. ¡Sincronízalo!”

“Deadlock, un lado mortal de la sincronización”

“Comparar e intercambiar con variables atómicas”

“Usando objetos inmutables”

“Más problemas con los datos compartidos”

"Usar una estructura de datos segura para subprocesos"

"Ejercicio"

“Solución de ejercicios”

Apéndice A

Código Final Cocina. Todo el código para el beat box de chat cliente-servidor completo. Tu oportunidad de ser una estrella de rock.

“Programa cliente final de BeatBox”

“Programa de servidor BeatBox final”

apéndice B

Los diez temas principales que no llegaron al resto del libro. Todavía no podemos enviarte al mundo. Tenemos algunas cosas más para ti, pero este es el final del libro. Y esta vez lo decimos en serio.

“N.º 11 JShell (reemplazo de Java)”

“Paquetes #10”

“#9 Inmutabilidad en cadenas y envoltorios”

“#8 Niveles de acceso y modificadores de acceso (quién ve qué)”

“#7 Varargs”

“#6 Anotaciones”

“#5 Lambdas y Mapas”

“#4 corrientes paralelas”

“#3 Enumeraciones (también llamadas tipos enumerados o enumeraciones)”

“#2 Inferencia de tipo de variable local (var)”

“Registros #1”

