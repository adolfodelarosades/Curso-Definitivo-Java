# Parte 1. Fundamentos

Esta primera parte del libro proporciona los fundamentos para ayudarlo a comenzar con las nuevas ideas de Java introducidas en Java 8. Al final de esta primera parte, tendrá una comprensión completa de lo que son las expresiones lambda y estará capaz de escribir código que sea lo suficientemente conciso y flexible para adaptarse fácilmente a los requisitos cambiantes.

En el capítulo 1, resumimos los cambios principales en Java (expresiones lambda, referencias de métodos, flujos y métodos predeterminados) y preparamos el escenario para el libro.

En el capítulo 2, aprenderá sobre la parametrización del comportamiento, un patrón de desarrollo de software en el que Java 8 se basa en gran medida y es la motivación para las expresiones lambda.

El Capítulo 3 ofrece una explicación completa, con ejemplos de código y cuestionarios en cada paso, de los conceptos de expresiones lambda y referencias a métodos.

# 01. Java 8, 9, 10 y 11: ¿qué está pasando?

Este capítulo cubre

* Por qué Java sigue cambiando
* Cambio de experiencia informática
* Presiones para que Java evolucione
* Presentamos nuevas funciones principales de Java 8 y 9

Desde el lanzamiento de Java Development Kit (JDK 1.0) en 1996, Java ha ganado un gran número de seguidores de estudiantes, gerentes de proyectos y programadores que son usuarios activos. Es un lenguaje expresivo y se sigue utilizando para proyectos tanto grandes como pequeños. Su evolución (mediante la incorporación de nuevas funciones) de Java 1.1 (1997) a Java 7 (2011) ha sido bien gestionada. Java 8 se lanzó en marzo de 2014, Java 9 en septiembre de 2017, Java 10 en marzo de 2018 y Java 11 previsto para septiembre de 2018. La pregunta es esta: ¿Por qué deberían preocuparse por estos cambios?

## 1.1. Entonces, ¿cuál es la gran historia?

Argumentamos que los cambios en Java 8 fueron, en muchos sentidos, más profundos que cualquier otro cambio en Java en su historia (Java 9 agrega cambios de productividad importantes, pero menos profundos, como verá más adelante en este capítulo, mientras que Java 10 hace ajustes mucho más pequeños a la inferencia de tipos). La buena noticia es que los cambios le permiten escribir programas con mayor facilidad. Por ejemplo, en lugar de escribir un código detallado (para ordenar una lista de manzanas en el inventario según su peso) como

```java
Collections.sort(inventory, new Comparator<Apple>() {
    public int compare(Apple a1, Apple a2){
        return a1.getWeight().compareTo(a2.getWeight());
    }
});
```

en Java 8 puede escribir un código más conciso que se lea mucho más cerca de la declaración del problema, como el siguiente:

```java
inventory.sort(comparing(Apple::getWeight));
```

### 1 ¡El primer código Java 8 del libro!

Dice "ordenar inventario comparando el peso de la manzana". No se preocupe por este código por ahora. Este libro le explicará qué hace y cómo puede escribir un código similar.

También hay una influencia del hardware: las CPU básicas se han convertido en multinúcleo; el procesador de su computadora portátil o de escritorio probablemente contiene cuatro o más núcleos de CPU. Pero la gran mayoría de los programas Java existentes usan solo uno de estos núcleos y dejan los otros tres inactivos (o gastan una pequeña fracción de su poder de procesamiento ejecutando parte del sistema operativo o un antivirus).

Antes de Java 8, los expertos podrían decirle que debe usar subprocesos para usar estos núcleos. El problema es que trabajar con subprocesos es difícil y propenso a errores. Java ha seguido un camino evolutivo de intentar continuamente hacer que la concurrencia sea más fácil y menos propensa a errores. Java 1.0 tenía subprocesos y bloqueos e incluso un modelo de memoria, la mejor práctica en ese momento, pero estas primitivas demostraron ser demasiado difíciles de usar de manera confiable en equipos de proyectos no especializados. Java 5 agregó bloques de construcción de fuerza industrial como grupos de subprocesos y colecciones concurrentes. Java 7 agregó el marco de bifurcación/unión, lo que hace que el paralelismo sea más práctico pero aún difícil. Java 8 nos dio una forma nueva y más sencilla de pensar sobre el paralelismo. Pero aún debe seguir algunas reglas, que aprenderá en este libro.

Como verá más adelante en este libro, Java 9 agrega un método de estructuración adicional para la concurrencia: la programación reactiva. Aunque esto tiene un uso más especializado, estandariza un medio para explotar los kits de herramientas de flujos reactivos **RxJava** y **Akka** que se están volviendo populares para sistemas altamente concurrentes.

De los dos desiderata anteriores (código más conciso y uso más simple de procesadores multinúcleo) surge todo el edificio consistente capturado por Java 8. Comenzamos por darle una muestra rápida de estas ideas (con suerte lo suficiente como para intrigarlo, pero lo suficientemente breve como para resumirlas ):

* La API de Streams
* Técnicas para pasar código a métodos
* Métodos predeterminados en interfaces

Java 8 proporciona una nueva API (llamada Streams) que admite muchas operaciones paralelas para procesar datos y se parece a la forma en que podría pensar en los lenguajes de consulta de bases de datos: usted expresa lo que quiere de una manera de nivel superior y la implementación (aquí, la biblioteca Streams ) elige el mejor mecanismo de ejecución de bajo nivel. Como resultado, evita la necesidad de escribir código sincronizado, que no solo es muy propenso a errores, sino que también es más caro de lo que se imagina en las CPU multinúcleo. [1]

<hr>
[1] Las CPU multinúcleo tienen cachés separados (memoria rápida) conectados a cada núcleo del procesador. El bloqueo requiere que estos estén sincronizados, lo que requiere una comunicación entre núcleos de protocolo de coherencia de caché relativamente lenta.
Desde un punto de vista ligeramente revisionista, la adición de Streams en Java 8 puede verse como una causa directa de las otras dos adiciones a Java 8: técnicas concisas para pasar código a métodos (referencias de métodos, lambdas) y métodos predeterminados en interfaces.
<hr>

Pero pensar en pasar código a métodos como una mera consecuencia de Streams minimiza su rango de usos dentro de Java 8. Le brinda una nueva forma concisa de expresar la parametrización del comportamiento. Suponga que desea escribir dos métodos que difieren solo en unas pocas líneas de código. Ahora puede simplemente pasar el código de las partes que difieren como argumento (esta técnica de programación es más corta, más clara y menos propensa a errores que la tendencia común de usar copiar y pegar). Los expertos notarán aquí que la parametrización del comportamiento podría, antes de Java 8, codificarse usando clases anónimas, pero dejaremos que el ejemplo al principio de este capítulo, que muestra una mayor concisión del código con Java 8, hable por sí mismo en términos de claridad. .

La característica de Java 8 de pasar código a métodos (y poder devolverlo e incorporarlo en estructuras de datos) también proporciona acceso a una variedad de técnicas adicionales que comúnmente se conocen como programación de estilo funcional. En pocas palabras, dicho código, llamado funciones en la comunidad de programación funcional, puede transmitirse y combinarse de manera que produzca potentes modismos de programación que verá en Java a lo largo de este libro.

El meollo de este capítulo comienza con una discusión de alto nivel sobre por qué evolucionan los lenguajes, continúa con secciones sobre las características principales de Java 8 y luego presenta las ideas de programación de estilo funcional que las nuevas características simplifican el uso y que las nuevas arquitecturas de computadora favorecen. En esencia, la sección 1.2 analiza el proceso de evolución y los conceptos, de los que antes carecía Java, para explotar el paralelismo multinúcleo de una manera fácil. La sección 1.3 explica por qué pasar código a métodos en Java 8 es un nuevo lenguaje de programación tan poderoso, y la sección 1.4 hace lo mismo para Streams, la nueva forma de Java 8 de representar datos secuenciados e indicar si estos pueden procesarse en paralelo. La Sección 1.5 explica cómo la nueva característica de Java 8 de métodos predeterminados permite que las interfaces y sus bibliotecas evolucionen con menos complicaciones y menos recompilación; También explica la adición de módulos a Java 9, que permite que los componentes de grandes sistemas Java se especifiquen con más claridad que "solo un archivo JAR de paquetes". Finalmente, la sección 1.6 analiza las ideas de programación de estilo funcional en Java y otros lenguajes que comparten la JVM. En resumen, este capítulo introduce ideas que se elaboran sucesivamente en el resto del libro. ¡Disfruta el viaje!

## 1.2. ¿POR QUÉ JAVA AÚN ESTÁ CAMBIANDO?

Con la década de 1960 llegó la búsqueda del lenguaje de programación perfecto. Peter Landin, un famoso científico informático de su época, señaló en 1966 en un artículo histórico [2] que ya había 700 lenguajes de programación y especuló sobre cómo serían los próximos 700, incluidos argumentos para una programación de estilo funcional similar a ese en Java 8.

<hr>
[2] P. J. Landin, "The Next 700 Programming Languages", CACM 9 (3): 157–65, marzo de 1966.
<hr>

Muchos miles de lenguajes de programación más tarde, los académicos han llegado a la conclusión de que los lenguajes de programación se comportan como ecosistemas: aparecen nuevos lenguajes y los lenguajes antiguos son suplantados a menos que evolucionen. Todos esperamos un lenguaje universal perfecto, pero en realidad ciertos lenguajes se adaptan mejor a determinados nichos. Por ejemplo, C y C ++ siguen siendo populares para la construcción de sistemas operativos y varios otros sistemas integrados debido a su pequeña huella de tiempo de ejecución y a pesar de su falta de seguridad en la programación. Esta falta de seguridad puede llevar a que los programas se bloqueen de manera impredecible y expongan agujeros de seguridad para virus y similares; de hecho, los lenguajes con seguridad de tipos como Java y C# han suplantado a C y C++ en varias aplicaciones cuando la huella de tiempo de ejecución adicional es aceptable.

La ocupación previa de un nicho tiende a desanimar a los competidores. Cambiar a un nuevo idioma y cadena de herramientas suele ser demasiado doloroso para una sola función, pero los recién llegados eventualmente desplazarán los idiomas existentes, a menos que evolucionen lo suficientemente rápido como para mantenerse al día. (Los lectores mayores a menudo pueden citar una variedad de esos lenguajes en los que han codificado previamente pero cuya popularidad ha disminuido desde entonces: Ada, Algol, COBOL, Pascal, Delphi y SNOBOL, por nombrar solo algunos).

Eres un programador de Java, y Java ha logrado colonizar (y desplazar lenguajes de la competencia) un gran nicho de ecosistema de tareas de programación durante casi 20 años. Examinemos algunas razones para eso.

### 1.2.1. El lugar de Java en el ecosistema de lenguajes de programación

Java empezó bien. Desde el principio, fue un lenguaje orientado a objetos bien diseñado con muchas bibliotecas útiles. También admitió la concurrencia a pequeña escala desde el primer día con su soporte integrado para subprocesos y bloqueos (y con su temprano reconocimiento profético, en forma de un modelo de memoria neutral de hardware, que los subprocesos concurrentes en procesadores multinúcleo pueden tener comportamientos inesperados además de los que ocurren en procesadores de un solo núcleo). Además, la decisión de compilar Java en código de bytes JVM (un código de máquina virtual que pronto todos los navegadores admitieron) significó que se convirtió en el idioma preferido para los programas de subprogramas de Internet (¿recuerda los subprogramas?). De hecho, existe el peligro de que Java Virtual Machine (JVM) y su código de bytes se consideren más importantes que el propio lenguaje Java y que, para ciertas aplicaciones, Java pueda ser reemplazado por uno de sus lenguajes competidores como Scala, Groovy, o Kotlin, que también se ejecuta en JVM. Varias actualizaciones recientes de la JVM (por ejemplo, el nuevo código de bytes dinámico invocado en JDK7) tienen como objetivo ayudar a que los lenguajes de la competencia se ejecuten sin problemas en la JVM y que interoperen con Java. Java también ha tenido éxito en colonizar varios aspectos de la computación integrada (desde tarjetas inteligentes, tostadoras y decodificadores hasta sistemas de frenado de automóviles).

#### ¿Cómo entró Java en un nicho de programación general?
<hr>
La orientación a objetos se puso de moda en la década de 1990 por dos razones: su disciplina de encapsulación resultó en menos problemas de ingeniería de software que los de C; y como modelo mental, capturó fácilmente el modelo de programación WIMP de Windows 95 y versiones posteriores. Esto se puede resumir de la siguiente manera: todo es un objeto; y un clic del mouse envía un mensaje de evento a un controlador (invoca el método de clic en un objeto Mouse). El modelo de Java de escritura única y ejecución en cualquier lugar y la capacidad de los primeros navegadores para ejecutar (de forma segura) los subprogramas de código Java le dieron un nicho en las universidades, cuyos graduados entonces poblaron la industria. Hubo una resistencia inicial al costo de ejecución adicional de Java sobre C/C++, pero las máquinas se hicieron más rápidas y el tiempo del programador se volvió cada vez más importante. C# de Microsoft validó aún más el modelo orientado a objetos de estilo Java.
<hr>

Pero el clima está cambiando para el ecosistema de lenguajes de programación; Los programadores se ocupan cada vez más de los llamados big data (conjuntos de datos de terabytes y más) y desean explotar computadoras multinúcleo o clústeres informáticos de manera eficaz para procesarlos. Y esto significa usar procesamiento paralelo, algo que Java no era compatible con anterioridad. Es posible que haya encontrado ideas de otros nichos de programación (por ejemplo, map-reduce de Google o la relativa facilidad de manipulación de datos con lenguajes de consulta de bases de datos como SQL) que lo ayudan a trabajar con grandes volúmenes de datos y CPU multinúcleo. La Figura 1.1 resume gráficamente el ecosistema del lenguaje: piense en el paisaje como el espacio de los problemas de programación y la vegetación dominante de un terreno en particular como el lenguaje favorito para ese programa. El cambio climático es la idea de que nueva hardware o nuevas influencias de programación (por ejemplo, "¿Por qué no puedo programar en un estilo similar a SQL?") significan que diferentes lenguajes se convierten en el lenguaje de elección para nuevos proyectos, al igual que el aumento de las temperaturas regionales significa que las uvas ahora prosperan en latitudes más altas. . Pero hay histéresis: muchos agricultores antiguos seguirán cultivando cultivos tradicionales. En resumen, están apareciendo nuevos idiomas y se están volviendo cada vez más populares porque se han adaptado rápidamente al cambio climático.

![01-01](images/01-01.png)

El principal beneficio de las adiciones de Java 8 para un programador es que brindan más herramientas y conceptos de programación para resolver problemas de programación nuevos o existentes más rápidamente o, lo que es más importante, de una manera más concisa y fácil de mantener. Aunque los conceptos son nuevos en Java, han demostrado su eficacia en lenguajes de investigación de nicho. En las siguientes secciones, destacaremos y desarrollaremos las ideas detrás de tres de estos conceptos de programación que han impulsado el desarrollo de las funciones de Java 8 para aprovechar el paralelismo y escribir código más conciso en general. Los presentaremos en un orden ligeramente diferente del resto del libro para habilitar una analogía basada en Unix y exponer las dependencias de "necesito esto por eso" en el nuevo paralelismo de Java 8 para multinúcleo.

#### Otro factor de cambio climático para Java
<hr>
Un factor del cambio climático implica cómo se diseñan los grandes sistemas. Hoy en día, es común que un sistema grande incorpore subsistemas de componentes grandes de otros lugares, y tal vez estos se construyan sobre otros componentes de otros proveedores. Peor aún, estos componentes y sus interfaces también tienden a evolucionar. Java 8 y Java 9 han abordado estos aspectos proporcionando métodos y módulos predeterminados para facilitar este estilo de diseño.
<hr>

Las siguientes tres secciones examinan los tres conceptos de programación que impulsaron el diseño de Java 8.

### 1.2.2. Stream processing - Procesamiento de flujo

El primer concepto de programación es el procesamiento de flujo. Para propósitos introductorios, un flujo es una secuencia de elementos de datos que se producen conceptualmente uno a la vez. Un programa puede leer elementos de un flujo de entrada uno por uno y, de manera similar, escribir elementos en un flujo de salida. El flujo de salida de un programa bien podría ser el flujo de entrada de otro.

Un ejemplo práctico es en Unix o Linux, donde muchos programas operan leyendo datos de la entrada estándar (stdin en Unix y C, System.in en Java), operando en ella y luego escribiendo sus resultados en la salida estándar (stdout en Unix y C, System.out en Java). Primero, un poco de trasfondo: Unix cat crea un flujo concatenando dos archivos, tr traduce los caracteres en un flujo, ordena ordena las líneas en un flujo y la cola -3 da las últimas tres líneas de un flujo. La línea de comandos de Unix permite que dichos programas se vinculen con conductos (|), dando ejemplos como

```sh
cat file1 file2  |  tr "[A-Z]"  "[a-z]"  |  sort  |  tail -3
```

que (suponiendo que file1 y file2 contienen una sola palabra por línea) imprime las tres palabras de los archivos que aparecen más recientes en el orden del diccionario, después de traducirlas primero a minúsculas. Decimos que ordenar toma un flujo de líneas [3] como entrada y produce otro flujo de líneas como salida (este último está ordenado), como se ilustra en la figura 1.2. Tenga en cuenta que en Unix estos comandos (cat, tr, sort y tail) se ejecutan al mismo tiempo, por lo que sort puede procesar las primeras líneas antes de que cat o tr hayan terminado. Una analogía más mecánica es una línea de ensamblaje de fabricación de automóviles en la que un flujo de automóviles se pone en cola entre las estaciones de procesamiento, cada una de las cuales toma un automóvil, lo modifica y lo pasa a la siguiente estación para su procesamiento posterior; el procesamiento en estaciones separadas suele ser simultáneo, aunque la línea de montaje es físicamente una secuencia.

<hr>
[3] Los puristas dirán un "flujo de caracteres", pero es conceptualmente más simple pensar que el orden reordena las líneas.
<hr>

![01-02](images/01-02.png)

**Java 8 agrega una API Streams** (tenga en cuenta la S mayúscula) en `java.util.stream` basada en esta idea; `Stream<T>` es una secuencia de elementos de tipo `T`. Puedes pensar en él como un iterador elegante por ahora. La API de Streams tiene muchos métodos que se pueden encadenar para formar una pipeline(tubería) compleja, al igual que los comandos de Unix se encadenaron en el ejemplo anterior.

La motivación clave para esto es que ahora puede programar en Java 8 en un nivel superior de abstracción, estructurando sus pensamientos de convertir un flujo de esto en un flujo de aquello (similar a cómo piensa cuando escribe consultas de base de datos) en lugar de un elemento a la vez. Otra ventaja es que Java 8 puede ejecutar de forma transparente su canalización de operaciones `Stream` en varios núcleos de CPU en partes separadas de la entrada; esto es un paralelismo *casi gratis* en lugar de un trabajo duro con `Threads`. ***Cubrimos la API de Java 8 Streams en detalle en los capítulos 4 a 7***.

### 1.2.3. Pasando código a métodos con parametrización de comportamiento

El segundo concepto de programación agregado a Java 8 es la capacidad de pasar un fragmento de código a una API. Esto suena terriblemente abstracto. En el ejemplo de Unix, es posible que desee indicarle al comando `sort` que utilice un orden personalizado. Aunque el comando `sort` admite parámetros de línea de comandos para realizar varios tipos predefinidos de clasificación, como el orden inverso, estos son limitados.

Por ejemplo, supongamos que tiene una colección de ID de factura con un formato similar a `2013UK0001`, `2014US0002`, etc. Los primeros cuatro dígitos representan el año, las siguientes dos letras un código de país y los últimos cuatro dígitos el ID de un cliente. Es posible que desee ordenar estos ID de factura por año o quizás utilizando el ID de cliente o incluso el código de país. Lo que desea es la capacidad de decirle al comando `sort` que tome como argumento un orden definido por el usuario: un fragmento de código separado que se pasa al comando `sort`.

Ahora, como un paralelo directo en Java, desea indicar un método de clasificación para comparar utilizando un orden personalizado. Podría escribir un método `compareUsingCustomerId` para comparar dos ID de facturas, pero, antes de Java 8, ¡no podía pasar este método a otro método! Podría crear un objeto `Comparator` para pasar al método `sort` como mostramos al comienzo de este capítulo, pero esto es detallado y ofusca la idea de simplemente reutilizar un comportamiento existente. Java 8 agrega la capacidad de pasar métodos (su código) como argumentos a otros métodos. La figura 1.3, basada en la figura 1.2, ilustra esta idea. También nos referimos a esto conceptualmente como parametrización del comportamiento. ¿Porque es esto importante? La API de Streams se basa en la idea de pasar código para parametrizar el comportamiento de sus operaciones, tal como pasó `compareUsingCustomerId` para parametrizar el comportamiento de `sort.`
Ahora, como un paralelo directo en Java, desea indicar un método de clasificación para comparar utilizando un orden personalizado. Podría escribir un método `compareUsingCustomerId` para comparar dos ID de facturas, pero, antes de Java 8, ¡no podía pasar este método a otro método! Podría crear un objeto `Comparator` para pasar al método `sort` como mostramos al comienzo de este capítulo, pero esto es detallado y ofusca la idea de simplemente reutilizar un comportamiento existente. Java 8 agrega la capacidad de pasar métodos (su código) como argumentos a otros métodos. La figura 1.3, basada en la figura 1.2, ilustra esta idea. También nos referimos a esto conceptualmente como parametrización del comportamiento. ¿Porque es esto importante? La API de Streams se basa en la idea de pasar código para parametrizar el comportamiento de sus operaciones, tal como pasó `compareUsingCustomerId` para parametrizar el comportamiento de `sort`.

![01-03](images/01-03.png)

Resumimos cómo funciona esto en la sección 1.3 de este capítulo, pero dejamos los detalles completos para los capítulos 2 y 3. Los capítulos 18 y 19 analizan cosas más avanzadas que puede hacer usando esta característica, con técnicas de la *comunidad de programación funcional*.

### 1.2.4. Paralelismo y datos mutables compartidos

El tercer concepto de programación es bastante más implícito y surge de la frase "paralelismo casi gratis" en nuestra discusión anterior sobre el procesamiento de secuencias. ¿A qué tienes que renunciar? Es posible que deba realizar algunos pequeños cambios en la forma en que codifica el comportamiento pasado a los métodos de transmisión. Al principio, estos cambios pueden resultar un poco incómodos, pero una vez que te acostumbres, te encantarán. Debe proporcionar un comportamiento que sea seguro para ejecutar simultáneamente en diferentes partes de la entrada. *Normalmente, esto significa escribir código que no acceda a los datos mutables compartidos para hacer su trabajo*. A veces, se denominan funciones puras o funciones sin efectos secundarios o funciones sin estado, y las discutiremos en detalle en los capítulos 18 y 19. El paralelismo anterior surge solo asumiendo que varias copias de su código pueden funcionar independientemente. Si hay una variable u objeto compartido, en el que se escribe, las cosas ya no funcionan. ¿Qué pasa si dos procesos quieren modificar la variable compartida al mismo tiempo? (La sección 1.4 ofrece una explicación más detallada con un diagrama). Encontrará más información sobre este estilo a lo largo del libro.

Los streams de Java 8 explotan el paralelismo más fácilmente que la API de subprocesos existente de Java, por lo que, aunque es posible usar sincronizado para romper la regla de datos mutables no compartidos, está luchando contra el sistema porque está abusando de una abstracción optimizada en torno a esa regla. El uso de la sincronización en varios núcleos de procesamiento suele ser mucho más costoso de lo esperado, porque la sincronización obliga al código a ejecutarse de forma secuencial, lo que va en contra del objetivo del paralelismo.

Dos de estos puntos (sin datos mutables compartidos y la capacidad de pasar métodos y funciones (código) a otros métodos) son las piedras angulares de lo que generalmente se describe como ***el paradigma de la programación funcional***, que verá en detalle en los capítulos 18 y 19. Por el contrario, en ***el paradigma de programación imperativa*** normalmente se describe un programa en términos de una secuencia de declaraciones que mutan el estado. El requisito de no compartir datos mutables significa que un método se describe perfectamente únicamente por la forma en que transforma los argumentos en resultados; en otras palabras, se comporta como una función matemática y no tiene efectos secundarios (visibles).

### 1.2.5. Java necesita evolucionar

Has visto la evolución en Java antes. Por ejemplo, la introducción de genéricos y el uso de `List<String>` en lugar de solo `List` puede haber sido inicialmente irritante. Pero ahora está familiarizado con este estilo y los beneficios que trae (detectar más errores en tiempo de compilación y hacer que el código sea más fácil de leer, porque ahora sabe qué es una lista).

Otros cambios han hecho que las cosas comunes sean más fáciles de expresar (por ejemplo, usar un bucle `for-each` en lugar de exponer el uso estándar de un iterador). *Los principales cambios en Java 8 reflejan un alejamiento de la orientación a objetos clásica*, que a menudo se centra en la mutación de valores existentes, *y hacia el espectro de programación de estilo funcional* en el que lo que desea hacer en términos generales (por ejemplo, crear un valor representar todas las rutas de transporte de A a B por menos de un precio determinado) se considera principal y se separa de cómo puede lograrlo (por ejemplo, escanear una estructura de datos modificando ciertos componentes). Tenga en cuenta que la programación clásica orientada a objetos y la programación funcional, como extremos, pueden parecer estar en conflicto. Pero la idea es obtener lo mejor de ambos paradigmas de programación, para que tenga más posibilidades de tener la herramienta adecuada para el trabajo. Discutimos esto en detalle en las secciones 1.3 y 1.4.

Una conclusión podría ser la siguiente: los lenguajes deben evolucionar para seguir las expectativas cambiantes del hardware o del programador (si necesita convencerse, considere que COBOL fue una vez uno de los lenguajes más importantes comercialmente). Para perdurar, Java tiene que evolucionar añadiendo nuevas funciones. Esta evolución no tendrá sentido a menos que se utilicen las nuevas funciones, por lo que al usar Java 8 estás protegiendo tu forma de vida como programador de Java. Además de eso, tenemos la sensación de que te encantará usar las nuevas funciones de Java 8. Pregúntele a cualquiera que haya usado Java 8 si está dispuesto a volver. Además, las nuevas características de Java 8 podrían, en la analogía del ecosistema, permitir a Java conquistar el territorio de las tareas de programación que actualmente ocupan otros lenguajes, por lo que los programadores de Java 8 tendrán aún más demanda.

Ahora presentamos los nuevos conceptos en Java 8, uno por uno, señalando los capítulos que cubren estos conceptos con más detalle.

## 1.3. FUNCIONES EN JAVA

La palabra *función* en los lenguajes de programación se usa comúnmente como *sinónimo de método*, particularmente un método estático; esto se suma a que se utiliza para funciones matemáticas, sin efectos secundarios. Afortunadamente, como verá, cuando Java 8 se refiere a funciones, estas las edades casi coinciden (these usages nearly coincide).

Java 8 agrega funciones como nuevas formas de valor. Estos facilitan el uso de streams, cubiertos en la sección 1.4, que Java 8 proporciona para explotar la programación paralela en procesadores multinúcleo. Comenzamos mostrando que las funciones como valores son útiles en sí mismas.

Piense en los posibles valores manipulados por los programas Java. ***Primero, hay valores primitivos*** como `42` (de tipo `int`) y `3.14` (de tipo double). ***En segundo lugar, los valores pueden ser objetos*** (más estrictamente, *referencias a objetos*). La única forma de obtener uno de estos es *utilizando `new`*, quizás mediante un método de factory o una función de una library; las referencias a objetos apuntan a *instancias* de una clase. Los ejemplos incluyen `"abc"` (de tipo `String`), `new Integer(1111)` (de tipo `Integer`) y el resultado `new HashMap<Integer, String>(100)` de llamar explícitamente a un constructor para `HashMap`. Incluso los arrays son objetos. ¿Cuál es el problema?

Para ayudar a responder a esto, notaremos que el objetivo de un lenguaje de programación es manipular valores, que, siguiendo la tradición histórica del lenguaje de programación, se denominan valores de primera clase (o citizens, en la terminología tomada de los años sesentas, movimiento de derechos humanos en los Estados Unidos). Otras estructuras en nuestros lenguajes de programación, que quizás nos ayuden a expresar la estructura de valores pero que no se pueden transmitir durante la ejecución del programa, son citizens de segunda clase. Los valores enumerados anteriormente son ciudadanos de Java de primera clase, pero varios otros conceptos de Java, como métodos y clases, ejemplifican ciudadanos de segunda clase. Los métodos están bien cuando se usan para definir clases, que a su vez pueden instanciarse para producir valores, pero tampoco los valores en sí. ¿Importa esto? Sí, resulta que poder pasar métodos en tiempo de ejecución y, por lo tanto, convertirlos en ciudadanos de primera clase, es útil en programación, por lo que los diseñadores de Java 8 agregaron la capacidad de expresar esto directamente en Java. Por cierto, podría preguntarse si convertir a otros ciudadanos de segunda clase, como las clases, en valores de ciudadanos de primera clase también podría ser una buena idea. Varios lenguajes como Smalltalk y JavaScript han explorado esta ruta.

### 1.3.1. Métodos y lambdas como ciudadanos de primera

Los experimentos en otros lenguajes, como Scala y Groovy, han determinado que permitir que conceptos como los métodos se usen como valores de primera clase facilitó la programación al agregar al conjunto de herramientas disponible para los programadores. Y una vez que los programadores se familiarizan con una característica poderosa, se vuelven reacios a usar lenguajes sin ella. Los diseñadores de Java 8 decidieron permitir que los métodos fueran valores, para facilitarle la programación. Además, la característica de Java 8 de métodos como valores forma la base de varias otras características de Java 8 (como Streams).

**La primera característica nueva de Java 8 que presentamos es la de *referencias a métodos***. Suponga que desea filtrar todos los archivos ocultos en un directorio. Debe comenzar a escribir un método que, dado un archivo, le dirá si está oculto. Afortunadamente, existe un método de este tipo en la clase `File` llamado `isHidden`. Puede verse como una función que toma un archivo y devuelve un valor `booleano`. Pero para usarlo para el filtrado, debe envolverlo en un objeto `FileFilter` que luego pasar al método `File.listFiles`, de la siguiente manera:

```java
File[] hiddenFiles = new File(".").listFiles(new FileFilter() {
    public boolean accept(File file) {
        return file.isHidden();                        1
    }
});
```

* ¡Filtrado de archivos ocultos![1]

¡Qué asco! Esto es horrible. Aunque son solo tres líneas significativas, son tres líneas opacas; todos recordamos haber dicho "¿Realmente tengo que hacerlo de esta manera?" en el primer encuentro. Ya tienes el método `isHidden` que podrías usar. ¿Por qué tiene que envolverlo en una clase `FileFilter` detallada y luego crear una instancia? Porque eso es lo que tenías que hacer antes de Java 8.

Ahora, puede reescribir ese código de la siguiente manera:

```java
File[] hiddenFiles = new File(".").listFiles(File::isHidden);
```

¡Guauu! ¿No es genial? Ya tienes la función `isHidden` disponible, así que la pasas al método `listFiles` usando el método Java 8 *method reference `::` syntax* (que significa “usar este método como un valor”); tenga en cuenta que también nos deslizamos en el uso de la palabra *función* para los métodos. Más adelante explicaremos cómo funciona la mecánica. Una ventaja es que su código ahora se lee más cerca de la declaración del problema.

He aquí una muestra de lo que se avecina: los métodos ya no son valores de segunda clase. De manera análoga a usar una referencia de objeto cuando pasa un objeto (y las referencias de objeto son creadas por `new`), en Java 8 cuando escribe `File::isHidden`, crea una *referencia de método*, que de manera similar se puede pasar. Este concepto se analiza en detalle en el capítulo 3. Dado que los métodos contienen código (el cuerpo ejecutable de un método), el uso de referencias de método permite pasar el código como en la figura 1.3. La figura 1.4 ilustra el concepto. También verá un ejemplo concreto (seleccionar manzanas de un inventario) en la siguiente sección.

![01-04](images/01-04.png)

![01-05](images/01-05.png)

![01-06](images/01-06.png)
