# Parte 1. Fundamentos

Esta primera parte del libro proporciona los fundamentos para ayudarlo a comenzar con las nuevas ideas de Java introducidas en Java 8. Al final de esta primera parte, tendrá una comprensión completa de lo que son las expresiones lambda y estará capaz de escribir código que sea lo suficientemente conciso y flexible para adaptarse fácilmente a los requisitos cambiantes.

En el capítulo 1, resumimos los cambios principales en Java (expresiones lambda, referencias de métodos, flujos y métodos predeterminados) y preparamos el escenario para el libro.

En el capítulo 2, aprenderá sobre la parametrización del comportamiento, un patrón de desarrollo de software en el que Java 8 se basa en gran medida y es la motivación para las expresiones lambda.

El Capítulo 3 ofrece una explicación completa, con ejemplos de código y cuestionarios en cada paso, de los conceptos de expresiones lambda y referencias a métodos.

# 01. Java 8, 9, 10 y 11: ¿qué está pasando?

Este capítulo cubre

* Por qué Java sigue cambiando
* Cambio de experiencia informática
* Presiones para que Java evolucione
* Presentamos nuevas funciones principales de Java 8 y 9

Desde el lanzamiento de Java Development Kit (JDK 1.0) en 1996, Java ha ganado un gran número de seguidores de estudiantes, gerentes de proyectos y programadores que son usuarios activos. Es un lenguaje expresivo y se sigue utilizando para proyectos tanto grandes como pequeños. Su evolución (mediante la incorporación de nuevas funciones) de Java 1.1 (1997) a Java 7 (2011) ha sido bien gestionada. Java 8 se lanzó en marzo de 2014, Java 9 en septiembre de 2017, Java 10 en marzo de 2018 y Java 11 previsto para septiembre de 2018. La pregunta es esta: ¿Por qué deberían preocuparse por estos cambios?

## 1.1. Entonces, ¿cuál es la gran historia?

Argumentamos que los cambios en Java 8 fueron, en muchos sentidos, más profundos que cualquier otro cambio en Java en su historia (Java 9 agrega cambios de productividad importantes, pero menos profundos, como verá más adelante en este capítulo, mientras que Java 10 hace ajustes mucho más pequeños a la inferencia de tipos). La buena noticia es que los cambios le permiten escribir programas con mayor facilidad. Por ejemplo, en lugar de escribir un código detallado (para ordenar una lista de manzanas en el inventario según su peso) como

```java
Collections.sort(inventory, new Comparator<Apple>() {
    public int compare(Apple a1, Apple a2){
        return a1.getWeight().compareTo(a2.getWeight());
    }
});
```

en Java 8 puede escribir un código más conciso que se lea mucho más cerca de la declaración del problema, como el siguiente:

```java
inventory.sort(comparing(Apple::getWeight));
```

### 1 ¡El primer código Java 8 del libro!

Dice "ordenar inventario comparando el peso de la manzana". No se preocupe por este código por ahora. Este libro le explicará qué hace y cómo puede escribir un código similar.

También hay una influencia del hardware: las CPU básicas se han convertido en multinúcleo; el procesador de su computadora portátil o de escritorio probablemente contiene cuatro o más núcleos de CPU. Pero la gran mayoría de los programas Java existentes usan solo uno de estos núcleos y dejan los otros tres inactivos (o gastan una pequeña fracción de su poder de procesamiento ejecutando parte del sistema operativo o un antivirus).

Antes de Java 8, los expertos podrían decirle que debe usar subprocesos para usar estos núcleos. El problema es que trabajar con subprocesos es difícil y propenso a errores. Java ha seguido un camino evolutivo de intentar continuamente hacer que la concurrencia sea más fácil y menos propensa a errores. Java 1.0 tenía subprocesos y bloqueos e incluso un modelo de memoria, la mejor práctica en ese momento, pero estas primitivas demostraron ser demasiado difíciles de usar de manera confiable en equipos de proyectos no especializados. Java 5 agregó bloques de construcción de fuerza industrial como grupos de subprocesos y colecciones concurrentes. Java 7 agregó el marco de bifurcación/unión, lo que hace que el paralelismo sea más práctico pero aún difícil. Java 8 nos dio una forma nueva y más sencilla de pensar sobre el paralelismo. Pero aún debe seguir algunas reglas, que aprenderá en este libro.

Como verá más adelante en este libro, Java 9 agrega un método de estructuración adicional para la concurrencia: la programación reactiva. Aunque esto tiene un uso más especializado, estandariza un medio para explotar los kits de herramientas de flujos reactivos **RxJava** y **Akka** que se están volviendo populares para sistemas altamente concurrentes.

De los dos desiderata anteriores (código más conciso y uso más simple de procesadores multinúcleo) surge todo el edificio consistente capturado por Java 8. Comenzamos por darle una muestra rápida de estas ideas (con suerte lo suficiente como para intrigarlo, pero lo suficientemente breve como para resumirlas ):

* La API de Streams
* Técnicas para pasar código a métodos
* Métodos predeterminados en interfaces

Java 8 proporciona una nueva API (llamada Streams) que admite muchas operaciones paralelas para procesar datos y se parece a la forma en que podría pensar en los lenguajes de consulta de bases de datos: usted expresa lo que quiere de una manera de nivel superior y la implementación (aquí, la biblioteca Streams ) elige el mejor mecanismo de ejecución de bajo nivel. Como resultado, evita la necesidad de escribir código sincronizado, que no solo es muy propenso a errores, sino que también es más caro de lo que se imagina en las CPU multinúcleo. [1]

<hr>
[1] Las CPU multinúcleo tienen cachés separados (memoria rápida) conectados a cada núcleo del procesador. El bloqueo requiere que estos estén sincronizados, lo que requiere una comunicación entre núcleos de protocolo de coherencia de caché relativamente lenta.
Desde un punto de vista ligeramente revisionista, la adición de Streams en Java 8 puede verse como una causa directa de las otras dos adiciones a Java 8: técnicas concisas para pasar código a métodos (referencias de métodos, lambdas) y métodos predeterminados en interfaces.
<hr>

Pero pensar en pasar código a métodos como una mera consecuencia de Streams minimiza su rango de usos dentro de Java 8. Le brinda una nueva forma concisa de expresar la parametrización del comportamiento. Suponga que desea escribir dos métodos que difieren solo en unas pocas líneas de código. Ahora puede simplemente pasar el código de las partes que difieren como argumento (esta técnica de programación es más corta, más clara y menos propensa a errores que la tendencia común de usar copiar y pegar). Los expertos notarán aquí que la parametrización del comportamiento podría, antes de Java 8, codificarse usando clases anónimas, pero dejaremos que el ejemplo al principio de este capítulo, que muestra una mayor concisión del código con Java 8, hable por sí mismo en términos de claridad. .

La característica de Java 8 de pasar código a métodos (y poder devolverlo e incorporarlo en estructuras de datos) también proporciona acceso a una variedad de técnicas adicionales que comúnmente se conocen como programación de estilo funcional. En pocas palabras, dicho código, llamado funciones en la comunidad de programación funcional, puede transmitirse y combinarse de manera que produzca potentes modismos de programación que verá en Java a lo largo de este libro.


El meollo de este capítulo comienza con una discusión de alto nivel sobre por qué evolucionan los lenguajes, continúa con secciones sobre las características principales de Java 8 y luego presenta las ideas de programación de estilo funcional que las nuevas características simplifican el uso y que las nuevas arquitecturas de computadora favorecen. En esencia, la sección 1.2 analiza el proceso de evolución y los conceptos, de los que antes carecía Java, para explotar el paralelismo multinúcleo de una manera fácil. La sección 1.3 explica por qué pasar código a métodos en Java 8 es un nuevo lenguaje de programación tan poderoso, y la sección 1.4 hace lo mismo para Streams, la nueva forma de Java 8 de representar datos secuenciados e indicar si estos pueden procesarse en paralelo. La Sección 1.5 explica cómo la nueva característica de Java 8 de métodos predeterminados permite que las interfaces y sus bibliotecas evolucionen con menos complicaciones y menos recompilación; También explica la adición de módulos a Java 9, que permite que los componentes de grandes sistemas Java se especifiquen con más claridad que "solo un archivo JAR de paquetes". Finalmente, la sección 1.6 analiza las ideas de programación de estilo funcional en Java y otros lenguajes que comparten la JVM. En resumen, este capítulo introduce ideas que se elaboran sucesivamente en el resto del libro. ¡Disfruta el viaje!

## 1.2. ¿POR QUÉ JAVA AÚN ESTÁ CAMBIANDO?

Con la década de 1960 llegó la búsqueda del lenguaje de programación perfecto. Peter Landin, un famoso científico informático de su época, señaló en 1966 en un artículo histórico [2] que ya había 700 lenguajes de programación y especuló sobre cómo serían los próximos 700, incluidos argumentos para una programación de estilo funcional similar a ese en Java 8.

<hr>
[2] P. J. Landin, "The Next 700 Programming Languages", CACM 9 (3): 157–65, marzo de 1966.
<hr>

Muchos miles de lenguajes de programación más tarde, los académicos han llegado a la conclusión de que los lenguajes de programación se comportan como ecosistemas: aparecen nuevos lenguajes y los lenguajes antiguos son suplantados a menos que evolucionen. Todos esperamos un lenguaje universal perfecto, pero en realidad ciertos lenguajes se adaptan mejor a determinados nichos. Por ejemplo, C y C ++ siguen siendo populares para la construcción de sistemas operativos y varios otros sistemas integrados debido a su pequeña huella de tiempo de ejecución y a pesar de su falta de seguridad en la programación. Esta falta de seguridad puede llevar a que los programas se bloqueen de manera impredecible y expongan agujeros de seguridad para virus y similares; de hecho, los lenguajes con seguridad de tipos como Java y C# han suplantado a C y C++ en varias aplicaciones cuando la huella de tiempo de ejecución adicional es aceptable.

La ocupación previa de un nicho tiende a desanimar a los competidores. Cambiar a un nuevo idioma y cadena de herramientas suele ser demasiado doloroso para una sola función, pero los recién llegados eventualmente desplazarán los idiomas existentes, a menos que evolucionen lo suficientemente rápido como para mantenerse al día. (Los lectores mayores a menudo pueden citar una variedad de esos lenguajes en los que han codificado previamente pero cuya popularidad ha disminuido desde entonces: Ada, Algol, COBOL, Pascal, Delphi y SNOBOL, por nombrar solo algunos).

Eres un programador de Java, y Java ha logrado colonizar (y desplazar lenguajes de la competencia) un gran nicho de ecosistema de tareas de programación durante casi 20 años. Examinemos algunas razones para eso.

### 1.2.1. El lugar de Java en el ecosistema de lenguajes de programación

Java empezó bien. Desde el principio, fue un lenguaje orientado a objetos bien diseñado con muchas bibliotecas útiles. También admitió la concurrencia a pequeña escala desde el primer día con su soporte integrado para subprocesos y bloqueos (y con su temprano reconocimiento profético, en forma de un modelo de memoria neutral de hardware, que los subprocesos concurrentes en procesadores multinúcleo pueden tener comportamientos inesperados además de los que ocurren en procesadores de un solo núcleo). Además, la decisión de compilar Java en código de bytes JVM (un código de máquina virtual que pronto todos los navegadores admitieron) significó que se convirtió en el idioma preferido para los programas de subprogramas de Internet (¿recuerda los subprogramas?). De hecho, existe el peligro de que Java Virtual Machine (JVM) y su código de bytes se consideren más importantes que el propio lenguaje Java y que, para ciertas aplicaciones, Java pueda ser reemplazado por uno de sus lenguajes competidores como Scala, Groovy, o Kotlin, que también se ejecuta en JVM. Varias actualizaciones recientes de la JVM (por ejemplo, el nuevo código de bytes dinámico invocado en JDK7) tienen como objetivo ayudar a que los lenguajes de la competencia se ejecuten sin problemas en la JVM y que interoperen con Java. Java también ha tenido éxito en colonizar varios aspectos de la computación integrada (desde tarjetas inteligentes, tostadoras y decodificadores hasta sistemas de frenado de automóviles).

#### ¿Cómo entró Java en un nicho de programación general?

<hr>
La orientación a objetos se puso de moda en la década de 1990 por dos razones: su disciplina de encapsulación resultó en menos problemas de ingeniería de software que los de C; y como modelo mental, capturó fácilmente el modelo de programación WIMP de Windows 95 y versiones posteriores. Esto se puede resumir de la siguiente manera: todo es un objeto; y un clic del mouse envía un mensaje de evento a un controlador (invoca el método de clic en un objeto Mouse). El modelo de Java de escritura única y ejecución en cualquier lugar y la capacidad de los primeros navegadores para ejecutar (de forma segura) los subprogramas de código Java le dieron un nicho en las universidades, cuyos graduados entonces poblaron la industria. Hubo una resistencia inicial al costo de ejecución adicional de Java sobre C/C++, pero las máquinas se hicieron más rápidas y el tiempo del programador se volvió cada vez más importante. C# de Microsoft validó aún más el modelo orientado a objetos de estilo Java.
<hr>

Pero el clima está cambiando para el ecosistema de lenguajes de programación; Los programadores se ocupan cada vez más de los llamados big data (conjuntos de datos de terabytes y más) y desean explotar computadoras multinúcleo o clústeres informáticos de manera eficaz para procesarlos. Y esto significa usar procesamiento paralelo, algo que Java no era compatible con anterioridad. Es posible que haya encontrado ideas de otros nichos de programación (por ejemplo, map-reduce de Google o la relativa facilidad de manipulación de datos con lenguajes de consulta de bases de datos como SQL) que lo ayudan a trabajar con grandes volúmenes de datos y CPU multinúcleo. La Figura 1.1 resume gráficamente el ecosistema del lenguaje: piense en el paisaje como el espacio de los problemas de programación y la vegetación dominante de un terreno en particular como el lenguaje favorito para ese programa. El cambio climático es la idea de que nueva hardware o nuevas influencias de programación (por ejemplo, "¿Por qué no puedo programar en un estilo similar a SQL?") significan que diferentes lenguajes se convierten en el lenguaje de elección para nuevos proyectos, al igual que el aumento de las temperaturas regionales significa que las uvas ahora prosperan en latitudes más altas. . Pero hay histéresis: muchos agricultores antiguos seguirán cultivando cultivos tradicionales. En resumen, están apareciendo nuevos idiomas y se están volviendo cada vez más populares porque se han adaptado rápidamente al cambio climático.

![01-01](images/01-01.png)

El principal beneficio de las adiciones de Java 8 para un programador es que brindan más herramientas y conceptos de programación para resolver problemas de programación nuevos o existentes más rápidamente o, lo que es más importante, de una manera más concisa y fácil de mantener. Aunque los conceptos son nuevos en Java, han demostrado su eficacia en lenguajes de investigación de nicho. En las siguientes secciones, destacaremos y desarrollaremos las ideas detrás de tres de estos conceptos de programación que han impulsado el desarrollo de las funciones de Java 8 para aprovechar el paralelismo y escribir código más conciso en general. Los presentaremos en un orden ligeramente diferente del resto del libro para habilitar una analogía basada en Unix y exponer las dependencias de "necesito esto por eso" en el nuevo paralelismo de Java 8 para multinúcleo.

#### Otro factor de cambio climático para Java

<hr>
Un factor del cambio climático implica cómo se diseñan los grandes sistemas. Hoy en día, es común que un sistema grande incorpore subsistemas de componentes grandes de otros lugares, y tal vez estos se construyan sobre otros componentes de otros proveedores. Peor aún, estos componentes y sus interfaces también tienden a evolucionar. Java 8 y Java 9 han abordado estos aspectos proporcionando métodos y módulos predeterminados para facilitar este estilo de diseño.
<hr>

Las siguientes tres secciones examinan los tres conceptos de programación que impulsaron el diseño de Java 8.

#### 1.2.2. Stream processing - Procesamiento de flujo

El primer concepto de programación es el procesamiento de flujo. Para propósitos introductorios, un flujo es una secuencia de elementos de datos que se producen conceptualmente uno a la vez. Un programa puede leer elementos de un flujo de entrada uno por uno y, de manera similar, escribir elementos en un flujo de salida. El flujo de salida de un programa bien podría ser el flujo de entrada de otro.

Un ejemplo práctico es en Unix o Linux, donde muchos programas operan leyendo datos de la entrada estándar (stdin en Unix y C, System.in en Java), operando en ella y luego escribiendo sus resultados en la salida estándar (stdout en Unix y C, System.out en Java). Primero, un poco de trasfondo: Unix cat crea un flujo concatenando dos archivos, tr traduce los caracteres en un flujo, ordena ordena las líneas en un flujo y la cola -3 da las últimas tres líneas de un flujo. La línea de comandos de Unix permite que dichos programas se vinculen con conductos (|), dando ejemplos como

```sh
cat file1 file2  |  tr "[A-Z]"  "[a-z]"  |  sort  |  tail -3
```

que (suponiendo que file1 y file2 contienen una sola palabra por línea) imprime las tres palabras de los archivos que aparecen más recientes en el orden del diccionario, después de traducirlas primero a minúsculas. Decimos que ordenar toma un flujo de líneas [3] como entrada y produce otro flujo de líneas como salida (este último está ordenado), como se ilustra en la figura 1.2. Tenga en cuenta que en Unix estos comandos (cat, tr, sort y tail) se ejecutan al mismo tiempo, por lo que sort puede procesar las primeras líneas antes de que cat o tr hayan terminado. Una analogía más mecánica es una línea de ensamblaje de fabricación de automóviles en la que un flujo de automóviles se pone en cola entre las estaciones de procesamiento, cada una de las cuales toma un automóvil, lo modifica y lo pasa a la siguiente estación para su procesamiento posterior; el procesamiento en estaciones separadas suele ser simultáneo, aunque la línea de montaje es físicamente una secuencia.

<hr>
[3] Los puristas dirán un "flujo de caracteres", pero es conceptualmente más simple pensar que el orden reordena las líneas.
<hr>

![01-02](images/01-02.png)

