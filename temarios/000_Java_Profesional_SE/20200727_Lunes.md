# 20200727 Lunes

### Nota

Los Lambda no tienen un tipo, se determina en tiempo de ejecución. Cuando algo espera un object y le metemos un Lambda directamentge me puede marcar un error de compilación por un Lambda no tiene tipo.

## Nueva Multitarea

<img src="images/M2-10-01.png">

<img src="images/M2-10-02.png">

<img src="images/M2-10-03.png">

<img src="images/M2-10-04.png">

<img src="images/M2-10-05.png">

<img src="images/M2-10-06.png">

<img src="images/M2-10-07.png">

## `ExecutorService`

Vamos a realizar algunos ejemplos que muestren la forma Clásica de la Multitarea con la forma Nueva.

### :computer: `000-058-01_ejercicio_tablas_multiplicar_concurrente_Clasica`

<img src="images/20200727-01.png">

*`Acumulador`*

```java
package recurso;

public class Acumulador {
	
   private int valor;

   public int getValor() {
      return valor;
   }

   public void setValor(int valor) {
      this.valor = valor;
   }	
}
```

*`TareaGenerarTabla`*

```java
package tarea;

public class TareaGenerarTabla implements Runnable{
	
   private int num;
		
   public TareaGenerarTabla(int num) {
      super();
      this.num = num;	
   }

   @Override
   public void run() {
      for(int i=1; i<=10; i++) {
	 System.out.println( num + " * " + i + " = " + (num * i));
	 try {
	    Thread.sleep(100);
	 } catch (InterruptedException e) {
	    e.printStackTrace();
	 }
      }
   }
}
```

*`Tablas`*

```java
package principal;

import tarea.TareaGenerarTabla;

public class Tablas {

   public static void main(String[] args) {
      lanzador(new TareaGenerarTabla(5));
      lanzador(new TareaGenerarTabla(7));
      lanzador(new TareaGenerarTabla(3));
   }

   // Lanzo start() del Thread a partir del Runnable
   private static void lanzador(Runnable r) {
      new Thread(r).start();
   }
}
```

### :computer: `000-058-02_ejercicio_tablas_multiplicar_concurrente_moderno_con_ExecutorService`

<img src="images/20200727-02.png">

Las clases `Acumulador` y `TareaGenerarTabla` son exactamente iguales solo cambia `Tablas` donde en lugar de usar **`Thread`** usamos **`ExecutorService`** 

*`Tablas`*

```java
package principal;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import tarea.TareaGenerarTabla;

public class Tablas {
   static ExecutorService executor = Executors.newCachedThreadPool(); // Multihilo
   //static ExecutorService executor = Executors.newSingleThreadExecutor(); //Un solo hilo
   //static ExecutorService executor = Executors.newFixedThreadPool(2); //Dos hilos
   public static void main(String[] args) {
      lanzador(new TareaGenerarTabla(5));
      lanzador(new TareaGenerarTabla(7));
      lanzador(new TareaGenerarTabla(3));
      executor.shutdown();
   }

   // Lanzo start() del Thread a partir del Runnable
   private static void lanzador(Runnable t) {
      executor.submit(t);
   }

}
```

Existen 3 Formas de usarlo:

* `Executors.newCachedThreadPool()`:  Multihilo.
* `Executors.newSingleThreadExecutor()`: Un solo hilo.
* `Executors.newFixedThreadPool(2)`: con un determinado número de hilos.

Vamos a ver la salida en cada caso.

Con `Executors.newCachedThreadPool()`:

<img src="images/20200727-03.png">

Con `Executors.newSingleThreadExecutor()`:

<img src="images/20200727-04.png">

Con `Executors.newFixedThreadPool(2)`:

<img src="images/20200727-05.png">

La instrucción `executor.shutdown();` es importante por que si no se pone el `ExecutorService` sigue activo por lo que el programa no termina, hay que ponerla para evitar esto.

## `Callable` y `Future`.

### :computer: `000-059_factoriales_multitarea_Callable_Future`

<img src="images/20200727-06.png">

*`Factorial`*

```java
package tareas;

import java.util.concurrent.Callable;

public class Factorial implements Callable<Long>{
   
   private int n;
   public Factorial(int n) {
      this.n=n;
   }
	
   @Override
   public Long call() { //throws Exception { Puedo manejar internamente la exepción no como lo define la interfaz
      long aux=1;
      for (int i = 1; i <= n; i++) {
	 aux *=i;
	 try {
	    Thread.sleep(200);
	 } catch (InterruptedException e) {
	    e.printStackTrace();
	 }		
      }
      return aux;
   }

}
```

*`TestFactorial`*

```java
package principal;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import tareas.Factorial;

public class TestFactorial {

   public static void main(String[] args) throws InterruptedException, ExecutionException  {
      ExecutorService exec = Executors.newCachedThreadPool();
      Future<Long> f= exec.submit(new Factorial(7));
      while(!f.isDone()) {
	 System.out.println("Haciendo cosas en el main");
	 try {
	    Thread.sleep(50);
	 } catch (InterruptedException e) {
	    e.printStackTrace();
	 }
      }
      System.out.println("El resultado del factorial es: " + f.get());
      exec.shutdown();
   }

}
```

<img src="images/20200727-07.png">

## Sincronización Vs `.lock()` y `.unlock()`

Vamos a comparar la forma anterior de la Sincronización con la forma nueva usando los métodos `.lock()` y `.unlock()`.


### :computer: `000-060-01_ejercicio_tablas_multiplicar_concurrente_syncronyze`

<img src="images/20200727-08.png">

*`Acumulador`*

```java
package recurso;

public class Acumulador {
	
   private int valor;

   public int getValor() {
      return valor;
   }

   public void setValor(int valor) {
      this.valor = valor;
   }
}
```

*`TareaGenerarTabla`*

```java
package tarea;

import recurso.Acumulador;

public class TareaGenerarTabla implements Runnable {

   private int num;
   private Acumulador acumulador;

   public TareaGenerarTabla(int num, Acumulador acumulador) {
      super();
      this.num = num;
      this.acumulador = acumulador;
   }

   @Override
   public void run() {
      for (int i = 1; i <= 10; i++) {
	 System.out.println(num + " * " + i + " = " + (num * i));

	  synchronized (acumulador) {
	     int valor = acumulador.getValor();
	     valor += num * i;
	     try {
		Thread.sleep(100);
	     } catch (InterruptedException e) {
	        e.printStackTrace();
	     }
	     acumulador.setValor(valor);
	  }
       }
       System.out.println("VALOR ACTUAL DEL ACUMULADOR: " + acumulador.getValor());
   }
}
```

*`Tablas`*

```java
package principal;

import java.util.Scanner;

import recurso.Acumulador;
import tarea.TareaGenerarTabla;

public class Tablas {

   public static void main(String[] args) {

      final int totalNumeros = 2;
      int[] nums = new int[totalNumeros];
		
      Acumulador acumulador = new Acumulador();
			
      Scanner sc = new Scanner(System.in);

      for (int i = 0; i <= totalNumeros - 1; i++) {

	 System.out.println("Inserta el número " + (i + 1) + ": ");
	 String numStr = sc.nextLine();

	 nums[i] = Integer.parseInt(numStr);
      }

      for (int n:nums) {
	 lanzador(new TareaGenerarTabla(n, acumulador));
      }
   }

   // Lanzo start() del Thread a partir del Runnable
   private static void lanzador(Runnable r) {
      new Thread(r).start();
   }

}
```

<img src="images/20200727-10.png">


### :computer: `000-060-02_ejercicio_tablas_multiplicar_concurrente_syncronyze_con_lock`

<img src="images/20200727-09.png">

*`Acumulador`* (Exactamente igual al anterior)

```java
package recurso;

public class Acumulador {
	
   private int valor;

   public int getValor() {
      return valor;
   }

   public void setValor(int valor) {
      this.valor = valor;
   }
}
```

*`TareaGenerarTabla`*

```java
package tarea;

import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

import recurso.Acumulador;

public class TareaGenerarTabla implements Runnable {

   private int num;
   private Acumulador acumulador;
   static Lock lc= new ReentrantLock();

   public TareaGenerarTabla(int num, Acumulador acumulador) {
      super();
      this.num = num;
      this.acumulador = acumulador;
   }

   @Override
   public void run() {
      for (int i = 1; i <= 10; i++) {
	 System.out.println(num + " * " + i + " = " + (num * i));

	 lc.lock();
	    int valor = acumulador.getValor();
	    valor += num * i;
	    try {
	       Thread.sleep(100);
	    } catch (InterruptedException e) {
	       e.printStackTrace();
	    }
	    acumulador.setValor(valor);
	    lc.unlock();
      }
      System.out.println("VALOR ACTUAL DEL ACUMULADOR: " + acumulador.getValor());
   }
}
```

*`Tablas`*

```java
package principal;

import java.util.Scanner;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import recurso.Acumulador;
import tarea.TareaGenerarTabla;

public class Tablas {

   public static ExecutorService executor = Executors.newCachedThreadPool();

   public static void main(String[] args) {

      final int totalNumeros = 2;
      int[] nums = new int[totalNumeros];
		
      Acumulador acumulador = new Acumulador();
		
      Scanner sc = new Scanner(System.in);

      for (int i = 0; i <= totalNumeros - 1; i++) {
	 System.out.println("Inserta el número " + (i + 1) + ": ");
	 String numStr = sc.nextLine();

	 nums[i] = Integer.parseInt(numStr);
      }

      for (int n:nums) {
	 lanzador(new TareaGenerarTabla(n, acumulador));
      }
      executor.shutdown();
   }

   // Lanzo start() del Thread a partir del Runnable
   private static void lanzador(Runnable t) {
      executor.submit(t);
   }
   
}
```

<img src="images/20200727-11.png">




