# 20200727 Lunes

### Nota

Los Lambda no tienen un tipo, se determina en tiempo de ejecución. Cuando algo espera un object y le metemos un Lambda directamentge me puede marcar un error de compilación por un Lambda no tiene tipo.

## Nueva Multitarea

<img src="images/M2-10-01.png">

<img src="images/M2-10-02.png">

<img src="images/M2-10-03.png">

<img src="images/M2-10-04.png">

<img src="images/M2-10-05.png">

<img src="images/M2-10-06.png">

<img src="images/M2-10-07.png">

## `ExecutorService`

Vamos a realizar algunos ejemplos que muestren la forma Clásica de la Multitarea con la forma Nueva.

### :computer: `000-058-01_ejercicio_tablas_multiplicar_concurrente_Clasica`

<img src="images/20200727-01.png">

*`Acumulador`*

```java
package recurso;

public class Acumulador {
	
	private int valor;

	public int getValor() {
		return valor;
	}

	public void setValor(int valor) {
		this.valor = valor;
	}	
}
```

*`TareaGenerarTabla`*

```java
package tarea;

public class TareaGenerarTabla implements Runnable{
	
	private int num;
	
	
	public TareaGenerarTabla(int num) {
		super();
		this.num = num;
		
	}

	@Override
	public void run() {
		for(int i=1; i<=10; i++) {
			System.out.println( num + " * " + i + " = " + (num * i));
			try {
				Thread.sleep(100);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			
		}
	}
}
```

*`Tablas`*

```java
package principal;

import tarea.TareaGenerarTabla;

public class Tablas {

	public static void main(String[] args) {
			lanzador(new TareaGenerarTabla(5));
			lanzador(new TareaGenerarTabla(7));
			lanzador(new TareaGenerarTabla(3));
	}

	// Lanzo start() del Thread a partir del Runnable
	private static void lanzador(Runnable r) {
		new Thread(r).start();
	}

}
```

### :computer: `000-058-02_ejercicio_tablas_multiplicar_concurrente_moderno_con_ExecutorService`

<img src="images/20200727-02.png">

Las clases `Acumulador` y `TareaGenerarTabla` son exactamente iguales solo cambia `Tablas` donde en lugar de usar **`Thread`** usamos **`ExecutorService`** 

*`Tablas`*

```java
package principal;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;

import tarea.TareaGenerarTabla;

public class Tablas {
    static ExecutorService executor = Executors.newCachedThreadPool(); // Multihilo
	//static ExecutorService executor = Executors.newSingleThreadExecutor(); //Un solo hilo
	//static ExecutorService executor = Executors.newFixedThreadPool(2); //Dos hilos
	public static void main(String[] args) {
			lanzador(new TareaGenerarTabla(5));
			lanzador(new TareaGenerarTabla(7));
			lanzador(new TareaGenerarTabla(3));
			executor.shutdown();
	}

	// Lanzo start() del Thread a partir del Runnable
	private static void lanzador(Runnable t) {
		executor.submit(t);
	}

}
```

Existen 3 Formas de usarlo:

* `Executors.newCachedThreadPool()`:  Multihilo.
* `Executors.newSingleThreadExecutor()`: Un solo hilo.
* `Executors.newFixedThreadPool(2)`: con un determinado número de hilos.

Vamos a ver la salida en cada caso.

Con `Executors.newCachedThreadPool()`:

<img src="images/20200727-03.png">

Con `Executors.newSingleThreadExecutor()`:

<img src="images/20200727-04.png">

Con `Executors.newFixedThreadPool(2)`:

<img src="images/20200727-05.png">

La instrucción `executor.shutdown();` es importante por que si no se pone el `ExecutorService` sigue activo por lo que el programa no termina, hay que ponerla para evitar esto.

## `Callable` y `Future`.

### :computer: `000-059_factoriales_multitarea_Callable_Future`

<img src="images/20200727-06.png">

*`Factorial`*

```java
package tareas;

import java.util.concurrent.Callable;

public class Factorial implements Callable<Long>{
    private int n;
    public Factorial(int n) {
    	this.n=n;
    }
	
	@Override
	public Long call() { //throws Exception { Puedo manejar internamente la exepción no como lo define la interfaz
		long aux=1;
		for (int i = 1; i <= n; i++) {
			aux *=i;
			try {
				Thread.sleep(200);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
			
		}
		return aux;
	}

}
```

*`TestFactorial`*

```java
package principal;

import java.util.concurrent.ExecutionException;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.Future;

import tareas.Factorial;

public class TestFactorial {

	public static void main(String[] args) throws InterruptedException, ExecutionException  {
		ExecutorService exec = Executors.newCachedThreadPool();
		Future<Long> f= exec.submit(new Factorial(7));
		while(!f.isDone()) {
			System.out.println("Haciendo cosas en el main");
			try {
				Thread.sleep(50);
			} catch (InterruptedException e) {
				e.printStackTrace();
			}
		}
		System.out.println("El resultado del factorial es: " + f.get());
		exec.shutdown();
	}

}
```

<img src="images/20200727-07.png">








